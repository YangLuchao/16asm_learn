[toc]

# 10.7 80386的中断和异常

第5章介绍了中断的基本概念和8086/8088处理中断的有关内容。80386除了保持8086/8088的相关功能外，还增强了中断处理功能，并引入“异常”的概念。本节在第5章的基础上介绍80386的中断和异常。

## 10.7.1 80386的中断和异常

8086/8088把中断分为内部中断和外部中断两大类。为了支持多任务和虚拟存储器等功能，==80386把外部中断称为`中断`，把内部中断称为`异常`==。与8086/8088一样，==80386通常在两条指令之间响应中断或异常；80386最多处理256种中断或异常==。

### 1. 中断

对80386而言，==中断是由异步的外部事件引起的==。外部事件及中断响应与正执行的指令没有关系。通常，中断用于指示`I/O`设备的一次操作已完成。与8086/8088一样，==80386有两根引脚`INTR`和`NMI`接受外部中断请求信号==。==`INTR`接受可屏蔽中断请求。`NMI`接受不可屏蔽中断请求==。==在80386中，标志寄存器`EFLAGS`中的`IF`标志决定是否屏蔽可屏蔽中断请求==。
外部硬件在通过`INTR`发出中断请求信号的同时，还要向处理器给出一个8位的中断向量号。处理器在响应可屏蔽中断请求时，读取这个由外部硬件给出的中断向量号。处理器对这个中断向量号并没有规定。但在具体的微机系统中，系统必须通过软件和硬件的配合设置，使得给出的这个中断向量号不仅与外部中断源对应，而且要避免中断向量号使用冲突情况的出现。可编程中断控制器芯片8259A可配合80386工作，能够根据设置向处理器提供上述这个中断向量号和还能处理中断请求的优先级，每个8259A芯片可以支持8路中断请求信号，如果使用9个8259A芯片，就可使80386在单个引脚`INTR`上接受多达64个中断源的中断请求信号。
==处理器不屏蔽来自`NMI`的中断请求==。处理器在响应`NMI`中断时，不从外部硬件接收中断向量号。与8086/8088一样，在80386中，==不可屏蔽中断所对应的中断向量号固定为2==。==为了避免不可屏蔽中断的嵌套，每当接受一个`NMI`中断，处理器就在内部屏蔽了再次响应`NMI`，这一屏蔽过程直到执行中断返回指令`IRET`后才结束==。==所以，`NMI`处理程序应以`IRET`指令结束==。

### 2. 异常

==异常是80386在执行指令期间检测到不正常的或非法的条件所引起的==。异常与正执行的指令有直接的联系。例如：执行除法指令时，除数等于0。再如，执行指令时发现特级不正确。当发生这些情况时，指令就不能成功完成。软中断指令`INTn`和`INT0`也归类于异常而不称为中断，这是因为执行这些指令产生异常事件。
80386识别多种不同类别的异常，并赋予每一种类别不同的中断向量号。异常发生后，处理器就象响应中断那样处理异常。也即，根据中断向量号，转相应的中断处理程序。把这种中断处理程序称为异常处理程序可能更合适。
==根据引起异常的程序是否可被恢复和恢复点不同，把异常进一步分类为故障(Fault)、陷阱(Tap)和中止(Abort)==。我们把对应的异常处理程序分别称为故障处理程序、陷阱处理程序和中止处理程序。
==故障是在引起异常的指令之前，把异常情况通知给系统的一种异常==。==80386认为故障是可排除的==。==当控制转移到故障处理程序时，所保存的断点`CS`及`EIP`的值指向引起故障的指令==。==这样，在故障处理程序把故障排除后，执行`IRET`返回到引起故障的程序继续执行时，刚才引起故障的指令可重新得到执行==。这种重新执行，不需要操作系统软件的额外参与。故障的发现可能在指令开始执行之前，也可能在指令执行期间。如果在执行指令期间检测到故障，那么中止故障指令，并把指令的源操作数恢复为指令开始执行之前的值。这可保证故障指令的重新执行得到正确的结果。例如，在一条指令的执行期间，如果发现段不存在，那么停止该指令的执行，并通知系统产生段故障，对应的段故障处理程序可通过加载该段的方法来排除故障，之后，原指令就可成功执行，至少不再发生段不存在故障。
==陷阱是在引起异常的指令之后，把异常情况通知给系统的一种异常==。当控制转移到异常处理程序时，所保存的断点`CS`及`EIP`的值指向引起陷阱的指令的下一条要执行指下一条要执行的指令，不一定就是下一条指令。因此，陷阱处理程序并不是总能根据保存的断点，反推确定出产生异常的指令。在转入陷阱处理程序时，引起陷阱的指令应正常完成，它有可能改变了寄存器或存储单元。软中断指令、单步异常是陷阱的例子。
==中止是在系统出现严重情况时，通知系统的一种异常==。引起中止的指令是无法确定的。==产生中止时正执行的程序不能被恢复执行==。系统接收中止后，处理程序要重新建立各种系统表格，并可能需要重新启动操作系统。硬件故障和系统表中出现非法值或不一致值是中止的例子。

### 3. 优先级

在一条指令执行期间，如检测到不止一个中断或异常，那么按表10.6所列优先级通知系统。==把优先级最高的中断或异常通知系统，其他优先级较低的异常被废弃，而优先级较低的中断则保持悬挂==。请读者考虑，为什么优先级较低的异常可被废弃？

![image](https://github.com/YangLuchao/img_host/raw/master/20231127/image.1b2s1tvxhh7k.jpg)

## 10.7.2 异常类型

象中断分为多种类型一样，异常也分为多种类型。

### 1. 80386识别的异常

80386识别的多种不同类别的异常及赋予的对应中断向量号列于表10.7。某些异常还以出错码的形式提供一些附加的信息传递给异常处理程序，出错代码列中的`无`表示没有出错代码，`有`表示有出错代码。

![image](https://github.com/YangLuchao/img_host/raw/master/20231127/image.uwrayrghl8w.jpg)

![image](https://github.com/YangLuchao/img_host/raw/master/20231127/image.41e5zi6vd4e0.jpg)

把表10.7与表5.2比较，就会发现某些中断向量号(如08-10H)的分配发生了冲突。表5.2所列的中断向量号的分配基于PC微机系统，使用的CPU是8088。表10.7所列中断向量号的分配是80386所规定的。实际上，Intel在宣布8086/8088时，保留了这些发生冲突的中断向量号。尽管发生这样的冲突，但以80386为CPU的微机系统仍可保持与以8088为CPU的微机系统的兼容，原因是在80386的实方式下，几乎不会发生那些中断向量号与外部硬件在提出中断请求时所提供的中断向量号存在冲突的异常。

### 2. 故障类异常

==当发生故障，控制转移到故障处理程序时，所保存的断点CS及EIP的值指向引起故障的指令，以便在排除故障后恢复执行==。

#### (1) 除法出错故障(异常0)

除法出错是一种故障。当执行`DIV`指令或`IDIV`指令时，如果除数等于0，或者商太大，以至于存放商的操作数容纳不下，那么产生这一故障。除法出错故障不提供出错码。

#### (2) 边界检查故障(异常5)

如果`BOUND`指令发现被测试的值超出了指令中给定的范围，那么发生边界检查故障。边界检查故障不提供出错码。

#### (3) 非法操作码故障(异常6)

==如果80386不能把`CS`及`EIP`所指存储单元处的位模式识别为某条指令的部分，那么就发生非法操作码故障==。当出现如下情况时，发生这样的故障：

1. 操作码字段的内容不是一个合法的80386指令的代码；
2. 要求使用存储器操作数的场合，使用了寄存器操作数；
3. 不能被加锁的指令使用了`LOCK`前缀。非法操作码故障不提供出错码。

#### (4) 设备不可用故障(异常7)

设备不可用故障支持80387数字协处理器。在没有80387协处理器硬件的系统中，可用该异常的处理程序代替协处理器的软件模拟器。在发生任务切换时，使得只有在新任务使用浮点指令时，才进行80387寄存器状态的切换。设备不可用故障不提供出错码。该故障在下列情况下产生：

1. 在执行浮点指令时，控制寄存器`CR0`中的`EM`位或TS为1;
2. 在执行WAIT指令时，控制寄存器`CR0`中`TS`位及`EM`位都为1。

#### (5) 段不存在故障(异常0BH)

==处理器在把描述符装入非`SS`段寄存器的高速缓冲器时，如果发现描述符其他方面有效，而P位为0(表示对应段不存在)，那么就发生段不存在故障==。有关`SS`段的情形纳入堆栈段故障。在进入故障处理程序时，保存的`CS`及`EIP`指向发生故障的指令；或者该故障作为任务切换的一部分发生时，指向任务的第一条指令。
段不存在故障提供一个包含引起该异常的段选择子的出错码。出错码的格式如图10.19所示。16位出错码的主要成分是选择子，高13位是选择子的索引部分，`TI`位是描述符表指示位。
图10.19所示出错码格式是段异常时出错码的一般格式。从图中可见出错码中不含选择子的`RPL`，而由`IDT`位和`EXT`位代替。当处理某一异常或外部中断时，又发生了某种异常，那么`EXT`位置1。当从中断描述符表`IDT`中读出表项并产生异常时，`IDT`位置1，这只在中断或异常的处理期间才会发生。当没有选择子时，构成出错码选择子部分的值为0。

#### (6) 堆栈段故障(异常0CH)

==当处理器检测到用`SS`寄存器进行寻址的与段有关的某种问题时，就发生堆栈段故障==。在进入故障处理程序时，保存的`CS`及`EIP`指向发生故障的指令；或者该故障作为任务切换的一部分发生时，指向任务的第一条指令。堆栈段故障提供一个出错码，出错码的一般格式也如图10.19所示。

![image](https://github.com/YangLuchao/img_host/raw/master/20231127/image.1ybfeh0983vk.jpg)

具体地说，当出现下列三种情况时，将引起堆栈段故障：

1. ==在堆栈操作时，偏移超出段界限所规定的范围==。这种情况下的出错码是0。例如，PUSH操作时，堆栈溢出。
2. 在由特权级变换所引起的对内层堆栈的操作时，偏移超出段界限所规定的范围。这种情况下的出错码包含有内层堆栈的选择子。
3. 装入到`SS`寄存器(高速缓冲寄存器)的描述符中的存在位为0。这种情况下的出错码包含有对应的选择子。

上述第一种情况是容易辨别的。第二和第三种情况的辨别要通过判断出错码所含选择子所指示的描述符中的存在位进行。如果存在位为1，那么是第二种情况；否则是第三种情况。

#### (7) 无效TSS故障(异常0AH)

==当正从任务状态段`TSS`装入选择子时，如果发生除了不存在故障以外的段异常时，就发生无效`TSS`故障==。在进入故障处理程序时，保存的`CS`及`EIP`指向发生故障的指令；或者该故障作为任务切换的一部分发生时，指向任务的第一条指令。
无效`TSS`故障提供一个出错码，出错码的格式也如图10.19所示，其中选择子部分是指向引起故障的`TSS`的选择子。
一些引起无效`TSS`故障的原因如下：

- `TSS`描述符中的段限长小于103;
- 无效的`IDT`描述符，或者`LDT`未出现；

- 堆栈段不是一个可写段；

- 堆栈段选择子索引的描述符超出描述符表界限；

- 堆栈段`DPL`与新的`CPL`不匹配；

- 堆栈段选择子`RPL`不等于`CPL`;

- 代码段选择子索引的描述符超出描述符表界限；

- 代码段选择子不指向代码段；

- 非一致代码段的`DPL`不等于新的`CPL`;

- 一致代码段`DPL`大于新的`CPL`;

- 对应`DS`、`ES`、`FS`或`GS`的选择子指向一个不可读段；

- 对应`DS`、`ES`、`FS`或`GS`的选择子索引的描述符超出描述符表界限

#### (8) 通用保护故障(异常0DH)

==除了明确列出的段异常外，其他的段异常都被视作为通用保护故障==。在进入故障处理程序时，保存的`CS`及`EIP`指向发生故障的指令；或者该故障作为任务切换的一部分发生时，指向任务的第一条指令。
通用保护故障提供一个出错码，出错码的一般格式也如图10.19所示。根据处理程序可能进行的响应，==通用保护故障可分为如下两类==：

1. 违反保护方式，但程序无须终止的异常。这类故障提供的出错码是0。这种异常在应用程序执行特权指令或``I/O``访问时发生，支持虚拟8086程序的系统或支持虚拟``I/O``访问的系统，需要模拟这些指令，并在模拟完成产生故障的指令后，重新执行被中断的程序。
2. 违反保护方式，并导致程序终止的异常。这类故障提供的出错码可能为0，也可能不为0(能确定选择子时)。引起这类故障的一些原因如下：
   1. 向某个只读数据段或代码段写；

   2. 从某个只能执行的代码段读出；

   3. 将某个系统段描述符装入到数据段寄存器`DS`、`ES`、`FS`、`GS`或`SS`;

   4. 将控制转移到一个不可执行的段；

   5. 在通过段寄存器`CS`、`DS`、`ES`、`FS`或`GS`访问内存时，偏移越出段界限；

   6. 当访问某个描述符表时，超过描述符表段界限；

   7. 把`PG`位为1但`PE`位为0的控制信息装入到`CR0`;

   8. 切换到一个正忙的任务。

对上述两类通用保护故障的辨别，可通过检查引起故障的指令和出错码进行。如果出错码非0，那么肯定是第二类通用保护故障。如果出错码是0，那么需进一步检查引起故障的指令，以确定它是否是系统支持的可以模拟的指令。

#### (9) 页故障(异常0EH)

关于页故障的详细说明见10.10.4节

#### (10) 协处理器出错(异常10H)

协处理器出错故障指示协处理器发生了未被屏蔽的数字错误，如上溢或下溢。在引起故障的浮点指令之后的下一条浮点指令或WAIT指令，把协处理器出错作为一个故障通知给系统。协处理器出错故障不提供出错码。

### 2. 陷阱类异常

#### (1) 调试陷阱(异常1)

==调试异常有故障类型，也有陷阱类型==。调试程序可以访问调试寄存器DR6,以确定调试异常的原因和类型。调试异常不提供出错码。

#### (2) 单字节INT3(异常3)

`INT3`是一条特别的一字节“INTn”指令。调试程序可利用该指令支持程序断点。
`INT3`指令被看成是一种陷阱，而不是一个中断。当由于执行`INT3`指令进入异常3处理程序时，被保存的`CS`和`EIP`指向紧跟`INT3`的指令，也即`INT3`指令后面的一个字节。
INT3陷阱不提供出错码。

#### (3) 溢出(异常4)

`INTO`指令提供条件陷阱。如果`OF`标志为1,那么`INTO`指令产生陷阱；否则不产生陷阱，继续执行`INTO`后面的指令。在进入溢出处理程序时，被保存的`CS`和`EIP`指向`INTO`指令的下一条指令。溢出陷阱不提供出错码。

### 3. 中止类异常

#### (1) 双重故障异常(异常8)

当系统正在处理一个异常时，如果又检测到一个异常，处理器试图向系统通知一个双重故障，而不是通知第二个异常。双重故障被分在中止异常那一类，所以在转入双重故障处理程序时，被保存的`CS`和`EIP`可能不指向引起双重故障的指令，而且指令的重新启动不支持双重故障。双重故障提供的出错码是0。
当正处理一个段故障异常时，有可能又产生一个页故障。在这种情况下，通知给系统的是页故障异常而不是双重故障异常。但是，如果正处理一个段或页故障时，又一个段故障被检测到；或者如果正处理一个页故障时，又一个页故障被检测到，那么就引起双重故
障。
当正处理一个双重故障时，又一个段或页故障被检测到，那么处理器暂停执行指令并进入关机方式。关机方式类似于处理器执行一条`HLT`指令后的状态：处理器空转，并维持到处理器接收到一个`NMI`中断请求或者被重新启动为止。在关机方式下，处理器不响应`INTR`中断请求。
双重故障通常指示系统表出现严重的问题，例如段描述符表、页表或中断描述符表出现问题。双重故障处理程序在重建系统表后，可能不得不重新启动操作系统。

#### (2)协处理器段越界(异常9)

协处理器段越界异常被分在中止异常这一类。当浮点指令操作数超出段界限时，产生该中止异常。协处理器段越界异常不提供出错码。

## 10.7.3 中断和异常的转移方法

80386在实方式下的中断和异常转移方法与第5章所介绍的8086/8088响应中断的方法相同。这里介绍的中断和异常的转移方法是指==80386在保护方式下响应中断和处理异常时所采用的转移方法==，

### 1. 中断描述符表IDT

与8086/8088一样，==在响应中断或者处理异常时，80386根据中断向量号转对应的处理程序==。但是，在保护方式下80386不再使用实方式下的中断向量表，而是使用中断描述符表`IDT(Interrupt Descriptor Table)`。在保护方式下，80386把中断向量号作为中断描述符表`IDT`中描述符的索引，而不再是中断向量表中的中断向量的索引。
像全局描述符表`GDT`一样，在整个系统中，中断描述符表`IDT`只有一个。中断描述符表寄存器`IDTR`指示`IDT`在内存中的位置，这也与如图10.10所示的`GDTR`指示`GDT`相似。由于80386只识别256个中断向量号，所以`IDT`最大长度是2K。
中断描述符表`IDT`所含的描述符只能是中断门、陷阱门和任务门。也就是说，在保护方式下，80386只有通过中断门、陷讲门或任务门才能转移到对应的中断或异常处理程图10.13给出了门描述符的格式。从中可见门描述符包含由选择子和偏移量构成的48位全指针。另外，双字计数字段对中断门、陷阱门和任务门而言无意义。

### 2. 中断响应和异常处理的步骤

==由硬件自动实现的中断响应和异常处理的步骤如下==：

1. ==首先，判中断向量号要索引的门描述符是否超出`IDT`的界限==。如果超出界限，就引起通用保护故障，出错码是中断向量号乘8再加2.
2. ==其次，从IDT中取得对应的门描述符，分解出选择子、偏移量和描述符属性类型，并进行有关检查==。描述符只能是任务门、286中断门、286陷阱门、386中断门或386陷阱门，否则，就引起通用保护故障，出错码是中断向量号乘8再加2。如果是由于`INTn`指令或者`INTO`指令引起转移，还要检查中断门或陷阱门描述符中的`DPL`是否满足`CPL<=DPL`。这种检查可以避免应用程序执行`INTn`指令时，使用分配给各种设备用的中断向量号。如果检查不通过，就引起通用保护故障，出错码是中断向量号乘8再加2。门描述符中的P位必须是1，表示门描述符是一个有效项，否则就引起段不存在故障，出错码是中断向量号乘8再加2
3. 最后，根据门描述符类型，分情况转入中断或异常处理程序。

对于异常处理，在开始上述步骤之前，还要根据异常类型确定返回点；如果有出错码则形成符合出错码格式的出错码。对于异常处理，如果有出错码，在实际执行异常处理程字之前，还要把出错码压入堆栈。为了保证堆栈的双字边界对齐，16位的出错码以32位约值压入，其中高16位的值未作定义。

### 3.通过中断门或陷阱门的转移

如果中断向量号所指示的门描述符是386中断门或386陷阱门，那么控制转移到当前任务的一个处理程序过程，并且可以变换特权级。与通过调用门的`CALL`指令一样，从中断门或陷阱门中获取指向处理程序的48位全指针。其中，16位选择子是对应处理程序代码段的选择子，它指示`GDT`或`LDT`中的描述符；32位偏移指示处理程序入口点在代码段内的偏移。
通过中断门或陷阱门的转移过程如图10.20所示。该过程由硬件自动进行。图中`开始`处表示接上述分情况转移，所以此时已对由中断向量号所索引的`IDT`中的中断门或陷阱门描述符进行过必要的检查，并从中取得指示处理程序的由选择子和偏移构成的48位全指针。`结束`处表示转入实际的中断或陷阱处理程序。

![image](https://github.com/YangLuchao/img_host/raw/master/20231127/image.4hql4z6yc5m0.jpg)

图10.20所示通过中断门或陷阱门的转移与通过调用门的转移很相似。
从图10.20可见，中断门或陷讲门中指示处理程序的选择子必须指向描述一个可执行代码段的描述符。如果选择子为空，就引起通用保护故障，出错码是0。如果描述符不是代码段描述符，就引起通用保护故障，出错码含选择子。
中断或异常可以转移到同一特权级或内层特权级。上述指定处理程序段的描述符中的类型及`DPL`字段，决定了这种同一任务内的转移是否要发生特权级的变换。如果是一个非一致的代码段，并且`DPL<CPL`，那么要发生特权级的变换，堆栈也要切换成内层堆栈。但不复制堆栈中的参数。
图10.20中的`把描述符装入CS`是指把上述指定处理程序段的描述符装入`CS`的高速缓冲寄存器中，在这一步骤中要对描述符进行如10.6.1节所述的其他检查，包括是否是代码段描述符和代码段是否存在等，因此可能再发生异常。在对该描述符进行检查时，通过调整`RPL=0`的方法，实现只考虑`DPL`，而不考虑门中选择子的`RPL`。在把描述符装入`CS`之后，还要检查门描述符中给出的表示处理程序代码段入口的偏移是否越界，即是否超出段界限。如果越界，就引起出错码为0的通用保护故障。
从图10.20可见，把标志寄存器和断点压入堆栈的做法和顺序与实方式是相同的，但这里每一次堆栈操作是一个双字，`CS`被扩展成32位。
把`TF`置成0，表示不允许处理程序单步执行。把`NT`置成0，表示处理程序在利用中断返回指令IRET返回时，返回到同一任务而不是一个联套任务。
从图10.20可见，通过中断门的转移和通过陷阱门的转移之间的差别只是对IF标志的处理。对于中断门，在转移过程中，把IF置成0，使得在处理程序执行期间，屏蔽掉`INTR`中断；对于陷阱门，在转移过程中，保持`IF`位不变，即如果`IF`位原是1，那么通过陷阱门转移到处理程序之后仍允许`INTR`中断。因此，中断门最适宜于处理中断，而陷阱门适宜于处理异常。
从图10.20可见，在有出错码的情况下，在转入处理程序之前，还要把出错码压入堆栈。只有异常处理才可能有出错码。
图10.21给出了通过中断门或陷阱门转移时的堆栈情况。

- (a)是没有变换特权级和没有出错码的情形；
- (b)是没有变换特权级和有出错码的情形；
- (c)是变换特权级和没有出错码的内层堆栈情形；
- (d)是变换特权级和有出错码的内层堆栈情形。

注意，图中每一项为双字。

![image](https://github.com/YangLuchao/img_host/raw/master/20231127/image.2nmijs6jufs0.jpg)

### 4. 通过任务门的转移

==如果中断向量号所指示的门描述符是任务门描述符，那么控制转移到一个作为独立的任务方式出现的处理程序==。如图10.13所示，任务门中含48位全指针。这时，16位选择子是指向描述对应处理程序任务的TSS段的选择子，也即该选择子指示一个可用的`286TSS`，或`386TSS`。通过任务门的转移与通过任务门到一个可用的`386TSS`的`CALL`指令的转移很相似，主要的区别是，对于提供出错码的异常处理，在完成任务切换之后，把出错码压入新任务的堆栈中。
通过任务门的转移，在进入中断或异常处理程序时，标志寄存器`EFLAGS`中的`NT`位被置1，表示是嵌套任务。
在响应中断或处理异常时，使用任务门可提供一个处理程序任务的自动调度。这种任务调度由硬件直接执行，并且越过包含在操作系统中的软件任务切换，这就为处理程序提供了一个快速的任务切换。

### 5. 转移方法的比较

对中断的响应和异常的处理，80386允许通过使用中断门或陷阱门实现由当前任务之内的一个过程进行处理；也允许通过使用任务门实现由另外一个任务进行处理。在当前任务内的处理程序较为简单，并可以很快转移到处理程序，但处理程序要负责保存及恢复处理器的寄存器等内容。转到不同任务的处理程序要花费较长时间，保存及恢复处理器寄存器内容的开销作为任务切换的一部分。使用当前任务内的处理程序的方法，在响应中断或处理异常时，对正执行任务的状态可直接进行访问，但是，这样就要求每一个任务之内都包含一个处理程序。使用独立任务的处理方法，使处理程序得到较好的隔离，但在响应中断或处理异常时，对原任务状态的访问变得较为复杂

无效`TSS`异常必须使用任务门进行处理，以保证处理程序有一个有效的任务环境其他的异常通常在任务环境之内进行处理。在任务内，异常被检测并且不必屏蔽中断，所以使用陷阱门。由陷阱门指示的异常处理程序，是一个由所有任务共享的过程，所以该处理程序最好置于全局地址空间之内。如果各个任务要求有不同的处理程序，那么全局异常处理程序可保存一个各处理程序的人口表，并为引起异常的任务调用相应的处理程序。
中断通常与正执行的任务没有关系，并可能从使用任务门提供的隔离中获得好处。要求较快响应的中断，通过中断门可以得到较好的处理。因为中断随时都可能发生，所以，通过中断门访问的中断处理程序，必须置于全局地址空间中，以便对所有的任务都有效。

### 6. 中断或异常处理后的返回

==中断返回指令`IRET`用于从中断或异常处理程序的返回==。该指令的执行根据任务族套标志`NT`是否为1，分两种情形。

1. ==NT为1，表示是嵌套任务的返回==。当前`TSS`中的链接字段保存由前一任务的`TSS`的选择子，取出该选择子，进行任务切换就完成了返回。这种情形在由通过任务门转入的中断或异常处理程序返回时出现，因为在由中断门或陷阱门转入处理程序时，`NT`位已被清0。
2. ==NT为0，表示当前任务内的返回==。这种情形在由通过中断门或陷阱门转入的中断或异常处理程序返回时出现。具体进行的操作包括：从堆栈顶弹出返回指针`EIP`及`CS`，然后弹出`EFLAG`值。弹出的`CS`选择子的`RPL`字段，确定返回后的特权级。如果返回选择子的`RPL`与`CPL`相同，则不进行特权级的改变。若`RPL`规定了一个外层特权级，则需要特权级改变，从内层堆栈中弹出外层堆栈的`ESP`及`SS`的值，参见图10.21。这些做法与`RET`指令的实现相似。例如，使用返回`CS`选择子的`RPL`，而不是由选择子标识的段的`DPL`，是为了返回到不在`DPL`给定的级执行的一致代码段。

对于提供出错代码的异常的处理程序，必须先从堆栈中弹出出错代码，然后再执行`IRET`指令。中断返回指令`IRET`不仅能够用于由中断/异常引起的嵌套任务的返回，而且也适用于由段间调用指令`CALL`通过任务门引起的嵌套任务的返回。如10.6.5节所述，在执行通过任务门进行任务切换的`CALL`指令时，标志寄存器中的`NT`被置1，表示任务嵌套。

## 10.7.4 演示中断处理的实例(实例六)

下面给出一个用于演示中断处理的实例。该实例的逻辑功能是，在屏幕的左上角以倒计时方式显示秒为单位的时间，在时间用完后结束。该实例演示内容包括：外部中断处理程序，陷阱处理程序。

### 1. 源程序组织和清单

本实例有如下几部分组成：

1. 全局描述符表`GDT`。GDT中除了含有常见的几个描述符外，含有描述时钟中断处理程序所使用的代码段和数据段，还含有描述显示程序所使用的代码段和数据段。
2. 中断描述符表`IDT`。为了在保护方式下响应中断和处理异常，必须有`IDT`。IDT含有256个门描述符。8H号安排的是一个通向时钟中断处理程序的中断门，0FEH号安排的是通向显示处理程序的陷阱门，其他均安排成通向其他中断或异常处理程序的陷阱门
3. 时钟中断处理程序的代码段和数据段。
4. 实现直接填显示缓冲区进行显示的显示程序的代码段和数据段。
5. 处理其他中断或异常的处理程序的代码段。
6. 演示程序的代码段、数据段和堆栈段等。
7. 实方式下执行的启动和结束程序代码段和数据段。

源程序清单如下：

```assembly
;程序名：T10-6.ASM
;功能：演示中断处理的实现
;
INCLUDE 386SCD.ASM
;参见实例三
	.386P
;部分常量定义
EOICOM 	= 	20H		;外部中断处理结束命令
ICREGP	=	20H		;中断控制寄存器端口地址
IMREGP 	= 	21H		;中断屏蔽寄存器端口地址
;全局描述符表GDT
GDTSEG 	SEGMENT 	PARA 	USE16
	GDT		LABEL 	BYTE
	DUMMY 	DESCRIPTOR 	<>
	NORMAL 	DESCRIPTOR 	<0FFFFH,0,0,ATDW,0>
	Normal_SEL	=	NORMAL - GDT
	EFFGDT 	LABEL 	BYTE
	;临时代码段描述符
	TEMPCODE 	DESCRIPTOR 	<0FFFFH,TempCodeSEG,,ATCE,>
	TempCode_SEL 	= 	TEMPCODE - GDT
	;演示任务代码段描述符
	DEMOCODE 	DESCRIPTOR 	<DemoCodeLEN-1,DemoCodeSEG,,ATCE,>
	DemoCode_SEL	=	DEMOCODE - GDT
	;演示任务数据段描述符
	DEMODATA 	DESCRIPTOR 	<DemoDataLEN-1,DemoDataSEG,,ATDW,>
	DemoData_SEL 	= 	DEMODATA - GDT
	;演示任务堆栈段描述符
	DEMOSTACK 	DESCRIPTOR 	<DemoStackLEN-1,DemoStackSEG,,ATDWA,>
	DemoStack_SEL 	= 	DEMOSTACK - GDT
	;FEH号中断处理程序(显示程序)代码段描述符
	ECHOCODE 	DESCRIPTOR 	<EchoCodeLEN-1,EchoCodeSEG,,ATCE,>
	EchoCode_SEL	=	ECHOCODE - GDT
	;FEH号中断处理程序(显示程序)数据段描述符
	ECHODATA 	DESCRIPTOR 	<EchoDataLEN-1,EchoDataSEG,,ATDW,>
	EchoData_SEL 	= 	ECHODATA - GDT
	;视频缓冲区描述符(B8000H)
	VIDEOBUFF 	DESCRIPTOR 	<80*25*2-1,0B800H,,ATDW,>
	VideoBuff_SEL 	= 	VIDEOBUFF - GDT
	;8H号中断处理程序代码段描述符
	TICODE 		DESCRIPTOR 	<TICodeLEN-1,TICodeSEG,,ATCE>
	TI_SEL			=	TICODE - GDT
	;8H号中断处理程序数据段描述符
	TIDATA		DESCRIPTOR 	<TiDataLEN-1,TiDataSEG,,ATDW,>
	TIData_SEL 		= 	TIDATA - GDT
	;其他中断或异常处理程序代码段描述符
	OTHER 		DESCRIPTOR 	<OTHERCodeLEN-1,OTHERCodeSEG,,ATCE,>
	OTHER_SEL 		= 	OTHER - GDT
	;GDT中的需要进行基地址初始化的描述符个数
	GDNUM 	= ($ - EFFGDT)/(SIZE DESCRIPTOR)
	GDTLEN 	= $ - GDT
GDTSEG	ENDS
;中断描述符表IDT
IDTSEG 	SEGMENT 	PARA 	USE16
	IDT LABEL 	BYTE
	;从00~07的8个陷阱门描述符
	REPT 	8
	GATE <OtherBegin,OTHER_SEL,0,AT386TGAT,0>
	ENDM
;对应8H号(时钟)中断处理程序的中断门描述符
	INT08 	GATE 	<TIBegin,TL_SEL,0,AT386IGAT,0>
;从09~FDH的245个陷阱门描述符
	REPT 254 - 9
	GATE <OtherBegin,OTHER_SEL,0,AT386TGAT,0>
	ENDM
;对应0FEH号中断处理程序的陷阱门描述符
	INTFE 	GATE	<EchoBegin,EchoCode_SEL,0,AT386TGAT,>
;对应0FFH号中断处理程序的陷阱门描述符
	GATE <OtherBegin,OTHER_SEL,0,AT386TGAT.0>
	IDTLEN $ - IDT
IDTSEG	ENDS
;其他中断或异常处理程序的代码段
OtherCodeSEG 	SEGMENT 	PARA 	USE16
	ASSUME 	CS:OtherCodeSEG
OtherBegin:
	MOV		AX,VideoBuff_SEL
	MOV 	ES,AX
	MOV 	AH,17H
	MOV 	AL,'! '
	MOV 	ES:[0].AX		;在屏幕左上角显示兰底白色符号“！”
	JMP		$				;无限循环
	OtherCodeLEN = $
OtherCodeSEG 	ENDS
;8H号(时钟)中断处理程序的数据段
TIDataSEG 	SEGMENT 	PARA 	USE16
	COUNT	DB	0		;中断发生的计数器
	TIDataLEN = $
TIDataSEG ENDS
;8H号(时钟)中断处理程序的代码段
TICodeSEG 	SEGMENT 	PARA 	USE16
	ASSUME 	CS:TICodeSEG,DS:TIDataSEG
TIBegin:
	PUSH 	EAX
	PUSH 	DS
	PUSH 	FS				
	PUSH 	GS				;保护现场
	MOV 	AX,TIData_SEL
	MOV 	DS,AX			;置中断处理程序数据段
	MOV		AX,EchoData_SEL
	MOV		FS,AX			;置显示过程数据段
	MOV		AX,DemoData_SEL
	MOV		GS,AX			;置演示程序数据段
	CMP		COUNT,0
	JNZ		TI2				;计数非0表示未到一秒
	MOV		COUNT,18		;每秒约18次
	INT		0FEH			;调用OFEH号中断处理程序显示
	CMP 	FS:MESS,'0'
	JNZ		T11
	MOV		GS:FLAG,1		;显示符号0时置标记
T11: 
	DEC 	FS:MESS			;调整显示符号
TI2:
	DEC		COUNT			;调整计数
	POP 	GS
	POP 	FS				;恢复现场
	POP 	DS
	MOV 	AL,EOICOM
	OUT 	ICREGP,AL		;通知中断控制器中断处理结束
	POP		EAX
	IRETD					;中断返回
	TICodeLEN = $
TICodeSEG ENDS
;0FEH号中断处理程序的数据段
EchoDataSEG 	SEGMENT 	PARA 	USE16
	MESS		DB '8',07H
	EchoDataLEN	=	$
EchoDataSEG		ENDS
;OFEH号中断处理程序(显示程序)的代码段
EchoCodeSEG 	SEGMENT 	PARA 	USE16
	ASSUME		CS:EchoCodeSEG,DS:EchoDataSEG
EchoBegin:
	PUSH 	AX
	PUSH 	DS					;保护现场
	PUSH 	ES
	MOV 	AX,EchoData_SEL
	MOV 	DS,AX				;置显示过程数据段
	MOV 	AX,VideoBuff_SEL
	MOV 	ES,AX				;置视频数据段
	MOV		AX,WORD PTR MESS
	MOV 	ES:[0],AX			;显示符号
	POP 	ES
	POP 	DS					;恢复现场
	POP		AX
	IRETD						;中断返回
	EchoCodeLEN	=	$
EchoCodeSEG		ENDS
;演示任务的堆栈段
DemoStackSEG 	SEGMENT 	PARA 	USE16
	DemoStackLEN = 1024
	DB	DemoStackLEN DUP (0)
DemoStackSEG 	ENDS
;演示任务的数据段
DemoDataSEG 	SEGMENT 	PARA 	USE16
	FLAG	DB	0
	DemoDataLEN = $
DemoDataSEG		ENDS
;演示任务的代码段
DemoCodeSEG 	SEGMENT 	PARA 	USE16
	ASSUME	CS:DemoCodeSEG,DS:DemoDataSEG
DemoBegin:
	MOV 	AX,DemoStack_SEL
	MOV 	SS,AX			;置堆栈
	MOV 	SP,DemoStackLEN
	MOV 	AX,DemoData_SEL
	MOV 	DS,AX			;置数据段
	MOV 	ES,AX
	MOV 	FS,AX
	MOV 	GS,AX
	;
	MOV 	AL,11111110B	;置中断屏蔽寄存器
	OUT 	IMREGP,AL		;仅开放时钟中断
	STI						;开中断
DemoConti:
	CMP		FLAG,0			;判标志
	JZ		DemoConti		;为0继续
	CLI						;关中断
	;转回临时代码段，准备回实方式
OVER:
	JUMP16 TempCode_SEL,<OFFSET ToDOS>
	DemoCodeLEN = $
DemoCodeSEG ENDS
;临时代码段
TempCodeSEG 	SEGMENT 	PARA 	USE16
	ASSUME 	CS:TempCodeSEG
Virtual:;转演示程序
	JUMP16 	DemoCode_SEL,DemoBegin
ToDOS:;准备返回实方式
	MOV 	AX,Normal.SEL
	MOV 	DS,AX
	MOV 	ES,AX
	MOV 	FS,AX
	MOV 	GS,AX
	MOV 	SS,AX
	MOV 	EAX,CR0
	AND 	EAX,0FFFFFFFEH
	MOV 	CR0,EAX
	;返回实方式
	JUMP16 	<SEG Real>,<OFFSET Real>
TempCodeSEG ENDS
;实方式下的数据段
RDataSEG 	SEGMENT 	PARA 	USE16
	VGDTR 	PDESC 	<GDTLEN-1,>	;GDT伪描述符
	VIDTR	PDESC 	<IDTLEN-1,>	;IDT伪描述符
	NORVIDTR PDESC	<3FFH,0>	;用于保存原IDTR值
	SPVAR	DW 		?			;用于保存原堆栈指针
	SSVAR	DW		?
	IMASKREGV 	DB 	?			;用于保存原中断屏蔽寄存器值
RDataSEG 	ENDS
;实方式下的代码段
RCodeSEG 	SEGMENT 	PARA 	USE16
	ASSUME 	CS:RCodeSEG,DS:RDataSEG
Start:
	MOV 	AX,RDataSEG
	MOV 	DS,AX
	CLD
	CALL 	INIT_GDT	;初始化GDT
	CALL 	INIT_IDT	;初始化IDT
	MOV 	SSVAR,SS	;保存堆栈指针
	MOV 	SPVAR,SP
	SIDT 	NORVIDTR	;保存IDTR值
	IN		AL,IMREGP
	MOV 	IMASKREGV,AL	;保存中断屏蔽字节
	LGDT 	QWORD PTR VGDTR ;置GDTR
	CLI						;关中断
	LIDT 	QWORD PTR VIDTR	;置IDTR
	MOV 	EAX,CR0
	OR		EAX,1
	MOV 	CRO,EAX			;转保护方式下的临时代码段
	JUMP16 	<TempCode_SEL>,<OFFSET Virtual>
Real:;又回到实方式
	MOV 	AX,RDataSEG
	MOV 	DS,AX			;理实方式数据段
	LSS 	SP,DWORD PTR SPVAR	;恢复堆栈指针
	LIDT 	NORVIDTR		;恢复IDTR
	MOV		AL,IMASKREGV	;恢复中断屏蔽字节
	OUT		IMREGP,AL
	STI						;开中断
	MOV		AX,4C00H		;返回DOS
    INT		21H				;初始化过程
INIT_GDT 	PROC 	NEAR
;同实例四
INIT_GDT 	ENDP
;初始化IDTR伪描述符子程序
INIT_IDT 	PROC
	MOV 	BX,16
	MOV 	AX,IDTSEG
	MUL 	BX
	MOV 	WORD PTR VIDTR.BASE,AX
	MOV 	WORD PTR VIDTR.BASE+2,DX
	RET
INIT_IDT 	ENDP
RCodeSEG 	ENDS
	END Start
```

### 2. 关于实例六的说明

下面再对上述演示程序作些说明：

#### (1)时钟中断仍使用8H号中断向量

为了既简单又清楚地演示在保护方式下响应外部中断并进行处理，实例使用了时钟中断源，但没有通过重新设置中断控制器的方法改变对应的中断向量。所以，时钟中断使用的8H号中断向量号就与双重故障异常使用的中断向量号发生冲突。但实例仅是演示程序，所以只要保证不发生双重故障异常，就可避免冲突，就不会影响演示。设置中断屏蔽寄存器，仅开放时钟中断。所以，在开中断状态下，也只可能发生时钟中断，而不会发生其他外部中断。

#### (2)时钟中断处理程序的设计

==由于通过中断门转时钟中断处理程序，所以在控制转移时不发生任务切换==。==但作为外部中断，随时可能发生，因此中断处理程序必须采取保护现场等措施==。作为演示程序，该中断处理程序检查和调整在其数据段中的计数器；在满18次后，就认为已满一秒，再调整用于显示的倒计数信息；如果倒计数信息为0,那么就设置演示程序数据段中的时间为0标志。该中断处理程序通过约定的数据区与显示程序及演示程序交换信息。

#### (3)利用一个“软中断”(陷阱处理)程序实现显示

为了演示陷阱及其处理，把显示过程安排成陷阱处理程序，简称为显示程序。上述时钟中断处理程序，通过软中断指令INT调用该显示程序，显示倒计时数。在控制转移时，也没有任务切换。该陷阱处理程序相当于一个`软中断`处理程序。

#### (4)对其他中断或异常的响应

为了简单，除了8H号和0FEH号外，`IDT`中其他的门均通向同一个处理程序。该处理程序用于处理其他中断或异常。处理过程也极其简单，在屏幕左上角显示兰底白色的符号“！”，然后进入无限循环。实际上，按演示程序现在的安排，不可能发生这种情况。

#### (5)没有特权级变换

为了简单，实例涉及的中断处理程序和异常处理程序都保持特权级0。所以，控制转移时不发生特权级变换。因此，没有使用其他堆栈。

#### (6)对IDT的初始化

由于`IDT`中门描述符没有32位段基地址，并且入口点偏移较小，所以就直接填门描述符结构变量，没有额外再初始化。过程INIT_IDT只是设置`IDT`伪描述符。

#### (7)装载和保存IDTR寄存器

在使`IDT`发挥作用之前，还要装载中断描述符表寄存器`IDTR`，但为了回到实方式后，恢复原`IDTR`之内容，所以先保存`IDTR`的内容。实例使用如下指令保存`IDTR`:

```assembly
SIDT NORVIDTR
```

该指令的功能是把`IDTR`的内容保存到存储器中的伪描述符NORVIDTR。为描述符NORVIDTR的结构如前述结构类型PDESC所示，低字是以字节为单位的界限，高双字是基地址。在10.8节中对`SIDT`指令作详细说明。本实例使用如下指令装载`IDTR`:

```assembly
LIDT QWORD PTR VIDTR
LIDT QWORD PTR NORVIDTR
```

LIDT指令类似于LGDT指令，在10.8节中对LIDT指令再作详细说明。

## 10.7.5 演示异常处理的实例(实例七)

下面给出一个用于模拟异常和演示异常处理的实例。该实例的逻辑功能是，在屏幕上显示一条提示用户击键方式选择模拟异常类型的字符，然后模拟指定的异常。==该实例演示内容包括：除法出错故障处理、溢出陷阱处理、段不存在故障处理、堆栈段出错故障处理和通用保护故障处理==；还有作为一个独立任务方式出现的陷阱处理程序。

### 1. 源程序组织和清单

为了演示以独立任务方式出现的陷阱处理程序，实例含有两个任务：演示任务和读键盘任务。实例有如下几部分组成：

1. 全局描述符表`GDT`和中断描述符表`IDT`;

2. 读键盘任务局部描述符表、任务状态段、堆栈段和代码段等；

3. 演示任务的局部描述符表、任务状态段、堆栈段、代码段和数据段等；

4. 作为演示任务一部分的有关陷阱处理和故障处理程序的代码段；

5. 作为演示任务一部分的显示出错码过程代码段；

6. 实方式下执行的启动和结束程序代码段和数据段。


在切换到保护方式后，就进入临时代码段。为了简单，演示不发生特权级的变换。演示步骤如下：

1. 从临时代码段转移到演示代码段。

2. 做演示准备。把演示任务的`LDT`选择子装入`LDTR`，并填入`TSS`,装载任务寄存器`TR`，建立演示任务堆栈，设置其他数据段寄存器。

3. 接收要模拟的异常类型号。通过软中断指令`INT`调用读键盘任务完成该步骤。读键盘任务只有在接收到指定的字符后才结束。接收的字符是0、4、B、C和D。
4. 按接收的字符模拟异常。也即根据键入的字符，执行有关片段。在这些片段中，有意安排了能引起有关故障或陷阱的指令。
5. 结束演示，转临时代码段，返回DOS。

源程序清单如下：

```assembly
;程序名：T10-7.ASM
;功能：模拟异常和演示异常处理
;
	INCLUDE	386SCD.ASM
;参见实例三
	.386P
;全局描述符表GDT
GDTSEG	SEGMENT PARA 	USE16
	GDT		LABEL 	BYTE
	DUMMY	DESCRIPTOR		<>
	NORMAL	DESCRIPTOR 		<0FFFFH,0,0,ATDW,0>
	Normal_SEL		=	NORMAL - GDT
	EFFGDT 	LABEL BYTE
	;临时代码段描述符
	TEMPCODE DESCRIPTOR 	<0FFFFH,TempCodeSEG,,ATCE,>
	TempCode_SEL 	= 	TEMPCODE - GDT
	;演示任务代码段描述符
	DEMOCODE DESCRIPTOR 	<DemoCodeLEN-1,DemoCodeSEG,,ATCE,>
	DemoCode_SEL	=	DEMOCODE - GDT
	;演示任务局部描述符表段描述符
	DEMOLDT 	DESCRIPTOR 	<DemoLDTLEN-1,DemoLDTSEG,,ATLDT,<ERR>
	DemoLDT_SEL 	= 	DEMOLDT - GDT
	;演示任务TSS段描述符
	DEMOTSS 	DESCRIPTOR 	<DemoTSSLEN-1,DemoTSSSEG,,AT386Tss,>
	DemoTSS_SEL 	= 	DEMOTSS - GDT
	;缓冲数据段描述符
	XBUFFER 	DESCRIPTOR 	<BufferLEN-1,BufferSEG,,ATDW,>
	XBuffer_SEL 	= 	XBUFFER - GDT
	;读键盘任务局部描述符表段描述符
	GKEYLDT 	DESCRIPTOR 	<GKeyLDTLEN-1,GKeyLDTSEG,,ATLDT,>
	GKeyLDT_SEL 	= 	GKEYLDT - GDT
	;读键盘任务TSS段描述符
	GKEYTSS 	DESCRIPTOR 	<GKeyTSSLEN-1,GKeyTSSSEG,,AT386TSS,
	GKeyTSS_SEL 	= 	GKEYTSS - GDT
	;视频缓冲区段描述符(B8000H)
	VIDEOBUFF 	DESCRIPTOR 	<80*25*2-1,0B800H,,ATDW,>
	VideoBuff_SEL 	= 	VIDEOBUFF - GDT
	;显示陷阱处理程序代码段描述符
	ECHOCODE 	DESCRIPTOR 	<EchoCodeLEN-1,EchoCodeSEG,,ATCE,>
	EchoCode_SEL	=	ECHOCODE - GDT
	;显示出错码过程代码段描述符
	SUBCODE 	DESCRIPTOR 	<SUBCodeLEN-1,SUBCodeSEG,,ATCE,>
	SUBCode_SEL		= 	SUBCODE - GDT
	;其他中断或异常处理程序代码段描述符
	OTHER 		DESCRIPTOR	<OTHERCodeLEN-1,OTHERCodeSEG,,ATCE,>
	OTHER_SEL		=	OTHER - GDT
	;GDT中需要初始化基地址的描述符个数
	GDNUM			=	($ - EFFGDT)/(SIZE DESCRIPTOR)
	GDTLEN			=	$ - GDT
GDTSEG		ENDS
;中断描述符表IDT
IDTSEG 	SEGMENT 	PARA 	USE16
	IDT 	LABEL 	BYTE
	;00H号陷耕门描述符(对应除法出错故障)
	INT00 	GATE 	<DIVBegin ,Divide_SEL,0,AT386TGAT,0>
	;从01~03的3个陷饼门描述符
	REPT 3	
		GATE 	<OtherBegin,OTHER.SEL,0,AT386TGAT,0>
	ENDM
;04H号陷阱门描述符(对应溢出陷阱)
	INT04 	GATE 	<OFBegin,OF_SEL,0,AT386TGAT,0>
;从05~0AH的6个陷阱门描述符
    REPT 6	
    	GATE 		<OtherBegin,OTHER_SEL,0,AT386TGAT,0>
	ENDM
;0BH号陷阱门描述符(对应段不存在故障)
	INT0B 	GATE 	<SNPBegin,SNP_SEL,0,AT386TGAT,0>
;OCH号陷阱门描述符(对应堆栈段故障)
	INT0C 	GATE 	<SSEBegin,SSE_SEL,0,AT386TGAT,0>
;0DH号陷阱门描述符(对应通用保护故障)
	INT0D	GATE 	<GPBegin,GP_SEL,0,AT386TGAT,0>
;从OE~EDH的240个陷阱门描述符
	REPT 	254 - 14
		GATE 		<OtherBegin,OTHER_SEL,0,AT386TGAT,0>
	ENDM
;OFEH号陷阱门描述符(对应显示中断处理程序)
	INTFE 	GATE 	<EchoBegin,EchoCode_SEL,0,AT386TGAT,>
;OFFH号任务门描述符(对应读键盘中断处理任务)
	INTFF 	GATE 	<,GKeyTSS_SEL,0,ATTASKGAT,>
	IDTLEN 	= 	$	-	IDT
IDTSEG ENDS
;---------------------------------
;读键盘任务局部描述符表段
GKeyLDTSEG 	SEGMENT 	PARA 	USE16
	GLDT 	LABEL 	BYTE
	;代码段描述符
	GKEYCODE	DESCRIPTOR 	<OFFFFH,GKeyCodeSEG,,ATCE,>
	GKeyCode_SEL	=	(GKEYCODE - GLDT) + TIL
	;堆栈段描述符
	GKEYSTACK 	DESCRIPTOR 	<GKeyStackLEN-1,GKeyStackSEG,,ATDWA,>
	GKeyStack_SEL	=	(GKEYSTACK - GLDT) + TIL
	;该LDT中需要初始化基地址的描述符个数
	GKeyLDNUM		=	($ - GLDT)/(SIZE DESCRIPTOR)
	GKeyLDTLEN		=	$
GKeyLDTSEG	ENDS
;
;读键盘任务TSS段
GKeyTSSSEG 	SEGMENT 	PARA 	USE16
	DD 	0				;链接字
	DD 	?				;0级堆栈指针
	DW 	?,?
	DD 	?				;1级堆栈指针
	DW 	?,?
	DD 	?				;2级堆栈指针
	DW 	?,?
	DD 	0				;CR3.
	DW 	GKeyBegin , 0	;EIP
	DD 	0				;EFLAGS
	DD 	0				;EAX
	DD 	0				;ECX
	DD 	0				;EDX
	DD 	0				;EBX
	DW 	GKeyStackLEN,0	;ESP
	DD 	0				;EBP
	DD 	0				;ESI
	DD 	0				;EDI
	DW 	Normal_SEL,0	;ES
    DW 	GKeyCode_SEL,0	;CS
	DW	GKeyStack_SEL,0	;SS
	DW 	Normal_SEL,0	;DS
	DW 	Normal_SEL,0	;FS
	DW	Normal_SEL,0	;GS
	DW 	GKeyLDT_SEL,0	;LDT
	DW	0				;TSS的特别属性字
	DW 	$+2				;指向`I/O`许可位图区的指针
	DB 	OFFH			;`I/O`许可位图结束字节
	GKeyTSSLEN = $
GKeyTSSSEG 	ENDS
;读键盘任务堆栈段
GKeyStackSEG 	SEGMENT 	PARA 	USE16
	GKeyStackLEN = 1024
	DB 	GKeyStackLEN 	DUP 	(0)
GKeyStackSEG ENDS
;读键盘任务代码段
GKeyCodeSEG 	SEGMENT 	PARA 	USE16
	ASSUME 	CS:GKeyCodeSEG,DS:RDataSEG,ES:BufferSEG
GKeyBegin:
	PUSH 	DS
	PUSH 	ES
	PUSH 	FS
	PUSH 	GS
	MOV 	AX,Normal_SEL
	MOV 	SS,AX				;准备转实方式
    MOV 	EAX,CR0
	AND		EAX,0FFFFFFFEH
	MOV 	CR0,EAX				;转实方式
	JUMP16 	<SEG GetKey>,<OFFSET GetKey>
GetKey:;实方式
	MOV		AX,RDataSEG
	MOV 	DS,AX
	MOV 	EBP,ESP				;恢复实方式部分现场
	LSS 	SP,DWORD PTR SPVAR
	LIDT 	NORVIDTR
    STI
	MOV 	DX,OFFSET MESS
    MOV 	AH,9
	INT		21H					;显示提示信息
GetKey1:
	MOV 	AH,0
	INT		16H					;读键盘
	CMP 	AL,'0'
	JZ 		GetKey2
	CMP 	AL,'4'				;只有[0,4,B,C,D]有效
	JZ 		GetKey2
	AND		AL,11011111B		;小写转大写
	CMP 	AL,'B'
	JB 		GetKey1
	CMP 	AL,'D'
	JA 		GetKey1
GetKey2:
	MOV 	DL,AL
	MOV 	AH,2
	INT 	21H					;显示所按字符
	MOV 	AX,BufferSEG
	MOV 	ES,AX
	MOV 	ES, KeyASCII, DL	;保存到缓冲数据段
	CLI							;准备返回保护方式
	LIDT 	QWORD PTR VIDTR
	MOV 	EAX,CR0
	OR 		EAX,1
    MOV 	CRO,EAX				;返回保护方式
	JUMP16 	<GKeyCode_SEL,,OFFSET GetKeyV >
GetKeyV:;又进保护方式
	MOV 	AX.GKeyStack_SEL
	MOV 	SS,AX
	MOV 	ESP,EBP
	POP		GS
	POP		FS
	POP		ES
	POP		DS
	IRE		TD
	JMP 	GKeyBegin
	GKeyCodeLEN = 	$
GKeyCodeSEG 	ENDS
;其他中断或异常处理程序代码段
OtherCodeSEG 	SEGMENT 	PARA 	USE16
	ASSUME 		CS:OtherCodeSEG
OtherBegin:
	MOV 	SI,OFFSET MESSOTHER
	INT 	0FEH				;显示提示信息
	JMP		$					;进入无限循环
	OtherCodeLEN = $
OtherCodeSEG ENDS
;除法出错故障处理程序代码段
DIVCodeSEG 	SEGMENT 	PARA 	USE16
	ASSUME 	CS:DIVCodeSEG
DIVBegin:
	MOV 	SI,OFFSET MESSO
	MOV 	DI,0
	INT 	OFEH			;显示提示信息
	SHR 	AX,1			;处理模拟的除法错误
	IRETD
;返回
	DIVCodeLEN = $
DIVCodeSEG ENDS
;溢出陷阱处理程序代码段
OFCodeSEG	SEGMENT 	PARA 	USE16
	ASSUME 	CS:OFCodeSEG
OFBegin:
	MOV 	SI,OFFSET MESS4
	MOV 	DI,0
	INT 	0FEH	;显示提示信息
    IRETD			;返回
OFCodeLEN	=	$
OFCodeSEG	ENDS
;段不存在故障处理程序代码段
SNPCodeSEG 	SEGMENT 	PARA 	USE16
	ASSUME 	CS:SNPCodeSEG
SNPBegin:
	MOV 	SI,OFFSET MESSB
	MOV 	DI,0
	INT 	0FEH			;显示提示信息
	;
	POP 	EAX				;弹出出错代码
	CALL16	SUBCode_SEL,SUBBegin;显示出错代码
	;
	POP 	EAX
	ADD 	EAX,2			;按模拟的引起段不存在指令
	PUSH 	EAX			;调整返回地址
	IRETD
	SNPCodeLEN = $
SNPCodeSEG 	ENDS
;推找段故障处理程序代码段
SSECodeSEG 	SEGMENT 	PARA 	USE16
	ASSUME 	CS:SSECodeSEG
SSEBegin:
	MOV 	SI,OFFSET MESSC
	MOV 	DI,0
	INT 	0FEH		;显示提示信息
	POP 	EAX			;弹出出错代码
	CALL16 	SUBCode_SEL,SUBBegin;显示出错代码
	POP 	EAX
	ADD	 	EAX,4		;按模拟的引起堆栈段错误指令
	PUSH	EAX			;调整返回地址
	IRETD
	SSECodeLEN = $
SSECodeSEG	ENDS
;通用保护故障处理程序代码段
GPCodeSEG	SEGMENT 	PARA 	USE16
	ASSUME 	CS:GPCodeSEG
GPBegin:
	PUSH 	EBP
	MOV 	EBP,ESP
	PUSH 	EAX
	PUSH 	ESI				;保护现场
	PUSH 	EDI
	MOV 	SI,OFFSET MESSD
	MOV 	DI,0
	INT 	0FEH			;显示提示信息
	MOV 	EAX,[BP+4]		;从堆栈中取出错代码
	CALL16 SUBCode_SEL,SUBBegin ;显示出错代码
	POP 	EDI
	POP 	ESI				;恢复部分现场
	POP 	EAX
	ADD		DWORD PTR[EBP+8],2;按模拟的故障指令调整返回地址
	POP 	EBP
	ADD 	SP,4			;废除堆栈中的出错代码
	IRETD
	GPCodeLEN	=	$
GPCodeSEG	ENDS
;显示出错码过程代码段
SUBCodeSEG 	SEGMENT 	PARA 	USE16
	ASSUME 	CS:SUBCodeSEG
SUBBegin:
	PUSH 	AX		;AX含出错代码
	PUSH 	CX
	PUSH 	DX		;保护现场
	PUSH 	SI
	PUSH 	DI
	MOV 	SI,OFFSET ERRCODE
    MOV 	DX.AX
	MOV 	CX,4
SUBR1:
	ROL		DX,4		;把16位出错代码
	MOV 	AL,DI		;转成4位十六进制数的ASCII码
	AND 	AL,0FH		;并保存
	ADD 	AL,30H
	CMP 	AL,'9'
	JBE 	SUBR2
	ADD 	AL.
SUBR2:
	MOV		[SI],AL
	INC 	SI
	LOOP 	SUBR1
;
	MOV 	SI,OFFSET ERRMESS
	MOV 	DI,80 * 2		;在第二行首开始
	INT 	0FEH			;显示出错代码
	POP		DI
	POP		SI
	POP 	DX				;恢复部分现场
	POP 	CX
	POP
	RETF
	SUBCodeLEN = $
SUBCodeSEG 	ENDS
;实现显示的陷阱处理程序代码段
EchoCodeSEG 	SEGMENT 	PARA 	USE16
	ASSUME 		CS:EchoCodeSEG
EchoBegin:	;DS:SI指向显示信息串，ES:DI指向显示缓冲区
	PUSHAD	;保护现场
	CLD
	MOV 	AH,7
	MOV 	AL,20H
	MOV 	CX,80
	PUSH 	DI
	REP 	STOSW	;清所在显示行
	POP 	DI
Echol:
	LODSB
	OR 		AL,AL
	JZ 		Echo2
	STOSW			;显示指定信息串
	JMP 	Echol
Echo2:
	POPAD			;核复现场
	IRETD
	EchoCodeLEN = $
EchoCodeSEG	ENDS
;缓冲区数据段
BufferSEG 	SEGMENT 	PARA 	USE16
	KeyASCII 	DB ?
	Buffer		DB 128 DUP (?)
	BufferLEN	=	$
BufferSEG	ENDS
;演示任务局部描述符表段
DemoLDTSEG 	SEGMENT 	PARA 	USE16
	DLDT	LABEL 	BYTE
	;演示任务TSS段描述符
	TODEMOTSS 	DESCRIPTOR 	<DemoTSSLEN-1,DemoTSSSEG,,ATDW,>
	ToDemoTSS_SEL 	= 	(TODEMOTSS - DLDT) + TIL
;演示任务堆栈段描述符
	DEMOSTACK 	DESCRIPTOR 	<DemoStackLEN-1,DemoStackSEG,,ATDWA>
	DemoStack_SEL 	= 	(DEMOSTACK - DLDT) + TIL
;演示任务数据段描述符
	DEMODATA 	DESCRIPTOR 	<DemoDataLEN-1,DemoDataSEG,,ATDW,>
	DemoData_SEL 	= 	(DEMODATA  - DLDT) + TIL
;除法出错故障处理程序代码段描述符
	DIVIDE		DESCRIPTOR 	<DIVCodeLEN-1,DIVCodeSEG,,ATCE,>
	Divide_SEL 		= 	(DIVIDE - DLDT) + TII
;溢出陷阱处理程序代码段描述符
	OVERFLOW 	DESCRIPTOR <OFCodeLEN-1,OFCodeSEG,,ATCE,>
	OF_SEL			=	(OVERFLOW - DLDT) + TIL
;段不存在故障处理程序代码段描述符
	SNPCODE		DESCRIPTOR 	<SNPCodeLEN-1,SNPCodeSEG,,ATCE,>
	SNP_SEL			=	(SNPCODE - DLDT) + TIL
;准栈段出错故障处理程序代码段描述符
	SSECODE		DESCRIPTOR	<SSECodeLEN-1,SSECodeSEG,,ATCE,>
	SSE_SEL			=	(SSECODE - DLDT) + TIL
;通用保护故障处理程序代码段描述符
	GPCODE		DESCRIPTOR	<GPCodeLEN-1,GPCodeSEG,,ATCE,>
	GP_SEL			=	(GPCODE - DLDT) + TIL
;为模拟段不存在故障而安排的数据段描述符
	TESTNPS		DESCRIPTOR	<OFFFFH,0,,ATDW-80H,>
	TestNPS_SEL		=	(TESTNPS - DLDT) + TIL
;该LDT中需要初始化基地址的描述符个数
	Demol_DNUM		=	($ - DLDT)/(SIZE DESCRIPTOR)
	DemoLDTLEN		=	$
DemoI_DTSEG 	ENDS
;演示任务TSS段
DemoTSSSEG	SEGMENT 	PARA 	USE16
	DemoTaskSS		TASKSS	<>
					DB 0FFH
	DemoTSSLEN 	= $
DemoTSSSEG		ENDS
;演示任务堆栈段
DemoStackSEG	SEGMENT 	PARA 	USE16
	DemoStackLEN 	1024
					DB 1024 DUP (0)
DemoStackSEG	ENDS
;演示任务数据段
DemoDataSEG 	SEGMENT 	PARA 	USE16
	MESS0		DB 	'Divide Error (Exception 0)',0
	MESS4		DB 	'Overflow (Exception 4)',0
	MESSB		DB	'Segment Not Present (Exception 11)',0
	MESSC		DB	''*Stack Segment (Exception 12)',0
	MESSI		DB	'General Protection (Exception 13)',0
	MESSOTHER	DB	'Other Execption',0
	ERRMESS		DB	'Error Code ='
	ERRCODE		DB 4 DUP (0),'H',0
	DemoDataLEN =	$
DemoDataSEG 	ENDS
;演示任务代码段
DemoCodeSEG 	SEGMENT 	PARA 	USE16
	ASSUME		CS:DemoCodeSEG
DemoBegin:
	MOV 	AX,DemoLDT_SEL
	LLDT 	AX						;装载LDTR
	MOV 	AX,DemoStack_SEL
	MOV 	SS,AX					;置堆栈指针
	MOV 	ESP,DemoStackLEN
	MOV 	AX,ToDemoTSS_SEL
	MOV 	GS,AX					;把演示任务LDT选择子填入TSS
	MOV 	GS:DempTaskSS_TRLDT,DemoLDT_SEL	;装载TR
	MOV 	AX,DemoTSS.SEL
	LTR 	AX						;装载其他数据段寄存器
	MOV		AX,DemoData_SEL
	MOV		DS,AX
	MOV		AX,VideoBuff_SEL
	MOV		ES.AX
	MOV		AX,XBuffer_SEL
	MOV		FS,AX
	MOV		AX,XBuffer_SEL
	MOV		GS,AX					;接收要模拟的异常类型号
	INT		0FFH					;按接收的字符模拟异常
	MOV		AL,FS:KeyASCII
	CMP		AL,'0'
	JNZ		Demo4
Exceptiono:
	MOV 	AX,1000
	MOV 	CL,2					;模拟除法出错故障
	DIV 	CL						;该指令长2字节
	JMP 	OVER
Demo4:
	CMP 	AL,'4'
	JNZ 	Demo11
Exception4:
	MOV 	AL,100
	ADD 	AL,50
	INTO							;模拟溢出陷阱
	JMP 	OVER
Demo11:
	CMP 	AL,'B'
	JNZ		Demo12
Exception11:
	MOV 	AX,TestNPS_SEL			;模拟段不存在故障
	MOV 	GS,AX					;该指令长2字节
	JMP		OVER
Demo12:
	CMP 	AL,'C'
	JNZ		Demo13
Exception12:
	MOV	 	EBP,ESP					;模拟堆栈出错故障
	MOV 	AL,[EBP]				;该指令长4字节
	JMP		OVER
Demo13:
Exception13:
	MOV		AX,DemoTSS_SEL			;模拟通用保护故障
	MOV 	GS,AX					;该指令长2字节
	JMP		OVER					;转临时代码段
OVER: 
	JUMP16 	TempCode_SEL,<OFFSET ToDOS>
	DemoCodeLEN = $
DemoCodeSEG ENDS
;临时代码段
TempCodeSEG 	SEGMENT 	PARA 	USE16
	ASSUME 	CS:TempCodeSEG
Virtual:;转演示代码段
	JUMP16 DemoCode_SEL,0
ToDOs:;演示结束后准备返回实方式
	MOV 	AX,Normal_SEL
	MOV 	DS,AX
	MOV 	ES,AX
	MOV 	FS,AX
	MOV 	GS,AX
	MOV 	SS,AX
	MOV 	EAX,CR0
	AND 	EAX,0FFFFFFFEH
	MOV 	CR0,EAX
;返回实方式
	JUMP16	<SEG Real>,<OFFSET Real>
TempCodeSEG 	ENDS
;实方式下的数据段
RDataSEG 	SEGMENT 	PARA 	USE16
	VGDTR 	PDESC <GDTLEN-1,>		;GDT伪描述符
	VIDTR 	PDESC <IDTLEN-1,>		;IDT伪描述符
	NORVIDTR PDESC <3FFH,0>			;保存IDTR原值
	SPVAR 	DW ?					;保存原堆栈指针
	SSVAR 	DW ?
	MESS	DB "Strike a key [0,4,B,C,D]:$" ;提示信息
RDataSEG ENDS
;实方式下的代码段
RCodeSEG 	SEGMENT 	PARA 	USE16
	ASSUME 	CS:RCodeSEG,DS:RDataSEG
Start:
	MOV 	AX,RDataSEG
	MOV 	DS,AX
	CLD
	CALL 	INIT_GDT				;初始化GDT
	CALL 	INIT_IDT				;初始化IDT
	MOV 	AX,GKeyLDTSEG
	MOV 	FS,AX
	MOV 	CX,GKeyLDNUM
	MOV 	SI,OFFSET GLDT			;初始化读键盘任务LDT
	CALL 	INIT_LDT
	MOV 	AX,DemoLDTSEG
	MOV 	FS,AX
	MOV 	CX,DemoLDNUM
	MOV 	SI,OFFSET DLDT			;初始化演示任务LDT
	CALL 	INIT_LDT
	MOV 	SSVAR,SS
	MOV 	SPVAR,SP
	LGDT 	QWORD PTR VGDTR
	SIDT 	NORVIDTR
	CLI
	LIDT 	QWORD PTR VIDTR
	MOV 	EAX,CRO
	OR 		EAX,1
	MOV 	CRO,EAX
	JUMP16 	<TempCode_SEL>,<OFFSET Virtual >
Real:
	MOV 	AX,RDataSEG
	MOV 	DS,AX
	LSS 	SP,DWORD PTR SPVAR
	LIDT 	NORVIDTR
	STI
	MOV 	AX,4C00H
	INT		21H
;实方式下的初始化过程
INIT_GDT PROC NEAR
;同实例四中的过程内容
INIT GDT ENDP
INIT:
	IDTPROC
;同实例六过程内容
INIT_IDT ENDP
;
INIT_DT PROC
;同实例四过程内容
INIT LDT ENDP
RCodeSEG ENDS
	END Start
```

### 2. 关于实例七的说明

上述模拟与演示程序的许多内容与实例六相同，下面就各异常处理程序和读键盘任务的实现作些说明：

#### (1)除法出错故障处理程序的实现

从源程序可见，除法出错是在执行故意安排的被除数为1000，而除数为2的无符号除指令时引起。作为演示，除法出错故障处理程序先显示一条提示信息，然后把存放被除数的AX内容右移一位，然后就返回。由于除法出错归入故障异常这一类，所以，在故障处理结束返回后，仍执行该无符号除指令。显然，将再次引起同样的故障，仍把被除数右移一位。但由于每次处理时都把被除数减半，所以几次故障后就不发生该故障。

#### (2)溢出陷阱处理程序的实现

作为演示的溢出陷阱处理程序较简单。先显示一条提示信息，然后就返回。因为溢出异常归入陷阱这一类，所以在陷阱处理结束后，就直接返回到引起陷阱的指令的下一条指

#### (3)段不存在故障处理程序的实现

从源程序可见，段不存在故障是在执行故意安排的把一个选择子送段寄存器GS的指令时引起。该选择子索引的描述符中的存在位P被故意置为0.表示对应段不在内存。
在正常情况下，段不存在故障处理程序要把对应的段装入内存，再把描述符内的P位修改为1,于是，在故障处理结束后，引起故障的指令可得到顺利执行。为了简单，这里安排的故障处理程序先显示一条提示信息，然后显示出错码，最后调整堆栈中的返回地址并返回。段不存在故障提供一个出错码，该故障处理程序利用POP指令把它从堆栈中弹出，这样堆栈指针就指向返回地址。由于段不存在异常归入故障这一类，所以返回点仍是引起故障的指令。因此，作为演示程序调整了堆栈中的返回地址。

#### (4)堆栈段出错故障处理程序的实现

引起堆栈出错故障的原因有多种，实例通过执行故意安排的偏移超过段界限的堆栈段访问指令来模拟堆栈段出错故障的产生。作为演示的堆栈出错故障处理程序比较简单，先显示一条提示信息，然后显示出错码，最后调整堆栈中的返回地址并返回。

#### (5)通用保护故障处理程序的实现

引起通用保护故障的原因有多种，实例通过把一个指向系统段描述符的选择子装入数据段寄存器GS来模拟通用保护故障的产生。作为演示的通用保护故障处理程序，象上述两个故障处理一样比较简单，先显示一条提示信息，然后显示出错码，最后调整堆栈中的返回地址并返回，但在废除堆栈中的出错码和调整堆栈中的返回地址时采用了其他方法。

#### (6)异常处理程序的一般说明

在实例中，通向上述各种异常处理程序的门都是陷阱门。所以，在发生异常而转入这些异常处理程序时，都不发生任务切换。于是，这些异常处理仍作为演示任务的一部分。
正常情况下，异常处理程序应该注意现场的保护和恢复，但为了简单，作为演示的异常处理程序没有能够切实地保护现场。注意，这些异常处理程序所采用的处理方法与所模拟的指令有关，不适用于一般情况

#### (7)显示出错代码的过程

实例采用一个过程用于显示出错码，该过程的入口参数是AX含出错码。利用该过程不仅缩短程序，而且也用于表现异常处理程序的实现。

#### (8)读键盘任务的实现

在实例的`IDT`中，`0FFH`号门描述符是任务门，指向一个独立的任务。该任务的功能是读键盘，接收一个指定范围内的字符。演示任务通过指令`INT 0FFH`指令调用它，接收一个代表需要模拟异常的字符。
为了简单，该任务在实方式下读键盘，接收指定范围内的字符。为此，该任务每次经历如下步骤：

1. 转回到实方式。此前要做必要的准备，回到实方式后，要恢复必须的实方式下的部分现场。
2. 接收指定的字符。调用`DOS`功能显示提示信息，调用`BIOS`读键盘，如在指定范围内那么就显示，并保存在约定的数据段中。
3. 转回到保护方式，此前也要做必要的准备。

尽管在任务切换时，自动==利用`TSS`保护和恢复现场==，但由于该任务相当于一个读键盘的过程，所以在开始任务时，还通过堆栈保护必要的现场，在结束任务时恢复现场。请特别注意，安排在该任务代码段中的`IRETD`指令之后的转移指令的作用。

## 10.7.6 各种转移途径小结

如上所述，==中断/异常可引起任务切换、任务内特权级变换和任务内无特权级变换的转移==。至此，任务切换、任务内特权级变换和任务内无特权级变换转移的各种途径已全部列出。

### 1. 任务切换的途径

任务之间切换的途径如图10.22所示。段间转移指令`JMP`、段间调用指令`CALL`、软中断指令`INT`和中断返回指令`IRET`引起的任务切换是主动的任务切换，或者说是当前任务要求的任务切换。中断和异常(不包括软中断指令)引起的任务切换是被动的任务切换，或者说是不受当前任务左右的任务的切换。
==伴随着任务切换，特权级当然可能发生变换==。==只要任务切换发生，这种特权级的变换取决于目标任务，而与当前特权级无关==。

![image](https://github.com/YangLuchao/img_host/raw/master/20231128/image.2gxgy86ihhc.jpg)

### 2. 任务内特权级变换的途径

任务内特权级变换的途径如图10.23所示。==图中特权级m是外层特权级，特权级n是内层特权级==。==通常`RET`与`CALL`对应====；`IRET`与`INT`、中断/异常对应==。但也可以==通过在堆栈中建立合适环境的手段，使用`RET`或`IRET`从内层特权级变换到外层特权级==。

![image](https://github.com/YangLuchao/img_host/raw/master/20231128/image.1m1puxj6030g.jpg)

### 3. 任务内相同特权级转移的途径

任务内相同特权级转移的途径如图10.24所示。由图可见，任务内相同特权级转移的途径多种多样。

![image](https://github.com/YangLuchao/img_host/raw/master/20231128/image.5e0nqiqdsp00.jpg)

# 10.8 操作系统类指令

在第9章已介绍了80386新增的普通指令，本节介绍操作系统类指令。其中的某些指令始于80286。通常只在操作系统代码中使用这些指令，而不在应用程序代码中使用这些指令。这是把它们称为操作系统类指令的原因。为了保证操作系统的安全，保护方式下的80386支持四个特权级。相应地，这些操作系统类指令也可分为三种：

1. 实方式
2. 任何特权级下可执行的指令、实方式及特权级0下可执行的指令
3. 仅在保护方式下执行的指令

## 10.8.1 实方式和任何特权级下可执行的指令

### 1. 存储全局和中断描述符表寄存器指令

==全局描述符表`GDT`和中断描述符表`IDT`包含着系统的重要数据，对应的两个描述符表寄存器`GDTR`和`IDTR`含有这两张表的定位信息==。==利用存储描述符表寄存器指令能把描述符表寄存器的内容保存到指定的存储单元==。这样，访问这些存储单元就可获得描述符表的定位信息。与`GDT`和`IDT`被所有任务共享不同，`LDT`是每个任务私有，所以存储局部描述符表寄存器`LDTR`的指令不在所列。

#### (1)存储全局描述符表寄存器指令

==存储全局描述符表寄存器指令==的格式如下：

```assembly
SGDT DST
```

其中，==操作数`DST`是48位(6字节)的存储器操作数==。==该指令的功能是把全局描述符表寄存器`GDTR`的内容存储到存储单元`DST`==。==`GDTR`中的16位界限存入`DST`的低字，`GDTR`中的32位基地址存入`DST`的高双字==。
该指令对标志没有影响。
例如：如下指令把GDTR保存到由BX所指向的存储单元中：

```assembly
SGDT [BX]
```

#### (2)存储中断描述符表寄存器指令

==存储中断描述符表寄存器指令==的格式如下：

```assembly
SIDT DST
```

其中==，操作数`DST`是48位(6字节)的存储器操作数==。==该指令的功能是把中断描述符表寄存器`IDTR`的内容存储到存储单元`DST`==。==`IDTR`中的16位界限存入`DST`的低字，`IDTR`中的32位基地址存入`DST`的高双字==。该指令与上面的存储全局描述符表寄存器指令`SGDT`相似。
该指令对标志没有影响。
例如：如下指令把IDTR保存到由EDX所指向的存储单元中：

```assembly
SIDT [EDX]
```

### 2. 存储机器状态字指令

==存储机器状态字指令==的格式如下：

```assembly
SMSW DST
```

其中，==操作数`DST`可以是16位通用寄存器或存储单元==。==该指令的功能是把机器状态字存储到`DST`==。
该指令对标志没有影响。
例如：如下指令把机器状态字存储到AX:

```assembly
SMSW AX
```

80386有此指令是为了包含80286的指令集。由于80386的控制寄存器CR0的低16位等同于80286的机器状态字，所以在为80386编程时，如果需要存储机器状态字，那么应该使用存储CR0寄存器的指令。

## 10.8.2 实方式及特权级0下可执行的指令

下列指令涉及设置最关键的寄存器，所以只能在实方式和保护方式的特权级0下执行。为了从初始时的实方式转入保护方式，必须作基本的准备工作。例如，设置妥全局描述符表寄存器`GDTR`等。这是允许下列指令在实方式下执行的原因。
在保护方式下，如当前特权级(CPL)不为0，执行这些指令将引起错误码为0的通用保护故障。在虚拟8086方式下，因为CPL为3，所以执行这些指令也就会引起错误码为0的通用保护故障。

### 1. 清任务切换标志指令

==每当任务切换时，控制寄存器CR0中的任务切换标志TS被自动置1==。这样安排的原因已在前面说明过。
==清任务切换标志指令的功能是把TS标志清0==。该指令的格式如下：

```assembly
CLTS
```

该指令仅影响TS标志，对其他标志没有影响。

### 2. 暂停指令

暂停指令的格式如下：

```assembly
HLT
```

==该指令使处理机暂停执行==。==暂停之后的系统，只有在接受一个已经启用的中断，或者让系统复位，才能重新启动==。
该指令对标志没有影响。

### 3. 装载全局描述符表和中断描述符表寄存器的指令

#### (1) 装载全局描述符表寄存器指令

==装载全局描述符表寄存器指令==的格式如下：.

```assembly
LGDT SRC
```

其中，==操作数`SRC`是48位(6字节)的存储器操作数==。==该指令的功能是把存储器中的伪描述符装入到全局描述符表寄存器`GDTR`==。伪描述符`SRC`的结构如前述结构类型PDESC所示，低字是以字节为单位的段界限，高双字是段基地址。
该指令对标志没有影响。
例如：如下指令从BX所指向的存储单元中装载`GDTR`:

```assembly
LGDT [BX]
```

在前几节所举实例中，已多次使用了该指令。

#### (2) 装载中断描述符表寄存器指令

==装载中断描述符表寄存器指令==的格式如下：

```assembly
LIDT SRC
```

其中，==操作数`SRC`是48位(6字节)的存储器操作数==。==该指令的功能是把存储器中的为描述符装入到中断描述符表寄存器`IDTR`==。
该指令的格式与功能与装载全局描述符表寄存器指令的格式与功能类似。请参见实例六和七

### 4. 装载机器状态字指令

==装载机器状态字指令==的格式如下：

```assembly
LMSW SRC
```

其中，==操作数`SRC`可以是16位通用寄存器或存储单元==。==该指令的功能是将`SRC`装入机器状态字(也就是CR0的低16位)==。
该指令对标志寄存器中的标志没有影响
例如：如下指令把AX的内容装载到机器状态字：

```assembly
LMSW AX
```

==将PE位置1，便进入保护方式==。在80286中，没有控制寄存器，为进入保护方式需要通过该指令把MSW中的PE位置1。如果的确是这样，那么在LMSW指令后面必须紧跟一条转移指令。
80386提供此指令是为了包含80286的指令集。由于80386的控制寄存器CR0的低16位等同于80286的机器状态字，所以在为80386编程时，如果需要装载机器状态字，那么应该使用控制寄存器传送指令。

### 5. 控制寄存器数据传送指令

==控制寄存器数据传送指令==的一般格式如下：

```assembly
MOV DST,SRC
```

控制寄存器数据传送指令实现80386的控制寄存器和32位通用寄存器之间的数据传送。所以，操作数`SRC`和`DST`可以是80386使用的三个控制寄存器和任一32位通用寄存器，但不能同时是控制寄存器。
该指令对标志没有影响。
例如：

```assembly
MOV EAX,CR2 	;把CR2 送 EAX
MOV CR0,EAX 	;把EAX 送 CR0
```

### 6. 调试寄存器数据传送指令

调试寄存器数据传送指令的一般格式与上面的控制寄存器数据传送指令的格式相同。功能是实现80386的调试寄存器和32位通用寄存器之间的数据传送。操作数`SRC`和`DST`可以是80386使用的6个调试寄存器和任一32位通用寄存器，但不能同时是调试寄存器。
80386可使用的6个调试寄存器记为：`DRO`、`DR1`、`DR2`、`DR3`、`DR6`和`DR7`。
其他说明与控制寄存器数据传送指令相同。

### 7.测试寄存器数据传送指令

测试寄存器数据传送指令的一般格式与上面的控制寄存器数据传送指令的格式租同。功能是实现80386的测试寄存器和32位通用寄存器之间的数据传送。80386使用的2个测试寄存器是TR6和TR7。其他说明与控制寄存器数据传送指令相同。

## 10.8.3 只能在保护方式下执行的指令

下面介绍的指令只能在保护方式下执行。如果在实方式下执行这些指令，将引起非法操作码故障(向量号6)。

### 1. 装载和存储局部描述符表寄存器指令

#### (1) 装载局部描述符表寄存器指令

装载局部描述符表寄存器指令的格式如下：

```assembly
LLDT SRO
```

其中，==操作数`SRC`可以是16位通用寄存器或存储单元==。==该指令的功能是把`SRC`中的内容作为指示局部描述符表`LDT`的选择子装入到`LDTR`==。
该指令不影响标志。
例如：如下指令把`CX`的内容作为指向`LDT`的选择子装入`LDTR`:

```assembly
LLDT CX
```

==操作数`SRC`给定的选择子应该指示`GDT`中的类型为`LDT`的描述符==。但`SRC`也可以是一个空的选择子，如果这样的话，表示暂时不使用局部描述符表`LDT`若`CPL`不为0,那么执行该指令将产生错误码为0的通用保护故障。若被装载的选择子不指示`GDT`中描述符，或者描述符类型不是`LDT`描述符，那么产生通用保护故障，错误码由该选择子构成。
从10.3节可知，象段寄存器那样，`LDTR`也有两部分。在把指示`LDT`的选择子装入到`LDTR`可见部分时，处理器自动把选择子所索引的`LDT`描述符中的段基地址等信息保存到不可见的高速缓冲寄存器中

#### (2) 存储局部描述符表寄存器指令

==存储局部描述符表寄存器指令==的格式如下：

```assembly
SLDT DST
```

其中，==操作数`DST`可以是16位通用寄存器或存储单元==。==该指令的功能是把局部描述符表寄存器`LDTR`的内容存储到存储单元`DST`，也就是把指向当前任务`LDT`的选择子存储到`DST`==。
例如：如下指令把局部描述符表寄存器LDTR的内容保存到寄存器DX:

```
SLDT DX
```

### 2. 装载和存储任务寄存器指令

==任务寄存器`TR`指示当前任务的任务状态段`TSS`==。==随着任务的切换，`TR`的内容也随之改变==；==如果任务嵌套，那么`TR`的原值作为链接字保存到新任务的`TSS`中==。但有时候需要直接地装载`TR`，或者保存`TR`，这就需要使用装载`TR`指令和存储`TR`指令。

#### (1) 装载任务寄存器指令

==装载任务寄存器指令==的格式如下：

```assembly
LTR SRC
```

其中，==操作数SRC可以是16位通用寄存器或存储单元==。==该指令的功能是将`SRC`作为指示`TSS`描述符的选择子装载到任务寄存器`TR`==。从10.3节可知，像`LDTR`那样，`TR`也有两部分。在把指示`TSS`的选择子装入到`TR`可见部分时，处理器自动把选择子所索引的描述符中的段基地址等信息保存到不可见的高速缓冲寄存器中。所以，`SRC`表示的选择子不能为空，必须索引位于`GDT`中的描述符，并且描述符的类型必须是`TSS`。
该指令对标志没有影响。
例如：如下指令把AX的内容作为指示TSS描述符的选择子装载到TR:

```assembly
LTR AX
```

若`CPL`不为0，那么执行该指令将产生错误码为0的通用保护故障。若被加载的选择子不指示`GDT`中的`TSS`描述符，那么产生通用保护故障，错误码由该选择子构成。

#### (2) 存储任务寄存器指令

==存储任务寄存器指令==的格式如下：

```assembly
STR DST
```

其中，==操作数`DST`可以是16位通用寄存器或存储单元==。==该指令的功能是把`TR`所含的指示当前任务`TSS`描述符的选择子存储到`DST`==。
该指令对标志没有影响。
例如：如下指令把TR的内容存储到AX中：

```assembly
STR AX
```

### 3. 调整申请特权级指令

调整申请特权级指令的格式如下：

```assembly
ARPL OPRD1,OPRD2
```

其中，操作数OPRD1可以是16位通用寄存器或存储单元，操作数OPRD2是16位通用寄存器。该指令把操作数OPRD1和OPRD2视为两个选择子，用OPRD2的申请特权级(RPL)去检查OPRD1的RPL。选择子OPRD1和OPRD2的RPL分别由它们的最低2个位规定。==如果OPRD1的RPL小于OPRD2的RPL，那么零标志ZF被置1，并把OPRD2的RPL值赋予OPRD1的RPL(使它们最低2位相等)；否则，ZF被清0==。

OPRD1和OPRD2都可以是空的选择子。

该指令影响ZF，不影响其他标志。

请参见本节的示例程序。

### 4.装载存取权指令

==装载存取权指令==的格式如下：

```assembly
LAR OPRD1,OPRD2
```

其中，==操作数OPRDI可以是16位通用寄存器或32位通用寄存器==；==操作数OPRD2可以是16位通用寄存器或存储单元，也可以是32位通用寄存器或存储单元==。==操作数OPRD1和操作数OPRD2的尺寸应该一致==。该指令把操作数OPRD2视为选择子(当32位时仅使用低16位)，==如果OPRD2所指示的描述符满足如下条件，那么零标志ZF被置1，并把描述符内的属性字段装入OPRD1；否则，ZF被清0，OPRD1不变==。

1. 在描述符表的范围内
2. 是存储段描述符或系统段描述符，或者任务门描述符和调用门描述符
3. CPL和OPRD2的RPL都不大于DPL

在满足条件的情况下，装入到OPRD1的由OPRD2所指示的描述符中的属性字段是指描述符的高4字节和00FXFF00H相与的结果，其中X表示第16位到第19位无定义。

注意，如果指令使用16位操作数，那么只有上述高4字节中的低字被装入到OPRD1，也即装入到OPRD1的属性字段不包括G位和AVL位等。参见本节给出的示例程序。
该指令影响ZF，不影响其他标志。

### 5. 装载段界限指令

==装载界限指令==的格式如下：

```assembly
LSL OPRD1,OPRD2
```

其中，==操作数OPRD1可以是16位通用寄存器或32位通用寄存器==；==操作数OPRD2可以是16位通用寄存器或存储单元，也可以是32位通用寄存器或存储单元==。操作数OPRD1和操作数OPRD2的尺寸应该一致。该指令把操作数OPRD2视为选择子(当32位时仅使用低16位)，==如果OPRD2所指示的描述符满足如下条件，那么零标志ZF被置1，并把描述符内的界限字段装入OPRD1；否则，ZF被清0，OPRD1不变==。

1. 在描述符表的范围内；
2. 是存储段描述符或系统段描述符，而非门描述符；
3. CPL和OPRD2的RPL都不大于DPL。

在满足条件的情况下，装入到OPRD1的由OPRD2所指示的描述符中的界限字段以字节为单位。如果描述符中的界限字段以4K字节为单位(G=1),那么在装入到OPRD1时被左移12位，空出的低位全部填成1。

注意，如果指令使用16位操作数，那么只有段界限的低16位被装入到OPRD1。参见本节给出的示例程序。
该指令影响ZF,不影响其他标志。

### 6. 读写检验指令

==利用读检验指令和写检验指令可分别检查在当前特权级上指定的段能否读或写，从而避免引起不必要的异常==。

#### (1) 读检验指令

==读检验指令==的一般格式如下：

```assembly
VERR OPRD
```

其中，==操作数OPRD可以是16位通用寄存器或存储单元，也可以是32位通用寄存器或存储单元==。==该指令的功能是把OPRD的内容作为一个选择子(当32位时仅使用低16位)，判断在当前特权级上该选择子所指示的段是否能读==。==如果该选择子指示合法的一个存储段描述符，并且在当前特权级上可写所描述的段，那么零标志ZF被置1，否则ZF被清0==。
该指令只影响零标志2F，而不影响其他标志。

#### (2) 写检验指令

==写检验指令==的一般格式如下：

```assembly
VERW OPRD
```

其中，==操作数OPRD可以是16位通用寄存器或存储单元，也可以是32位通用寄存器或存储单元==。==该指令的功能是把OPRD的内容作为一个选择子(当32位时仅使用低16位)，判断在当前特权级上该选择子所指示的段是否能写==。==如果该选择子指示合法的一个存储段描述符，并且在当前特权级上可读所描述的段，那么零标志ZF被置1，否则ZF被清0==。
该指令只影响零标志ZF，而不影响其他标志。

## 10.8.4 显示关键寄存器内容的实例(实例八)

下面结合说明部分操作系统类指令的使用，给出一个显示80386关键寄存器内容的实例。该实例的逻辑功能，是显示系统中`GDTR`、`IDTR`、`LDTR`和`DR`等关键寄存器的当前内容。
实例八源程序清单如下：

```assembly
;程序名：T10-8.ASM
;功能：显示关键寄存器内容兼说明操作系统类指令的使用
INCLUDE	386SCD.ASM
;参见实例三
	.386P
;全局描述符表GDT
GDTSEG	SEGMENT 	PARA 	USE16
	GDT			LABEL 	BYTE
	DUMMY		DESCRIPTOR		<>
	NORMAL 		DESCRIPTOR 		<0FFFFH,0,0,ATDW,0>
	Normal_SEL			=		NORMAL - GDT		
	EFFGDT		LABEL 	BYTE
;临时代码段描述符
	TEMPCODE 	DESCRIPTOR 		<0FFFFH,TempCodeSEG,,ATCE,>
	TempCade_SEL 		= 		TEMPCODE GDT
;缓冲区段描述符
	BUFFER 		DESCRIPTOR 		<BufferLEN-1,BufferSEG,,ATDW,>
	Buffer_SEL			= 		BUFFER - GDT
;测试描述符1
	TEST1		DESCRIPTOR		 <1111H,0,,8792H,>
	TestL_SEL			=		TESTL - GDT
	TestR_SEL			=		TESTL - GDT+RPL3
;测试描述符2
	TEST2		DESCRIPTOR	 	<2222H,0,,1782H,>
	Test2_SEL			=		TEST2 - GDT
	GDNUM				=		($ - EFFGDT)/(SIZE DESCRIPTOR)
	GDTLEN				=		$ - GDT
GDTSEG		ENDS
;缓冲区段
BufferSEG 	SEGMENT 	PARA 	USE16
	GDTR_V 		PDESC		<>		;存放GDTR
	IDTR_V 		PDESC		<>		;存放IDTR
	MSW_V 		DW 			?		;存放机器状态字
	LDTR_V 		DW 			?		;存放LDTR选择子
	TR_V		DW 			?		;存放TR选择子
	CRO_V 		DD 			?		;存放控制寄存器CR0
	CR3_V 		DD 			?		;存放控制寄存器CR3
	DR7_V 		DD 			?		;存放调试寄存器DR7
	TEST_RPL 	DW 			?
	;
	TEST1_SLD 	DD 			?		;演示用变量
	TEST1_ARD 	DD 			?
	TEST1_SIW 	DW 			?
	TESTI_ARW 	DW			?
	TESTI_RF	DW			?
	TESTI_WF 	DW			?
	;
	TEST2_SLD 	DD			?		;演示用变量
	TEST2_ARD 	DD			?
	TEST2_SLW 	DW			?
	TEST2_ARW 	DW			?
	TEST2_RF 	DW			?
	TEST2_WF 	DW			?
	BufferLEN	=		$
BufferSEG ENDS
;临时代码段
TempCodeSEG 	SEGMENT 	PARA 	USE16
	ASSUME 		CS:TempCodeSEG,DS:BufferSEG
Virtual:
	MOV 	AX,Buffer_SEL
	MOV 	DS,AX
	MOV 	EAX,CR0		;存储CR0
	MOV 	CRO_V,EAX
	MOV 	EAX,CR3		;存储CR3
	MOV 	CR3_V,EAX
	MOV 	EAX,DR7		;存储DR7
	MOV 	DR7_V,EAX
	STR 	TR_V		;存储TR
	SLDT 	LDTR.V		;存储LDTR
;
	MOV 	TEST_RPL,Test1.SEL
	MOV 	AX,TestR.SEL
	ARPL 	TEST_RPL.AX		;说明调整申请特权级指令
;
	MOV 	BX,0
	MOV 	AX.TEST1.SEL
LAB1:
	MOV 	EDX,0
	MOV 	CX,0
	LSL 	EDX,EAX			;说明装载段界限指令
	LSL 	CX,AX
	MOV 	TEST1_SLD[BX],EDX
	MOV 	TEST1_SLW[BX],CX
	MOV 	EDX,0
	MOV 	CX,0
	LAR 	EDX,EAX			;说明装载存取权指令
	LAR 	CX,AX
	MOV		TEST1_ARD[BX],EDX
	MOV		TEST1_ARW[BX],CX
	MOV		TEST1_RF[BX],0
	VERR 	AX				;说明读检验指令
	JNZ 	LAB2
	MOV 	TEST1_RF[BX],1
LAB2:
	MOV 	TEST1_WF[BX],0
	VERW	AX				;说明写检验拾令
	JNZ		LAB3
	MOV		TEST1_WF[BX],1
LAB3:
	ADD		BX,16
	MOV 	AX,TEST2_SEL
	CMP		BX,32
	JB
	LAB1
Over:
	;准备返回实方式
	MOV 	AX,Normal_SEL
	MOV 	DS.AX
	MOV 	EAX,CR0
	AND 	EAX,0FFFFFFFEH
	MOV 	CRO,EAX			;返回实方式
	JUMP16 	<SEG Real>,<OFFSET Real>
TempCodeSEG ENDS
;实方式下的数据段和代码段
RCodeSEG 	SEGMENT 	PARA 	USE16
	VGDTR 	PDESC 	<GDTLEN-1,>
	ASSUME 	CS:RCodeSEG,DS:BufferSEG
Start:
;实方式
	MOV 	AX,BufferSEG
	MOV 	DS,AX
	SGDT 	GDTR_V		;存储GDTR
	SIDT 	IDTR-V		;存储IDTR
	SMSW 	MSW_V		;存储机器状态字
;准备转入保护方式
	PUSH 	CS
	POP 	DS
	CLD
	CALL 	INIT_GDT
	MOV 	BX,OFFSET VGDTR
	LGDT 	[BX]
	CLI
	MOV 	EAX,CR0
	OR 		EAX,1
;转入保护方式
	MOV 	CR0,EAX
	JUMP16 	<TempCode_SEL>,<OFFSET Virtual>
Real:
;回到实方式
	STI
;(略去显示相关变量内容的部分代码)
	MOV AX,4C00H
	INT	21H
;实方式下的初始化过程
INIT GDT PROC NEAR
;同实例四中的过程内容
INIT_GDTENDP
RCodeSEG ENDS
	END Start
```

## 10.8.5 特权指令

==所谓特权指令是指保护方式下只有当前特权级`CPL=0`时，才可以执行的指令==。如果`CPL`不等于0而执行它们，那么会引起通用保护异常。从上面介绍的操作系统类指令可归纳出如表10.8所列的80386特权指令。这些特权指令在构成完善的保护机制方面起了重要作用。

![image](https://github.com/YangLuchao/img_host/raw/master/20231128/image.407xb3f6xde0.jpg)

从表10.8可见，==装入`GDTR`、`IDTR`、`LDTR`、`TR`和`MSW`的指令都是特权指令，而存储上述寄存器的指令不是特权指令==。这表示，==保护方式下任何程序可获取这些寄存器的值，但只有具有特权级0的程序才能够改变这些寄存器的值==。从表10.8还可见，设置和存储控制寄存器及调试寄存器的指令都是特权指令。

# 10.9 输入/输出保护

==为了支持多任务，80386不仅要有效地实现任务隔离，而且还要有效地控制各任务的输入/输出，避免输入/输出冲突==。本节介绍输入/输出保护。

## 10.9.1 输入/输出保护

==80386采用`I/O`特权级IOPL和`I/O`许可位图的方法来控制输入/输出，实现输入/输出的保护==。

### 1. `I/O`敏感指令

==输入/输出特权级(`I/O` Privilege Level)规定了可以执行所有与`I/O`相关的指令和访问`I/O`空间中所有地址的最外层特权级==。`IOPL`值在如图9.2所示的标志寄存器中。==``I/O``许可位图规定了``I/O``空间中的哪些地址可以由在任何特权级执行的程序所访问==。`I/O`许可位图在任务状态段TSS中。

![image](https://github.com/YangLuchao/img_host/raw/master/20231128/image.20rngg7fz7s0.jpg)

表10.9所列的==指令称为`I/O`敏感指令==。==由于这些指令与`I/O`有关，并且只有在满足所列条件时才可以执行，所以把它们称为I/Q敏感指令==。从表10.9可见，==当前特权级不在`I/O`特权级外层时，可以正常执行所列的全部`I/O`敏感指令==；当前特权级在`I/O`特权级外层时，执行`CLI`和`STI`指令将引起通用保护异常；当前特权级在`I/O`特权级外层时，其他四条输入/输出指令是否能够执行要根据访问的`I/O`地址及`I/O`许可位图情况而定(在下面细述)，如果条件不满足而执行，那么将引起通用保护异常。
由于==每个任务使用各自的`EFLAGS`值和拥有自己的`TSS`，所以每个任务可以有不同的`IOPL`，并且可以定义不同的`I/O`许可位图==。
==注意，这些`I/O`敏感指令在实方式下总是可执行的==。

### 2. `I/O`许可位图

如果只用`IOPL`限制`I/O`指令的执行是很不方便的，不能满足实际需要。因为这样做会使得在特权级3执行的应用程序，要么可访问所有`I/O`地址，要么不可访问所有`I/O`地址。实际需要与此刚好相反，只允许任务甲的应用程序访间部分`I/O`地址，只允许任务乙的应用程序访问另一部分的`I/O`地址，以避免任务甲和任务乙在访问`I/O`地址时发生冲突，从而避免任务甲和任务乙使用独享设备时发生冲突

所以，==在`IOPL`的基础上，再采用了`I/O`许可位图==。==`I/O`许可位图由二进制位串组成==。==位串中的每一位依次对应一个`I/O`地址，位串的第0位，对应`I/O`地址0，位串的第n位对应`I/O`地址n==。==如果位串中的m位为0，那么对应的`I/O`地址m可以由在任何特权级执行的程序访问==；==否则对应的`I/O`地址m只能由在`IOPL`特权级或更内层特权级执行的程序访问==。==如果在`IOPL`外层特权级执行的程序访问位串中位值为1的位所对应的`I/O`地址，那么引起通用保护异常==。
==`I/O`地址空间按字节进行编址==。一条`I/O`指令最多可涉及四个`I/O`地址。例如，如下指令读取`I/O`端口71H~74H内的四个字节至`EAX`:

```assembly
IN EAX,71H
```

==在需要根据`I/O`位图决定是否可访问`I/O`地址的情况下，当一条`I/O`指令涉及多个`I/O`地址时，只有这多个`I/O`地址所对应的`I/O`位图中的位都为0时，该`I/O`指令才能正常执行；如果对应位中任一位为1，就会引起通用保护异常。==
==80386支持的`I/O`地址空间大小是64K，所以构成`I/O`许可位图的二进制位串最大长度是64K个位，也即`I/O`许可位图有效部分最大是8K字节==。一个任务实际需要使用的`I/O`许可位图大小通常要远小于这个数目。
==当前任务使用的`I/O`许可位图存储在当前任务`TSS`中低端的64K字节内==。==`I/O`许可位图总以字节为单位存储，所以位串所含的位数总被认为是8的倍数==。从如图10.14所示的TSS格式可见，`TSS`内偏移66H的字确定`I/O`许可位图的开始偏移。由于`I/O`许可位图最长可达8K字节，所以开始偏移应该小于56K。

### 3. `I/O`访问许可检查细节

保护方式下处理器在执行`I/O`指令时进行许可检查的细节如图10.25所示。==图中`字节偏移`是`I/O`指令访问的`I/O`地址对应位所在字节在`I/O`许可位图内的偏移，把`I/O`地址右移3位就得该字节偏移==；==`位偏移`是上述对应位在字节内的位数，根据它计算出屏蔽码字==。==把字节偏移加上位图开始偏移，再加上1，所得值与`TSS`界限比较，如果越界，那么就引起通用保护异常==。==如果不越界，那么就从位图中读出对应字节及下一字节，并和屏蔽字进行与运算，结果为0表示检查通过可以进行`I/O`访问，结果非0就引起通用保护异常==。
设任务甲的`TSS`段如下：

```assembly
TSSSEGA 	SEGMENT 	PARA 	USE16
	TASKSS 		<>		;TSS低端固定格式部分
	DB	8	DUP(0)		;对应`I/O`端口0~3FH
	DB	10000000B		;对应`I/O`端口40H~47H
	DB	01100000B		;对应`I/O`端口48H~4FH
	DB 	8182 DUP (OFFH)	;对应`I/O`端口50H~FFFFH
	DB 	OFFH			;位图结束字节
	TSSLENA = $
TSSSEGA ENDS
```

再假设`IOPL=1`,`CPL=3`。那么如下`I/O`指令有些能正常执行，有些会引起通用保护异常：

```assembly
IN 		AL,21H	;(1)正常执行
IN 		AL,47H	;(2)引起异常
OUT 	20H,AL	;(3)正常执行
OUT 	4FH,AL	;(4)引起异常
IN 		AX,20H	;(5)正常执行
OUT 	20H,EAX	;(6)正常执行
OUT 	4CH,AX	;(7)引起异常
IN 		AX,46H	;(8)引起异常
IN		EAX,42H	;(9)正常执行
```

从图10.25所示的细节可见，==不论是否有必要，当进行许可位检查时，80386总是从`I/O`许可位图中读取两个字节==。==目的是为了尽快地进行`I/O`许可检查==。一方面，常常要读取`I/O`许可位图中的两个字节。例如：上面的第(8)条指令要对`I/O`位图中的两个位进行检查，其低位是某字节的最高位，高位是下一字节的最低位。可见即使只要检查两个位，也可能需要读取两个字节。另一方面，最多检查四个连续的位，也即最多也只需读取两个字节。所以每次都读取两个字节。这也是在判别是否越界时再加1的缘故。为此，为了避免在读取`I/O`许可位图内的最高字节时产生越界，必须在`I/O`许可位图的最后添加一个全1的字节。

![image](https://github.com/YangLuchao/img_host/raw/master/20231128/image.5unm66y74h00.jpg)

从图10.25及其关于字节越界的说明可知，`I/O`许可位图开始偏移加8K所得值与`TSS`界限值二者中较小的值决定`I/O`许可位图的末端。当`TSS`的界限大于`I/O`许可位图开始偏移加8K时，`I/O`许可位图有效部分就有8K字节，`I/O`许可检查全部根据该位图进行。当`TSS`的界限不大于`I/O`许可位图开始偏移加8K时，`I/O`许可位图有效部分就不到8K字节，于是对较小`I/O`地址访问的许可检查根据位图进行，而对较大`I/O`地址访问的许可检查总被认为不可访问而引起通用保护异常，因为这时会发生字节越界而引起通用保护异常，所以在这种情况下，可认为不足的`I/O`许可位图的高端部分是全1。利用这一特点，可大大节约`TSS`中`I/O`许可位图占用的存储单元，也就大大减小了`TSS`。

设任务乙的TSS段如下：

```assembly
TSSSEGB 	SEGMENT 	PARA 	USE16
	TASKSS		<>				;TSS的低端部分
	DB 		100H/8 DUP (OFFH)	;对应`I/O`端口0~FFH
	DB 		100H/8 DUP(0)		;对应`I/O`端口100H~1FFH
	DB 		OFFH
	TSSLENB	=		$
TSSSEGB 	ENDS
```

上面任务乙的TSS内只含`I/O`许可位图的最初200H位，对应`I/O`端口地址0~1FFH,而其他位都可以被认为是1。
设任务丙的TSS段如下：

```assembly
TSSSEGC 	SEGMENT 	PARA 	USE16
	TASKSS		<>				;TSS的低端部分
	DB 		100H/8 DUP(0)		;对应I/O端口0~FFH
	DB 		OFFH
	TSSLENC = $
TSSSEGC ENDS
```

上面任务丙的`TSS`内只含`I/O`许可位图的最初100H位，对应`I/O`端口地址0~0FFH,而其他位都可以被认为是1。
设任务丁的TSS段如下：

```assembly
TSSSEGD 	SEGMENT 	PARA 	USE16
	TASKSS		<>
			DB 		0FFH
	TSSLENC = $
TSSSEGD ENDS
```

上面任务丁的`TSS`内只有`I/O`许可位图结束字节，而无有效的`I/O`许可位图。综上所述，使用`I/O`许可位图可以较好地满足实际应用需要。在方便应用程序进行输入/输出的同时，限制输入/输出，避免任务间在使用外设时发生冲突。

## 10.9.2 重要标志保护

==输入/输出的保护与存储在标志寄存器`EFLAGS`中的`IOPL`密切相关，显然不能允许随便地改变`IOPL`,否则就不能有效地实现输入/输出保护==。类似地，对`EFLAGS`中的`IF`位也必须加以保护，否则`CLI`和`STI`作为敏感指令对待是无意义的。此外，`EFLAGS`中的`VM`位决定着处理器是否按虚拟8086方式工作。
80386对`EFLAGS`中的这三个字段的处理比较特殊，只有在较高特权级执行的程序才能执行`IRET`，`POPF`，`CLI`和`STI`等指令来改变它们。表10.10列出了不同特权级下对这三个字段的处理情况。

![image](https://github.com/YangLuchao/img_host/raw/master/20231128/image.10lygumb6ysw.jpg) 

从表10.10可见，==只有在特权级0执行的程序才可以修改`IOPL`位及`VM`位==；==只能由相对于`IOPL`同级或更内层特权级执行的程序才可以修改`IF`位==。==与`CLI`和`STI`指令不同，在特权级不满足上述条件的情况下，当执行`POPF`指令和`IRET`指令时，如果试图修改这些字段中的任何一个字段，并不引起异常，但试图要修改的字段也未被修改，也不给出任何特别的信息==。
此外，指令`POPF`总不能改变VM位，而`PUSHF`指令总把0压入到`VM`位。

## 10.9.3 演示输人/输出保护的实例(实例九)

下面给出一个用于演示输入/输出保护的实例。演示内容包括：`I/O`许可位图的作用、`I/O`敏感指令引起的异常和特权指令引起的异常；使用段间调用指令`CALL`通过任务门
调用任务，实现任务嵌套等。

### 1.演示步骤

实例演示的内容比较丰富，具体演示步骤如下：

1. 在实方式下作必要准备后，切换到保护方式。
2. 进入保护方式的临时代码段后，把演示任务的`TSS`段描述符装入`TR`，设置演示任务的堆栈。

3. 进入演示代码段，演示代码段的特权级是0。

4. 通过任务门调用测试任务1。测试任务1能够顺利执行。

5. 通过任务门调用测试任务2。测试任务2演示由于违反`I/O`许可位图规定而导致通用保护异常。

6. 通过任务门调用测试任务3。测试任务3演示`I/O`敏感指令如何引起通用保护异

7. 通过任务门调用测试任务4。测试任务4演示特权指令如何引起通用保护异常

8. 从演示代码转临时代码，准备返回实方式。

9. 返回实方式，并作结束处理。


### 2.源程序组织和清单

为了达到演示目的，实例除了演示任务外，还涉及四个测试任务和一个通用保护故障
处理任务。实例有如下几部分组成；

1. 全局描述符表`GDT`和中断描述符表`IDT`;
2. 其他中断/异常处理程序代码段；

3. 通用保护故障处理任务的任务状态段、堆栈段和代码段；

4. 四个测试任务合用的任务状态段、堆栈段和代码段；

5. 演示任务的任务状态段、堆栈段和代码段：

6. 演示任务的临时代码段；

7. 实方式下执行的启动和结束程序代码段和数据段。


实例九源程序清单如下：

```assembly
;程序名：T10-9.ASM
;功能：演示`I/O`保护及I/Q敏感指令的作用
	INCLUDE	386SCD.ASM;参见实例三说明
	.386P
;------------------------------
;全局描述符表GDT
GDTSEG 	SEGMENT 	PARA 	USE16
	GDT		LABEL 	BYTE
	DUMMY	DESCRIPTOR		<>
	NORMAL 	DESCRIPTOR		<OFFFFH,0,0,ATDW,0>
	Normal_SEL		= 		NORMAL - GDT
	EFFGDT 	LABEL 	BYTE
;显示缓冲区段描述符(任何特权级可写)
	VIDEOBUFF 	DESCRIPTOR 	<80*25*2-1,0B800H,,ATDW+DPL3,>
	VideoBuff_SEL	=		VIDEOBUFF - GDT
;演示任务TSS段描述符
	DEMOTSS 	DESCRIPTOR 	<DemoTSSLEN-1 , DemoTSSSEG , , AT386TSS ,>
	DemoTSS_SEL		=		DEMOTSS - GDT
;演示任务堆栈段描述符
	DEMOSTACK 	DESCRIPTOR 	<DemoStackLEN-1,DemoStackSEG,,ATDW+D32,>
	DemoStack_SEL 	= 		DEMOSTACK - GDT
;演示任务代码段描述符
	DEMOCODE 	DESCRIPTOR 	<DemoCodeLEN-1,DemoCodeSEG,,ATCE+D32,>
	DemoCode_SEL 	= 		DEMOCODE - GDT
;属于演示任务的临时代码段描述符
	TEMPCODE 	DESCRIPTOR 	<0FFFFH,TempCodeSEG,,ATCE,>
	TempCode_SEL 	= 		TEMPCODE - GDT
;指向GDT的存储段描述符
	TOGDT		DESCRIPTOR 	<GDTLEN-1,GDTSEG,,ATDW,>
	ToGDT_SEL 		= 		TOGDT - GDT
;指向通用保护故障处理任务TSS的存储段描述符
	TOGPTSS 	DESCRIPTOR 	<GPTSSLEN-1,GPTSSSEG,,ATDW,>
	TOGPTSS_SEL 	= 		TOGPTSS - GDT
;指向测试任务TSS的存储段描述符
	TOTESTTSS 	DESCRIPTOR 	<TestTSSLEN-1, TestTSSSEG , , ATDW ,>
	ToTestTSSSEL	=		TOTESTTSS - GDT
;测试任务TSS段描述符
	TESTTSS 	DESCRIPTOR 	<TestTSSLEN-1 , Test TSSSEG , , AT386TSS ,>
	TestTSS_SEL		=		TESTTSS - GDT
;测试任务1堆栈段描述符(DPL=1)
	TESTISTACK 	DESCRIPTOR 	<TestStackLEN-1 , TestStackSEG,,ATDW+D32+DPL1,>
	Test1Stack_SEL 	= 		(TESTISTACK - GDT) + RPL1
;测试任务1代码段描述符(DPL=1)
	TESTICODE 	DESCRIPTOR 	<TestCodeLEN-1,TestCodeSEG,,ATCE+D32+DPL1,>
	Test1Code_SEL	=		(TESTICODE - GDT) + RPL1
;测试任务2堆栈段描述符(DPL=2)
	TEST2STACK	DESCRIPTOR 	<TestStackLEN-1,TestStackSEG,,ATDW+D32+DPL2,>
	Test2Stack_SEL	=		(TEST2STACK - GDT) + RPL2
;测试任务2代码段描述符(DPL=2)
	TEST2CODE 	DESCRIPTOR 	<TestCodeLEN-1,TestCodeSEG,,ATCE+D32+DPL2,>
	Test2Code_SEL	=		(TEST2CODE - GDT) + RPL2
;测试任务3堆栈段描述符(DPL=3)
	TEST3STACK 	DESCRIPTOR 	<TestStackLEN-1,TestStackSEG,,ATDW+D32+DPL3,>
	Test3Stack_SEL 	= 		(TEST3STACK - GDT) + RPL3
;测试任务3代码段描述符(DPL=3)
	TEST3CODE 	DESCRIPTOR 	<TestCodeLEN-1,TestCodeSEG,,ATCE+D32+DPL3,>
	Test3Code_SEL 	= 		(TEST3CODE - GDT) + RPL3
;通用保护故障处理任务的TSS段描述符
	GPTSS 		DESCRIPTOR 	<GPTSSLEN-1,GPTSSSEG,,AT386TSS,>
	GPTSS_SEL 		= 		GPTSS - GDT
;通用保护故障处理任务的堆栈段描述符
	GPSTACK 	DESCRIPTOR 	<GPStackL,EN-1,GPStackSEG.,ATDW+D32,>
	GPStack_SEL 	= 		GPSTACK - GDT
;通用保护故障处理任务的代码段描述符
	GPCODE 		DESCRIPTOR 	<GPCodeLEN-1,GPCodeSEG,,ATCE+D32,>
	GPCode_SEL 		= 		GPCODE - GDT
;其他中断/异常处理程序代码段描述符(一致可读代码段)
	ERRCODE 	DESCRIPTOR <ERRCodeLEN-1,ERRCodeSEG,,ATCCOR+D32,>
	ERRCode_SEL 	= 		ERRCODE - GDT
	GDNUM 			= 		($ - EFFGDT)/(SIZE DESCRIPTOR);要初始化的描述符个数
;指向测试任务的任务门
	TESTTASK	GATE 		<,TestTSS_SEL,0.ATTASKGAT,>
	Test_SEL		=		TESTTASK - GDT
	GDTLEN 			= 		$ - GDT
GDTSEG 		ENDS
;中断描述符表IDT
IDTSEG 	SEGMENT 	PARA 	USE16
	IDT 	LABEL BYTE
	REPT 	13
	GATE 	<ERRBegin,ERRCode_SEL,0,AT386TGAT,0>
	ENDM
	INTOD 	GATE <,GPTSS_SEL,O,ATTASKGAT, ;通用故障处理门描述符
	REPT 	254 - 14
	GATE 	<ERRBegin,ERRCode_SEL,0,AT386TGAT,0>
	ENDM
	IDTLEN	=	$ - IDT
IDTSEG ENDS
;-----------------------------------------------------
;其他中断/异常处理程序代码段(一致的可读代码段)
ERRCodeSEG 	SEGMENT 	PARA 	USE32
	ERRMESS		DB		'Error......................'
	ERRMESSLEN 	= 		$ - ERRMESS
	ASSUME 	CS:ERRCodeSEG
ERRBegin:
	CLD
	MOV AX,ERRCode_SEL
	MOV DS,AX				;可读代码段
	LEA	ESI,ERRMESS
	MOV AX,VideoBuff_SEL
	MOV ES,AX
	XOR EDI,EDI
	MOV ECX,ERRMESSLEN
	MOV AH,17H
ERR1:
	LODSB					;显示提示信息
	STOSW
	LOOP ERR1
	JMP	$					;循环等待
	ERRCodeLEN	=	$
ERRCodeSEG		ENDS
;通用保护故障处理任务的TSS段
GPTSSSEG 	SEGMENT 	PARA 	USE16
	GPTaskSS 	LABEL	BYTE
	DD 		0		;任务钱套时的链接指针
	DD 		?		;0级堆栈指针
	DW 		?,?
	DD 		?		;1级堆栈指针
	DW 		?,?
	DD 		?		;2级堆栈指针
	DW 		?,?
	DD 		0		;CR3
	DW 		GPBegin,0	;EIP
	DD 		0		;EFLAGS
	DD 		0		;EAX
	DD	 	0		;ECX
	DD 		0		;EDX
	DD 		0		;EBX
	DW GPStackLEN,0	;ESP
	DD 		0		;EBP
	DD 		0		;ESI
	DD 		0		;EDI
	DW 		VideoBuff_SEL,0		;ES
	DW 		GPCode_SEL,0		;CS
	DW 		GPStack_SEL,0
	DW 		ToTestTSS_SEL,0 	;DS
	DW 		ToGPTSS_SEL.0		;FS
	DW 		0,0					;GS
	DW 		0,0					;LDT
	DW 		0
	DW 		$+2					;指向`I/O`许可位图区的指针
	DB 		0FFH				;`I/O`许可位图结束标志
	GPTSSLEN = $
GPTSSSEG 	ENDS
;通用保护故障处理任务的堆栈段
GPStackSEG 	SEGMENT 	PARA 	USE32
	GPStackLEN = 512
	DB 	GPStackLEN DUP (0)
GPStackSEG ENDS
;通用保护故障处理任务的代码段
GPCodeSEG 	SEGMENT 	PARA 	USE32
	ASSUME 	CS:GPCodeSEG
GPStart:;在屏幕左上角显示故障点
	XOR 	EDI,EDI
	MOV 	EBX.OFFSET TestTaskSS
	MOV 	EDX,DWORD PTR [EBX].TRCS
    CALL 	EchoEDX
	MOV 	AX,(17H SHL 8) + ':'
    STOSW
	MOV 	EDX,[EBX].TREIP
	CALL 	EchoEDX				;延时以便看清故障点
	MOV	 	ECX,1234567H
	LOOP 	$					;调整任务链接指针，终止故障任务
	MOV 	EBX,OFFSET GPTaskSS
	MOV 	AX,DemoTSS_SEL
	MOV 	FS,[EBX].TRLINK,AX
	IRETD
GPBegin;通用故障处理任务开始点
	JMP 	GPStart
;显示EDX内容的子程序
EchoEDX PROC
	MOV 	AH,17H
	MOV		ECX,8
EchoEDX1:
    ROL 	EDX.4
	MOV		AL,DL
	CALL 	HTOASC
	STOSW
	LOOP 	EchoEDX1
	RET
EchoEDX ENDP
;把4位二进制数转换成对应ASCII码
HTOASC 	PROC
;内容略
HTOASC 	ENDP
GPCodeLEN 	= 	$
GPCodeSEG ENDS
;测试任务的TSS段
TestTSSSEG 	SEGMENT 	PARA 	USE16
	TestTaskSS 	TASKSS 	<>
	;TSS的固定格式部分
	IOMAP 	LABEL 	BYTE		;`I/O`许可位图
	DB 		8 	DUP (0)			;端口0000H~003FH
	DB 		11000100B			;端口0040H~0047H
	DB		00111011B			;端口0048H~004FH
	DB 		0,0					;端口0050H~005FH
	DB 		11110010B			;端口0060H~0067H
	DB		0					;端口0068H~006FH
	DB 		OFFH				;`I/O`许可位图结束标志
	TestTSSLEN = $
TestTSSSEG ENDS
;
;测试任务的堆栈段
TestStackSEG 	SEGMENT 	PARA 	USE32
	TestStackLEN	=	1024
	DB 		TestStackLEN 	DUP(0)
TestStackSEG ENDS
;测试任务的代码段
TestCodeSEG 	SEGMENT 	PARA 	USE32
	ASSUME 	CS:TestCodeSEG
Test3Begin:
	CLI					;`I/O`敏感指令
	CLTS				;特权指令
	IRETD
TestBegin:
	MOV 	AL,0B6H		;使扬声器发出一长声
	OUT 	43H,AL
	MOV 	AL,2
	OUT 	42H,AI.
	MOV 	AL,34H
	OUT 	42H,AL
	IN 		AL,61H
	MOV 	AH,AL
	OR 		AL,3
    OUT 	61H,AL
	MOV 	ECX,1234567H
	LOOP 	$			;延时
	MOV		AL,AH
	OUT 	61H,AL
	IRETD
	TestCodeLEN = $
TestCodeSEG 	ENDS
;演示任务的TSS段
DemoTSSSEG		SEGMENT 	PARA 	USE16
	DemoTaskSS	TASKSS	<>
				DB 		0FFH
	DemoTSSLEN 		= 	$
DemoTSSSEG ENDS
;演示任务的堆栈段
DemoStackSEG 	SEGMENT 	PARA 	USE32
	DemoStackLEN 	= 	1024
		DB 	DemoStackLEN DUP (0)
DemoStackSEG ENDS
;演示任务的代码段
DemoCodeSEG 	SEGMENT 	PARA 	USE32
	ASSUME 	CS:DemoCodeSEG
DemoBegin:
	MOV 	AX,ToTestTSS_SEL
	MOV 	DS,AX
	MOV 	EBX.OFFSET TestTaskSS
;把测试任务1的入口点、堆栈指针和标志值(含IOPL)填入测试任务TSS
	MOV		WORD PTR[EBX].TRSS,Test1Stack.SEL
	MOV 	DWORD PTR [EBX].TRESP,TestStackLEN
	MOV 	WORD PTR [EBX].TRCS,Test1Code_SEL
	MOV 	DWORD PTR [EBX].TREIP,OFFSET TestBegin
	MOV		DWORD PTR[EBX].TREFLAG,IOPL1
;通过任务门调用测试任务
	CALL32	Test_SEL,0
;
;把测试任务2的入口点、堆栈指针和标志值(含IOPL)填入测试任务TSS
	MOV 	WORD PTR [EBX].TRSS,Test2Stack_SEL
	MOV 	DWORD PTR [EBX],TRESP.TestStackLEN
	MOV 	WORD PTR [EBX].TRCS,Test2Code_SEL
	MOV 	DWORD PTR [EBX].TREIP,OFFSET TestBegin
	MOV 	DWORD PTR [EBX].TREFLAG,IOPL1
;通过任务门调用测试任务
	CALL32 	Test_SEL,0
;把测试任务TSS描述符内的属性置为“可用”
	MOV 	AX,ToGDT_SEL
	MOV 	FS,AX
	MOV 	FS:TESTTSS.ATTRIBUTES,AT386TSS
;把测试任务3的入口点、堆栈指针和标志值(含IOPL)填入测试任务TSS
	MOV 	WORD PTR [EBX].TRSS, Test3Stack_SEL
	MOV 	DWORD PTR [EBX].TRESP, TestStackLEN
	MOV 	WORD PTR [EBX].TRCS,Test3Code_SEL
	MOV 	DWORD PTR [EBX].TREIP,OFFSET Test3Begin
	MOV 	DWORD PTR [EBX].TREFLAG,IOPL2
;通过任务门调用测试任务
	CALL32 	Test_SEL,0
;把测试任务TSS描述符内的属性置为“可用”
	MOV 	AX,ToGDT.SEL
	MOV 	FS,AX
	MOV 	FS:TESTTSS.ATTRIBUTES,AT386TSS
;把测试任务4的入口点、堆栈指针和标志值(含IOPL)填入测试任务TSS
	MOV 	WORD PTR [EBX].TRSS,Test3Stack_SEL
	MOV 	DWORD PTR [EBX].TRESP,TestStackLEN
	MOV 	WORD PTR [EBX]. TRCS, Test3Code_SEL
	MOV 	DWORD PTR [EBX].TREIP,OFFSET Test3Begin
	MOV 	DWORD PTR [EBX].TREFLAG,IOPL3
;通过任务门调用测试任务
	CALL32	Test_SEL,0
OVER: 
	JUMP32 TempCode_SEL,<OFFSET ToDOs>
	DetnoCodeLEN = $
DemoCodeSEG		ENDS
;演示任务的临时代码段
TempCodeSEG 	SEGMENT 	PARA 	USE16
	ASSUME 	CS:TempCodeSEG
Virtual:
;置数据段寄存器为空
	MOV 	AX,0
	MOV 	DS,AX
	MOV 	ES,AX
	MOV 	FS,AX
	MOV 	GS,AX				;置堆栈指针
	MOV 	AX,DemoStack_SEL
	MOV 	SS,AX
	MOV 	ESP,DemoStackLEN	;置任务寄存器TR
	MOV 	AX,DemoTSS_SEL
	LTR 	AX					;转演示代码段
	JUMP16 	DemoCode_SEL,DemoBegin
ToDOS:
	CLTS						;清任务切换标志TS
	MOV 	AX,Normal_SEL
	MOV 	DS,AX				;把规范数据段描述符装入段寄存器
	MOV 	ES,AX
	MOV 	FS,AX
	MOV 	GS,AX
    MOV 	SS,AX
	MOV 	EAX,CR0
	AND 	EAX,0FFFFFFFEH
	MOV 	CR0,EAX					;切换到实方式
	JUMP16 	<SEG Real , OFFSET Real
TempCodeSEG ENDS
;实方式数据段
RDataSEG 	SEGMENT 	PARA 	USE16
	VGDTR	PDESC		<GDTLEN-1,>
	VIDTR	PDESC		<IDTLEN-1,>
	NORVIDTR PDESC 		<3FFH,0>
	SPVAR	DW 			?
	SSVAR	DW 			?
RDataSEG 	ENDS
;实方式代码段
RCodeSEG 	SEGMENT 	PARA 	USE16
	ASSUME 	CS:RCodeSEG,DS:RDataSEG
Start:
	MOV 	AX,RDataSEG
	MOV 	DS,AX
	CLD
	CALL 	INIT_GDT
	CALL 	INIT_IDT
	LGDT 	QWORD PTR VGDTR
	MOV 	SSVAR,SS			;保存实方式堆栈指针
	MOV 	SPVAR,SP
	SIDT 	NORVIDTR			;保存IDTR
	CLI
	LIDT 	QWORD PTR VIDTR
	MOV 	EAX,CR0
	OR 		EAX,1
	MOV 	CR0,EAX				;切换到保护方式
	JUMP16 	<TempCode_SEL>,<OFFSET Virtual>
Real:;实方式
	MOV 	AX,RDataSEG
	MOV 	DS,AX
	LSS 	SP,DWORD PTR SPVAR
	LIDT 	NORVIDTR			;恢复IDTR
	STI
	MOV		AX,4C00H			;返回DOS
	INT		21H
INIT_GDT PROC NEAR
;同实例四中的过程内容
INIT_GDT 	ENDP
INIT IDT 	PROC
;同实例六中的过程内容
INIT_IDT	ENDP
RCodeSEG 	ENDS
END Start
```

### 3.关于实例九的说明

为了节省篇幅，同时也反映任务状态段的作用，实例通过任务门调用的四个测试任务合用一个任务状态段。从源程序可见，这种合用，实际上是串行的。先把测试任务1的入口点填入测试任务状态段，同时填入堆栈指针，然后调用测试任务1。在测试任务1完成
后，再填入测试任务2的入口点，也填入堆栈指针，然后调用测试任务2。依次类推。通用保护故障处理程序作为一个独立的任务出现。在发生通用保护故障后，通用保护故障处理程序在屏幕的左上角显示故障点的选择子和偏移，然后通过调整存放在任务状态段内的任务链接指针的方法，终止引起故障的测试任务。实例的其他实现细节作为习题留给读者思考。

# 10.10 分页管理机制

==80386开始支持存储器分页管理机制==。分页机制是存储器管理机制的第二部分。==段管理机制实现虚拟地址(由段和偏移构成的逻辑地址)到线性地址的转换==，==分页管理机制实现线性地址到物理地址的转换==。==如果不启用分页管理机制，那么线性地址就作为物理地址==。本节介绍80386的存储器分页管理机制和线性地址如何转换为物理地址。

## 10.10.1 存储器分页管理机制

==在保护方式下，控制寄存器`CR0`中的最高位PG位控制分页管理机制是否生效==。==如果`PG=1`，分页机制生效，把线性地址转换为物理地址==。==如果`PG=0`，分页机制无效，线性地址就直接作为物理地址==。请参见图10.1。==必须注意，只有在保护方式下分页机制才可能生效==。==只有在保证使PE位为1的前提下，才能够使PG位为1==，否则将引起通用保护异常。请参见表10.3
==分页机制把线性地址空间和物理地址空间分别划分为大小相同的块==。==这样的块称之为页==。==通过在线性地址空间的页与物理地址空间的页之间建立的映射，分页机制实现线性地址到物理地址的转换==。==线性地址空间的页与物理地址空间的页之间的映射可根据需要而确立，可根据需要而改变==。图10.26反映了线性地址空间的部分页与物理地址空间的部分页之间的映射关系，线性地址空间的任何一页，可以映射为物理地址空间中的任何一页。

![image](https://github.com/YangLuchao/img_host/raw/master/20231128/image.k4ijauzpt74.jpg)==采用分页管理机制实现线性地址到物理地址转换映射的主要目的是便于实现虚拟存储器==。==不像段的大小可变，页的大小是相等并固定的==。根据程序的逻辑划分段，而根据实现虚拟存储的方便划分页：
在80386中，==页的大小固定为4K字节，每一页的边界地址必须是4K的倍数==。因此，==4G大小的地址空间被划分为1M个页，页的开始地址具有`XXXXX000H`的形式==。为此，==我们把页开始地址的高20位`XXXXXH`称为页码==。==线性地址空间页的页码也就是页开始边界线性地址的高20位==；==物理地址空间页的页码也就是页开始边界物理地址的高20位==。可见，==页码左移12位就是页开始地址，所以页码规定了页==。
==由于页的大小固定为4K字节，且页的边界是4K的倍数，所以在把32位线性地址转换成32位物理地址的过程中，低12位地址可以保持不变==。==也就是说，线性地址的低12位就是物理地址的低12位==。==假设分页机制采用的转换映射把线性地址空间的`XXXXXH`页映射到物理地址空间的`YYYYYH`页，那么线性地址`XXXXXXXXH`被转换为`YYYYYxxxH`==。==因此，线性地址到物理地址的转换要解决的是线性地址空间页到物理地址空间页的映射==，==也就是线性地址高20位到物理地址高20位的转换==。

## 10.10.2 线性地址到物理地址的转换

### 1. 映射表结构

==线性地址空间页到物理地址空间页之间的映射用表来描述==。由于4G的地址空间划分为1M个页，因此如果用一张表来描述这种映射，那么该映射表就要有1M个表项，如果每个表项占用4个字节，那么该映射表就要占用4M字节。为避免映射表占用如此巨大的存储器资源，所以80386把页映射表分为两级。
==页映射表的第一级称为页目录表，存储在一个4K字节的物理页中==。==页目录表共有1K个表项，其中，每个表项为4字节长，包含对应第二级表所在物理地址空间页的页码==。

==页映射表的第二级称为页表，每张页表也安排在一个4K字节的页中。每张页表都有1K个表项，每个表项为4字节长，包含对应物理地址空间页的页码==。==由于页目录表和页表均由1K个表项组成，所以使用10位就能指定表项==。
图10.27示出了由页目录表和页表构成的页映射表结构。从图10.27中可见，==控制寄存器CR3指定页目录表==，==页目录表可以指定1K个页表，这些页表可以分散存放在任意的物理页中，而不需要连续存放==；==每张页表可以指定1K个物理地址空间页，这些物理地址空间页可以任意地分散在物理地址空间中==。

![image](https://github.com/YangLuchao/img_host/raw/master/20231128/image.2z1b1zmjq3g0.jpg)

### 2. 表项格式

页目录表和页表中的表项都采用如图10.28所示的格式。从图可见，==最高20位(位12至位31)包含物理地址空间页的页码，也就是物理地址的高20位==。==低12位包含页的属性==。
图10.28所示属性中内容为0的位是Intel公司为80486等处理器留下的保留位，在为80386编程使用到它们时必须设置成0，在位9至位11的`AVL`字段供软件使用，==表项的最低位是存在属性位，记作P==。==P位表示该表项是否有效。`P=1`表项有效；`P=0`表项无效==，表项中其余各位均可供软件使用，80386不解释`P=0`的表项中的任何其他的位。==在通过页目录表和页表进行的线性地址到物理地址的转换过程中，无论在页目录表或页表中遇到无效表项，都会引起页故障==。

![image](https://github.com/YangLuchao/img_host/raw/master/20231128/image.k7dbz0s8axc.jpg)

其他属性位的作用在下一小节中介绍。

### 3. 线性地址到物理地址的转换

==分页管理机制通过上述页目录表和页表实现32位线性地址到32位物理地址的转换==。==控制寄存器CR3的高20位作为页目录表所在目录页的页码==。==首先，把线性地址的最高10位(即位22至位31)作为页目录表的索引，对应表项所包含的页码指定页表==；==然后，再把线性地址的中间10位(即位12至位21)作为已指定页表的索引，对应表项所包含的页码指定物理地址空间中的一页==；==最后，把已指定物理页的页码作为高20位，把线性地址的低12不加改变直接作为低12位，构成32位物理地址==。
图10.29示出了==分页管理机制通过页目录表和页表实现32位线性地址到32位物理地址的转换过程==。设分页管理机制有效，`CR3`的内容是`00200000H`，部分页目录表项和对应的部分页表项如图10.30所示，线性地址`00402567H`被转换成物理地址`00303567H`。

![image](https://github.com/YangLuchao/img_host/raw/master/20231128/image.5t1tfi6pkfk0.jpg)

![image](https://github.com/YangLuchao/img_host/raw/master/20231128/image.15u0uphv7fsw.jpg)

由`CR3`得到页目录表的基地址是`00200000H`，线性地址`00402567H`的高10位是`001H`，作为页目录表中的索引，所以对应表项的物理地址是`00200004H`；从该表项得到页表所在物理页的页码是`00201H`，也即页表所在物理页的基地址是`00201000H`，线性地址的中间10位是`002H`，作为页表中的索引，所以对应表项的物理地址是`00201008H`；从该表项得到物理页的页码是`00303H`；线性地址的低12位是`567H`，直接作为物理地址的低12位，于是得物理地址是`00303567H`。
基于上述假设，线性地址`000F0123H`被转换成物理地址`000B8123H`；线性地址`00000987H`被转换成物理地址`00000987H`，与线性地址相同。

### 4. 不存在的页表

采用如图10.27所示结构的页映射表，存储全部1K张页表需要4M字节，此外还需要4K字节用于存储页目录表。这样的两级页映射表似乎反而要比单一的整张页映射表多占用4K字节。其实不然，事实上不需要在内存存储完整的两级页映射表。两级页映射表结构中对于线性地址空间中不存在的或未使用的部分不必分配页表。除必须给页目录表分配物理页外，仅当在需要时才给页表分配物理页，于是页映射表的大小就对应于实际使用的线性地址空间大小。因为任何一个实际运行的程序使用的线性地址空间，都远小于4G字节，所以用于分配给页表的物理页也远小于4M字节。
页目录表项中的存在位P表明对应页表是否有效。如果`P=1`，表明对应页表有效，可利用它进行地址转换；如果`P=0`，表明对应页表无效。如果试图通过无效的页表进行线性地址到物理地址的转换，那么将引起页故障。因此，页目录表项中的属性位P使得操作系统只要给覆盖实际使用的线性地址范围的页表分配物理页。页目录表项中的属性位P也可用于把页表存储在虚拟存储器中。当发生由于所需页表无效而引起的页故障时，页故障处理程序再申请物理页，从磁盘上把对应的页表读入，把对应页目录表项中的P位置1。换句话说，可以当需要时才为所要的页表分配物理页。这样，页表占用的物理页数量可降到最小。

### 5. 页的共享

从如图10.27所示的页映射表结构可见，==分页机制没有全局页和局部页的规定==。==每一个任务可使用自己的页映射表独立地实现线性地址到物理地址的转换==。==但是，如果使每一个任务所用的页映射表具有部分相同的映射，那么也就可以实现部分页的共享常用的实现页共享的方法是线性地址空间的共享==。==也就是不同任务的部分相同的线性地址空间的映射信息相同，具体表现为部分页表相同或页表内的部分表项的页码相同==。
例如：如果任务A和任务B分别使用的页目录表A和页目录表B内的第0项中的页码相同，也就是页表0相同，那么任务A和任务B的`0000000H`至`003FFFFFH`线性地址空间就映射到相同的物理页。再如，任务A和任务B使用的页表0不同，但这两张页表内第0至第`0FFH`项的页码对应相同，那么任务A和任务B的`0000000H`至`000FFFFFH`线性地址空间就映射到相同的物理页。

## 10.10.3 页级保护和虚拟存储器支持

在如图10.28所示格式的表项中，安排了用于页级保护的属性位和用于支持虚拟存储器的属性位。

### 1. 页级保护

==80386不仅提供段级保护，也提供页级保护==。==分页机制只区分两种特权级。特权级0、1和2统称为系统特权级，特权级3称为用户特权级==。在如图10.28所示页目录表和页表的表项中保护属性位`R/W `和`U/S `就是用于对页的保护。
==表项的位1是读/写属性位，记作`R/W`==。==`R/W `位指示该表项所指定的页是否可读、写或执行==。如`R/W=1`，对表项所指定页可进行读、写或执行；如`R/W=0`，对表项所指定页可读或执行，但不能对该指定页写。但是，`R/W `位对页的写保护只在处理器处于用户特权级时发挥作用；当处理器处于系统特权级时，`R/W `位被忽略，也即总可以读、写或执行。
==表项的位2是用户/系统属性位，记作`U/S `==。==`U/S `位指示该表项所指定的页是否是用户级页==。如`U/S=1`，表项所指定页是用户级页，可由任何特权级下执行的程序访问；如`U/S=0`，表项所指定页是系统级页，只能由在系统特权级下执行的程序访问。

![image](https://github.com/YangLuchao/img_host/raw/master/20231128/image.17ulasr7nnq8.jpg)

表10.11列出了在上述==属性位`R/W`和`U/S`所确定的页级保护下，用户级程序和系统级程序分别具有的对用户级页和系统级页进行操作的权限==。==用户级页可以规定为只允许读/执行或者规定为读/写/执行==。==系统级页对于系统级程序总是可读/写/执行，而对用户程序级程序总是不可访问的==。==与分段机制一样，外层用户级执行的程序只能访问用户级的页，而内层系统级执行的程序，既可访问系统级页，也可访问用户级页==。==与分段机制不同的是，在内层系统级执行的程序，对任何页都有读/写/执行访问权，即使规定为只允许读/执行的用户页，内层系统级程序也对该页有写访问权==。
==页目录表项中的保护属性位`R/W`和`U/S`对由该表项指定页表所指定的全部1K个页起到保护作用==。==所以，对页访问时引用的保护属性位`R/W`和`U/S`的值是组合计算页目录表项和页表项中的保护属性位的值所得==。表10.12列出了组合计算前后的保护属性位值，==组合计算是`与`操作==。例如：假设某页表中的某项的`R/W=1`和`U/S=1`，表示所指定页是可由用户级程序读/写/执行的用户级页。如果指定该页表的页目录项中的`R/W=0`，`U/S=1`，那么用户级程序实际上可对该页的访问被限制为读/执行；如果指定该页表的页目录项中的`R/W=1`，`U/S=0`，那么实际上用户级程序没有对该页的访问权。

![image](https://github.com/YangLuchao/img_host/raw/master/20231128/image.4uxa5nh7sdg0.jpg)

==正如在80386地址转换机制中分页机制在分段机制之后起作用一样，由分页机制支持的页级保护也在由分段机制支持的段级保护之后起作用==。==先测试有关的段级保护，如果启用分页机制，那么在检查通过后，再测试页级保护==。例如，设启用分页机制和当前特权级是3，那么，对于一个存储单元，仅当其所在段及页都允许写入时，该存储单元才是可写的；如果段的类型为读/写，而页规定为只允许读/执行，那么不允许写；如果段的类型为只读/执行，那么不论页保护如何，也不允许写。
==页级保护的检查是在线性地址转换成物理地址的过程中进行的，如果违反页保护属性的规定，对页进行访问(读/写/执行)，那么将引起页异常==。

### 2. 对虚拟存储器的支持

==页表项中的P位是支持采用分页机制虚拟存储器的关键==。==`P=1`，表示表项指定的页存在于物理存储器中，并且表项的高20位是物理页的页码==；==`P=0`，表示该线性地址空间中的页所对应的物理地址空间中的页不在物理存储器中==。如果程序访问不存在的页，会引起页异常，这样操作系统可把该不存在的页从磁盘上读入，把所在物理页的页码填入对应表项和把表项中的P置为1，然后使引起异常的程序恢复运行。
此外，在如图10.28所示表项中的访问位A和写标志位D也用于支持有效地实现虚拟存储器。
==表项的位5是访问属性位，记作A==。在为了访问某存储单元而进行线性地址到物理地址的转换过程中，处理器总要把页目录表内的对应表项和其所指定页表内的对应表项中的A位置1，除非页表或页不存在，或者访问违反保护属性规定。所以，==`A=1`表示已访问过对应的物理页。处理器永不清除A位==。通过周期地检测及清除A位，操作系统就可确定哪些页在最近一段时间未被访问过。当存储器资源紧缺时，这些最近未被访问的页很可能就被选择出来，将它们从内存换出到磁盘上去。
==表项的位6是写标志位，记作D==。在为了访问某存储单元而进行线性地址到物理地址的转换过程中，如果是写访问并且可以写访问，处理器就把页表内对应表项中的D位置1，但并不把页目录表内对应表项中的D置1。当某页从磁盘上读入内存时，页表中对应表项的D位被清0。所以，==`D=1`表示已写过对应的物理页。当某页需要从内存换出到磁盘上去，如果该页的D位为1，那么必须进行写操作==。但是，==如果要写到磁盘上的页的D位为0，那么不需要实际的磁盘写操作，而只要简单地放弃内存中的该页即可==。==因为内存中的页与磁盘中的页具有完全相同的内容==。

## 10.10.4 页异常

==启用分页机制后，线性地址不再直接等于物理地址，线性地址要经过分页机制转换才成为物理地址==。在转换过程中，如果出现下列情况之一就会引起页异常：

1. 涉及的页目录表内的表项或者页表内的表项中的`P=0`,也即涉及的页不在内存；
2. 发现试图违反页保护属性的规定而对页进行访问

报告页异常的中断向量号是14(0EH)。页异常属于故障类异常。在进入故障处理程序时，保存的CS及EIP指向发生故障的指令。一旦引起页故障的原因被排除后，即可从页故障处理程序通过执行一条IRET指令，直接地重新执行产生故障的指令。
当页故障发生时，处理器把引起页故障的线性地址装入控制寄存器`CR2`。页故障处理程序可以利用该线性地址确定对应的页目录项和页表项。
页故障还在堆栈中提供一个出错码，出错码的格式如图10.31所示。页故障的响应处理模式同其他故障一样。

![image](https://github.com/YangLuchao/img_host/raw/master/20231128/image.2wkhqctxpfs0.jpg)

在如图10.31所示的页故障出错码中，==U位表示引起故障程序的特权级，U=1表示用户特权级(特权级3)，U=0表示系统特权级(特权级0、1和2)==；==W位表示访问类型，W=0表示读/执行，W=1表示写==；==P位表示异常类型，P=0表示页不存在故障，P=1表示保护故障==。

## 10.10.5 演示分页机制的实例(实例十)

下面给出一个演示如何启用分页管理机制的实例。该实例的逻辑功能是，在屏幕上显示一条表示已启用分页管理机制的提示信息。该实例演示内容包括：初始化页目录表和部分页表；启用分页管理机制；关闭分页管理机制等。该实例假设系统有4M字节物理内存

### 1.演示步骤和源程序清单

为了简单化，实例只有一个任务，并且没有局部描述符表和中断描述符表，不允许中断，也不考虑发生异常，甚至没有使用堆栈。实例执行步骤如下：

1. 在实方式下为进入保护方式作初始化；
2. 切换到保护方式后进入临时代码段，把部分演示代码传送到预定的内存，然后转演示代码段；

3. 建立页目录表，如图10.30所示；

4. 建立页表，如图10.30所示；

5. 启用分页管理机制；

6. 演示在分页管理机制启用后的程序执行和数据存取；

7. 关闭分页管理机制；

8. 退出保护方式，结束


实例十源程序清单如下：

```assembly
;程序名：T10-10.ASM
;功能：演示使用分页管理机制
;
	INCLUDE 386SCD.ASM
PL 		=	1			;存在属性位P值
RWR 	= 	0			;`R/W `属性位值，读/执行
RWW		=	2			;`R/W `属性值，读/写/执行
USU		=	0			;`U/S `属性值，系统级
USS		=	4			;`U/S `属性值，用户级
PDT_AD	=	200000H		;页目录表所在物理页的地址
PT0_AD	=	202000H		;页表0所在物理页的地址
PT1_AD	=	201000H		;页表1所在物理页的地址
;
PhVB_AD	=	0B8000H		;物理视频缓冲区地址
LoVB_AD	=	0F0000H		;程序使用的逻辑视频缓冲区地址
MPVB_AD	=	301000H		;线性地址0B8000H所映射的物理地址
PhSC_AD	=	303000H		;部分演示代码所在内存的物理地址
LoSC_AD =	402000H		;部分演示代码的逻辑地址
	.386P
;全局描述符表GDT
GDTSEG 	SEGMENT 	PARA 	USE16
	GDT 	LABEL 	BYTE
	DUMMY 		DESCRIPTOR		<>
	NORMAL 		DESCRIPTOR		<0FFFFH,0,0,ATDW,0>
	Normal_SEL	=			NORMAL - GDT
;页目录表所在段描述符(在保护方式下初始化时用)
	PDTable 	DESCRIPTOR		<0FFFH,PDT_AD AND 0FFFFH,PDT_AD SHR 16,ATDW,0>
	PDT_SEL		=	PDTable - GDT
;页表0所在段描述符(在保护方式下初始化时用)
	PTableo 	DESCRIPTOR 		<0FFFH,PTO_AD AND 0FFFFH ,PT0_AD SHR 16,ATDW,0>
	PTO_SEL		=	PTable0 - GDT
;页表1所在段描述符(在保护方式下初始化时用)
	PTable1 	DESCRIPTOR 		<0FFFH,PT1_AD AND 0FFFFH,PT1_AD SHR 16,ATDW,0>
	PT1_SEL		=	PTable1 - GDT
;逻辑上的显示缓冲区所在段描述符
	LOVIDEOB 	DESCRIPTOR 		<3999,LoVB_AD AND OFFFFH,LoVB_AD SHR 16,ATDW,0>
	LoVideoB_SEL=	LOVIDEOB - GDT
;逻辑上的部分演示代码所在段描述符
	LOCODE 		DESCRIPTOR 		<SCodeLEN-1,LoSC_AD AND 0FFFFH,LoSC_AD SHR 16,ATCE,0>
	LoCode_SEL 	= 	LOCODE - GDT
;预定内存区域(用于部分演示代码)所在段的描述符
	TPSCODE 	DESCRIPTOR 		<SCodeLEN-1,PhSC_AD AND 0FFFFH,PhSC_AD SHR 16,ATDW,>
	TPSCode_SEL = 	TPSCODE - GDT
	EFFGDT 	LABEL 	BYTE ;以下是需要额外初始化的描述符
;临时代码段描述符
	TEMPCODE 	DESCRIPTOR 		<0FFFFH,TempCodeSEG,,ATCE,>
	TempCode_SEL =	TEMPCODE - GDT
;演示任务代码段描述符
	DEMOCODE 	DESCRIPTOR 		<DemoCodeLEN-1,DemoCodeSEG,,ATCE,>
	DemoCode_SEL =	DEMOCODE - GDT
;演示任务数据段描述符
	DEMODATA 	DESCRIPTOR 		<DemoDataLEN-1,DemoDataSEG,,ATDW,>
	DemoData_SEL = 	DEMODATA - GDT
;在初始化时要移动的代码段描述符(移动时作为数据对待)
	SCODE 		DESCRIPTOR <SCodeLEN-1,SCodeSEG,,ATDR,>
	SCode_SEL	=	SCODE - GDT
	GDNUM 		= 	($ - EFFGDT)/(SIZE DESCRIPTOR)
	GDTLEN		=	$ - GDT
GDTSEG 		ENDS
;这部分代码在初始化时被复制到预定内存区域
;其功能是在屏幕上显示提示信息
SCodeSEG 	SEGMENT 	PARA 	USE16
	ASSUME 	CS:SCodeSEG,DS:DemoDataSEG
SBegin:
	MOV 	AX,LoVideoB_SEL
	MOV 	ES,AX
	MOV		DI,0
	MOV 	AH,17H
	MOV 	CX,MESSLEN
S1:
	LODSB					;显示信息
	STO		SW
	LOOP 	S1
	JUMP16 	DemoCode_SEL,Demo3
    MLEN 	= $ - SBegin
	SCodeLEN = $
SCodeSEG 	ENDS
;演示任务数据段
DemoDataSEG 	SEGMENT 	PARA 	USE16
	MESS		DB 	' Page is ok ! '
	MESSLEN		=	$ - MESS
	DemoDataLEN = 	$
DemoDHtaSEG ENDS
;演示任务代码段
DemoCodeSEG 	SEGMENT 	PARA 	USE16
	ASSUME 	CS:DemoCodeSEG
DemoBegin:
	MOV 	AX,PDT_SEL			;初始化页目录表
	MOV 	ES,AX
	XOR 	DI.DI
	MOV 	CX,1024
	XOR 	EAX,EAX				;先把全部表项置成无效
	REP 	STOSD				;再置表项0和表项I
	MOV 	DWORD PTR ES:[0],PT0_AD OR (USU + RWW + PL)
	MOV 	DWORD PTR ES:[4],PT1_AD OR (USU + RWW + PL)
	MOV 	AX,PTO_SEL
;初始化页表0
	MOV 	ES,AX
	XOR 	DI,DI
	MOV 	CX,1024
	XOR 	EAX,EAX
	OR		EAX,USU+RWW+PL
Demol: 
	STOSD
	ADD 	EAX,1000H		;先全部置成直接对应等地址的物理页
	LOOP	Demol			;再特别设置两个表项
	MOV 	DI,(PhVB_AD SHR 12)*4
	MOV 	DWORD PTR ES:[DI],MPV_AD+USS+RWW+PL
	MOV		DI,(LoVB_ADSHR12)*4
	MOV 	DWORD PTR ES:[DI],PhVB_AD+USU+RWR+PL
	MOV 	AX,PT1_SEL		;初始化页表1.
	MOV 	ES,AX
	XOR		DI,DI
	MOV 	CX,1024
	MOV 	EAX,400000H
Demo2:
	STOSD					;先把全部表项置成无效
	ADD 	EAX,1000H
	LOOP 	Demo2			;再特别设置一项
	MOV 	DI,((LoSC_AD SHR 12) AND 3FFH)*4
    MOV 	DWORD PTR ES [DI],PhSC_AD+USU+RWR+PL
;
	MOV 	EAX,PDT_AD
	MOV 	CR3,EAX
	MOV 	EAX,CR0
	OR 		EAX,80000000H
	MOV 	CR0,EAX
;启用分页机制
	JMP 	SHORT PageE
PageE:
	MOV 	AX,DemoData_SEI
	MOV 	DS,AX
	MOV 	SI,OFFSET MESS
	JUMP16 	LoCode_SEL,Sbegin
;转位于较大线性地址处的代码执行
Demo3:
	MOV 	EAX,CR0
	AND 	EAX,7FFFFFFFH
;关闭分页机制
	MOV 	CR0,EAX
	JMP		SHORT PageD
PageD:
	MOV 	AX,Normal_SEL
	JUMP16 	TempCode.SEL,ToDOS
	DemoCodeLEN = $
DemoCodeSEG ENDS
;临时代码段
TempCodeSEG 	SEGMENT 	PARA 	USE16
	ASSUME 	CS:TempCodeSEG
Virtual:
	CLD
;为演示在启用分页机制后执行位于
	MOV 	AX,SCode_SEL
;较高线性地址空间中的代码作准备
	MOV 	DS,AX
	MOV 	AX,TPSCode_SEL
	MOV 	ES,AX
	MOV 	SI,OFFSET SBegin
	MOV 	DI,SI
	MOV 	CX,MLEN
;把部分演示代码复制到预定的内存
	REP 	MOVSB
	JUMP16 	DemoCode_SEL,DemoBegin
;
ToDOS:
	MOV 	DS,AX
;准备返回实方式
	MOV 	ES,AX
	MOV 	EAX,CR0
	AND 	EAX,0FFFFFFFEH
    MOV 	CR0,EAX
;返回实方式
	JUMP16 	<SEG Real> ,<OFFSET Real>
TempCodeSEG ENDS
;实方式下的初始化代码和数据
RCodeSEG	SEGMENT 	PARA 	USE16
	ASSUME 	CS:RCodeSEG,DS:RCodeSEG
	VGDTR	PDESC	<GDTLEN-1,>
Start:
	PUSHCS
	POPDS
	CLD
	CALL 	INIT_GDT
;初始化全局描述符表GDT
	CALL 	EA20
;打开地址线A20
	LGDT 	QWORD PTR VGDTR
	CLI
	MOV 	EAX,CR0
	OR 		EAX,1
	MOV 	CRO,EAX
;转保护方式
	JUMP16	<TempCode_SEL>,<OFFSET Virtual>
Real:
;回到实方式
	CALL	DA20
;关闭地址线A20
	STI
	MOV 	AX,4C00H
;返回DOS
	INT		21H
;实方式下的初始化过程
INIT_GDT 	PROC 	NEAR
;同实例四中的过程内容
INIT_GDT 	ENDP
EA20 	PROC
;同实例一
EA20 	ENDP
DA20 	PROC
;同实例一
DA20 	ENDP
RCodeSEG	ENDS
	END Start
```

### 2.关于实例十的说明

上述演示程序的许多内容与其他实例相同，下面仅就演示分页管理机制方面的内容作些说明：

#### (1)部分演示代码的移动

为了充分说明分页机制所实现的线性地址到物理地址的转换，在初始化时把部分演示代码移动到预定的内存区域。预定的内存区域从00303000H开始，也即是页码为00303H的物理页。该部分演示代码的功能是显示指定的字符串。在进入保护方式后做这初始化工作的原因是预定的内存区域在扩展内存中，注意初始化时还没有启用分页机制。

#### (2)页映射表的初始化

实例按如图10.30所示安排映射表。页目录表安排在页码为00200H的物理页中，页表0安排在页码为00202H的物理页中，页表1安排在页码为00201H的物理页中。演示程序涉及的线性地址空间不超出007FFFFFH,所以只使用两张页表，为此页目录表中的
其他项被置为无效(P=0)。页表0把线性地址空间中的0000000H~003FFFFFH映射到物理地址空间中。实例在初始化页表0时，使该线性地址空间直接映射到相同地址的物理地址空间，除线性地址空间中页码为000B8H和000F0H这两页以外。000B8H页被映射到页码为00301H的物理页，而000F0H页被映射到页码为000B8H的物理页。
页表1把线性地址空间中的00400000H~007FFFFFH映射到物理地址空间中。实例在初始化页表1时，似乎使该线性地址空间直接映射到相同地址的物理地址空间，但是除了对应线性地址空间中00402H页的表项被另外设置外，其他表项中的P位为0,也即表示对应物理页不存在。初始化后，页表1的第2项把线性地址空间中的00402H页，映射到页码为00303H的物理页，也就是存放部分演示代码的指定内存区域。

#### (3)启用分页管理机制

在建立好页映射表后，启用分页机制所要做的操作是简单的，只要把控制寄存器中的最高位，也就是PG位置1。具体指令如下：

```assembly
	MOV 	EAX,CR0
	OR		EAX,80000000H
	MOV 	CRO,EAX
	JMP 	SHORT PageE
PageE:
```

在启用分页机制前，线性地址就是物理地址；在启用分页机制后，线性地址要通过分页机制的转换，才成为物理地址。尽管使用一条转移指令，可清除预取的指令，但随后在取指令时使用的线性地址就要经过转换才成为物理地址。为了保证顺利过渡，在启用分页机
制之后的过渡阶段，仍要维持线性地址等同于物理地址。为了做到这一点，在建立页映射表时，必须使实现过渡的代码所在的线性地址空间页映射到具有相同地址的物理地址空间页。实例中页表0就做到了这一点。

#### (4)关闭分页管理机制

只要把控制寄存器CR0中的PG位清0,便关闭分页机制。在这一过渡阶段，也要保持地址转换前后的一致。

#### (5)地址转换的演示

在启用分页机制之后，就转移到位于线性地址空间中00402000H处开始的代码，该部分代码的功能是显示提示信息“Page is ok!”。实际上这部分代码存放在从物理地址00303000H开始的内存区域中，是在初始化时被移到此区域的。在显示提示信息时，把要显示的字符ASCII和显示属性填到线性地址空间中000F0000H开始的区域中，而不是000B8000H开始的区域。从在初始化时建立的映射表可见，线性地址空间中的000F0H页，被映射到物理地址空间中的000B8H页。所以，向线性地址空间中的000F0H页写，实际上是向物理地址空间中的000B8H页写，也就是真正显示。

#### (6)页级保护的演示

在进入保护方式之后，特权级一直是0级。所以，无论系统级和用户级页，无论只能读/执行，还是读/执行/写，总是可进行各种形式的访问。

# 10.11 虚拟8086方式

继推出80386之后，Inte]又推出了80486、Pentium和PentiumPRO。这些处理器都具有实方式和保护方式两种工作模式。前面已介绍过，实方式与8086方式兼容，可以运行DOS及以其为平台的几乎所有软件；但在实方式下，处理器不能发挥自身的优越性能，不能支持多用户、多任务操作系统的运行。为了充分发挥处理器的功能，同时使DOS及以其为平台的软件继续有效地运行，从80386开始增加了虚拟8086方式。本节介绍虚拟8086方式。

## 10.11.1 V86方式

### 1. V86方式

虚拟8086方式是保护方式下的一种工作方式，也称为V8086方式，或者简称为V86方式。在虚拟8086方式下，处理器类似于8086。寻址的地址空间是1M字节；段寄存器的内容作为段值解释；20位存储单元地址由段值乘16加偏移构成。所以，在虚拟8086方式下，可以运行DOS及以其为平台的软件。但V86方式毕竟是虚拟8086的一种方式，所以不完全等同于8086。
当如图9.2所示的标志寄存器中的标志VM为1时，处理器就处于V86方式。当处理器处于V86方式时，其当前特权级必定是3。

### 2. V86任务

8086程序可直接在V86方式下运行，而V86方式受到称为V86监控程序的控制。V86监控程序和在V86方式下的8086程序构成的任务称为虚拟8086任务，或者简称为V86任务。V86任务形成一个由处理器硬件和属于系统软件的监控程序组成的`虚拟8086机`。V86监控程序控制V86外部界面、中断和`I/O`。硬件提供该任务最低端1M字节线性地址空间的虚拟存储空间，包含虚拟寄存器的TSS，并执行处理这些寄存器和地址空间的指令。
80386把V86任务作为与其他任务具有同等地位的一个任务。它可以支持多个V86任务，每个V86任务是相对独立的。所以，通过V86方式这种形式，运行8086程序可充分发挥处理器的能力和充分利用系统资源。

## 10.11.2 进入和离开V86方式

保护方式和V86方式之间的切换情形如图10.32所示。图中左面部分为V86任务。从图10.32可见，V86方式与保护方式的切换可发生在V86任务之内，这种切换是V86方式下的8086程序与保护方式下的监控程序之间的转换；V86方式与保护方式的切换可发生在任务之间，这种切换是V86任务与其他任务的切换。此外，V86监控程序与其他任务之间的切换是普通的任务切换。

![image](https://github.com/YangLuchao/img_host/raw/master/20231128/image.2qihr98slpe0.png)

由于80386没有提供直接改变VM标志的指令，并且只有当前特权级`CPL=0`时，对VM的改变才有效，所以V86方式与保护方式的切换不能简单地通过设置或改变VM而进行。下面介绍V86方式与保护方式之间的切换，也就是如何进入和离开V86方式。为了方便，先介绍如何离开V86方式。

### 1. 离开V86方式

在V86方式下，如果处理器响应中断/异常，那么就会退出当前V86任务的V86方在V86方式下，处理器对中断/异常的响应处理不同于真正的8086,而仍然采用保护方式下对中断/异常响应处理的方法。所以，在V86方式下，不是根据位于线性地址空间最低端的中断向量表内的对应中断向量转入处理程序，而是根据中断描述符表IDT内的对应门描述符的指示转入处理程序。

#### (1) 在V86任务内离开V86方式

如果对应的门描述符是386中断门或386陷阱门，那么就发生在当前V86任务内从V86方式到保护方式的转换。80386要求执行这种中断/异常处理程序时的CPL必须等于0。
由于V86方式下的CPL=3,而转换到保护方式后的CPL=0,所以这种转换包含了特权级的变换。在按10.7节介绍的方法转入处理程序之前，处理器先将V86方式下的段寄存器GS、FS、DS及ES压入0级堆栈，并装入空选择子。为保持使堆栈对齐，在把段寄存器压入堆栈时，一律按32位值压入，低16位是段寄存器的值，高16位为空。于是，转换后的0级堆栈如图10.33所示。其中，段寄存器SS和CS的值也是V86方式下的段值。图(a)是没有出错码的情形；图(b)是有出错码的情形。请与图10.21作比较。
在这种V86任务内从V86方式转换到保护方式的过程中，为了保证中断/异常处理程序工作于特权级0,对目标代码段描述符特权级进行检查，如果由目标代码段描述符特权级决定的CPL不等于0,将引起通用保护异常。此外，标志寄存器EFLAGS中的VM位被清0,从而使得中断/异常处理在保护方式下进行，也即离开V86方式。

![image](https://github.com/YangLuchao/img_host/raw/master/20231128/image.51k5lxmecyg0.jpg)

这种情况下，相应的中断/异常处理在当前V86任务之内进行。中断/异常处理程序可以检查保存在堆栈中的EFLAGS映象，根据VM位的值来确定被中断程序的工作方式。如果VM=1,那么被中断的程序工作于V86方式，是8086程序；否则，被中断的程序工作于保护方式，是V86监控程序

#### (2) 任务切换离开V86方式

如果对应的门描述符是任务门，那么就发生从当前V86任务到其他任务的切换，也就离开当前V86任务的V86方式。象普通任务切换一样，V86方式的各通用寄存器、段寄存器、指令指针和标志寄存器EFLAGS等保存到原V86任务的386TSS中。被保存的段寄存器的内容是V86方式下的段值。被保存的EFLAGS内的VM=1。这种情况下，相应的中断/异常处理在另一个任务内进行。目标任务可以是普通任务，也可以是另一个V86任务。如果目标任务TSS内的EFLAGS字段内的VM=1,那么就转入另一个V86任务的V86方式。

### 2.进入V86方式

与离开V86方式的两条途径相对应，有两条进入V86方式的途径。

#### (1) 通过IRET指令进入V86方式

通常在中断/异常处理结束时使用IRET指令返回被中断的程序继续执行。指令IRET的执行流程如图10.34所示，尽管它不够细致和没包括异常情况，但还是体现了指令IRET执行时所处理的三种情形。第一种情形是当前EFLAGS中的NT=1,也即嵌套任务返回，那么就进行任务切换，指向目标任务TSS的选择子在当前任务TSS的链接字段。NT=0表示当前中断/异常处理程序与被中断程序属于同一任务，于是就从堆栈弹出EIP、CS和EFLAGS。第二和第三种情形是在NT=0的条件下产生。第二种情形是弹出的EFLAGS中VM=0,表示被中断的程序是普通保护方式程序，那么就考虑特权级变换，如果向外层返回，那么就恢复外层堆栈指针，不允许向内层返回。在10.7.3中介绍的指令IRET的动作只考虑情形一和情形二，并不是指令IRET的完整动作。

![image](https://github.com/YangLuchao/img_host/raw/master/20231128/image.3y2j65a3j6o0.jpg)

第三种情形是弹出的EFLAGS中VM=1且CPL=0,表示被中断的程序是V86方式下的8086程序，当前是从同一V86任务下的中断/异常处理程序返回。由于V86方式的特权级是3,所以要进行堆栈切换，也即从堆栈中弹出3级堆栈的指针(ESP和SS)。此外，还从堆栈中弹出段寄存器ES、DS、FS和GS。在这种情形下，弹到各段寄存器(包括CS和SS)的内容都作为段值，而非选择子。这种处理动作对应于上述第一种离开V86方式的情形，有关堆栈操作也与图10.33所示的堆栈内容相符。当然，如果产生异常时提供出错码，那么异常处理程序在利用IRET指令返回时，必须确保堆栈指针指向图10.33所示保存EIP的单元。简单的实现方法是，异常处理程序在执行IRET前，先从堆栈弹出出错码。
利用指令IRET处理的这第三种情形，可以方便地从V86任务下的中断/异常处理程序返回到V86方式下的8086程序。利用这条途径还可以直接进入V86方式。为此，先在0级堆栈中形成如图10.33(a)所示的栈顶。对应EIP值是V86方式下要执行的8086程序入口点的16位偏移；对应CS值是V86方式下要执行的8086程序入口点的段值，对应EFLAGS值中的VM位必须是1;对应SS和ESP的值是要执行的8086程序的堆栈
指针；对应ES、DS、FS和GS的值是相应的段值。然后，在CPL=0和NT=0的情况下，执行IRET指令。实际上，这种进入V86方式的途径是，先建立一个V86方式下执行的8086程序被中断而离开V86方式的环境，然后再返回。

#### (2) 通过任务切换进入V86方式

通过任务切换的途径，可以从其他任务进入V86任务内的V86方式。利用在前面几节介绍的任务切换方法可以进行任务切换。如果目标任务由386TSS描述，并且其中EFLAGS字段内的VM位为1,那么在切换到目标任务时，也就进入V86方式。在切换到V86方式时，CPL被规定为3。目标任务TSS中的各段寄存器字段被解释为8086可以接受的段值，而不是选择子。任务切换时也将装载LDTR和CR3。

如果利用这条途径建立V86任务并进入V86方式，那么主要是把对应386TSS中EFLAGS字段内的VM位置1,把8086程序的有关段值填入对应386TSS中的相应段寄存器字段。此外，如果V86监控程序需要用到LDT,那么还要填LDTR字段；如果需要采用分页机制，那么还要填CR3字段。

## 10.11.3 演示进人和离开V86方式的实例(实例十一)

下面给出一个用于演示进入和离开V86方式的实例。该实例的逻辑功能是，以驻留方式结束程序，退出时已处于V86方式。该实例演示内容包括：两种方式进入V86方式和两种方式离开V86方式；V86方式下的8086程序如何调用实方式下的软中断处理程序

### 1.演示步骤和源程序清单

为了便于演示，本实例含有三个任务：临时任务、V86任务和INTFF任务。在实方式下作必要的初始化工作后切换到保护方式，也即进入临时任务，开始演示。演示分两个阶段：第一阶段进入V86任务的V86方式，并驻留退出；第二阶段进入INTFF任务，切换到临时任务，并返回实方式。
第一阶段的演示步骤如下：

1. 开始临时任务后，作切换到V86任务的准备；

2. 切换到V86任务，由于V86任务TSS中的EFLAGS字段内的VM=1，所以伴随着任务切换，就进入V86方式；

3. 进入V86任务的V86方式后，显示提示信息，驻留结束，出现DOS提示符，第一阶段至此结束。

在V86方式下，可进行各种操作，运行其他8086程序。如果8086程序引起通用保护异常，那么在屏幕第一行显示提示信息，并中止该8086程序。如果在8086程序中执行"INT FF"指令，开始第二阶段。
第二阶段的演示步骤如下：

1. 进入INTFF任务后，显示提示信息，切换到临时任务；

2. 在临时任务内切换回到实方式；

3. 在实方式下，中止发出`INTFF`的程序


源程序有如下几部分组成：

1. 全局描述符表GDT;

2. 中断描述符表IDT(只适用于V86任务);

3. INTFF任务的TSS段、LDT段、0级堆栈段和代码段；

4. V86任务的TSS段、LDT段、0级堆栈段、3级堆栈段及数据段，通用保护异常处理程序段和其他中断/异常处理程序段，V86方式下的8086程序段；

5. 临时任务的TSS段和代码段；

6. 实方式下的初始化代码段及有关过程。

源程序清单如下：

```assembly
;程序名：T10-11.ASM
;功能：演示进入和离开V86方式
	INCLUDE	386SCD.ASM
	.386P
;全局描述符表GDT
GDTSEG 	SEGMENT 	PARA 	USE16
	GDT		LABEL 	BYTE
	DUMMY 		DESCRIPTOR 			<>
	NORMAL		DESCRIPTOR			<0FFFFH,0,0,ATDW,0>
	Normal_SEL 		= 		NORMAL - GDT
	EFFGDT LABEL BYTE ;以下是需要额外初始化的全局描述符
;V86任务TSS段描述符
	V86TSS 		DESCRIPTOR 			<V86TSSLEN-1,V86TSSSEG,,AT386TSS,>
	V86TSS_SEL 		= 		V86TSS - GDT
;V86任务局部描述符表的描述符
	V86LDT 		DESCRIPTOR 			<V86LDTLEN-1,V86LDTSEG,,ATLDT,>
	V86LDT_SEL		= 		V86LDT - GDT
;INTFF任务TSS段描述符
	INTFFTSS 	DESCRIPTOR 			<INTFFTSSLEN-1,INTFFTSSSEG,,AT386TSS,>
	INTFFTSS_SEL	=		INTFFTSS - GDT
;INTFF任务局部描述符表的描述符
	INTFFLDT 	DESCRIPTOR 			<INTFFLDTLEN-1,INTFFLDTSEG,,ATLDT,>
	INTFFLDT_SEL	=		INTFFLDT - GDT
;临时任务TSS段描述符
	TEMPTSS 	DESCRIPTOR 			<TempTSSLEN-1,TempTSSSEG,,AT386TSS,>
	TempTSS_SEL		=		TEMPTSS - GDT
;临时任务代码段描述符
    TEMPCODE 	DESCRIPTOR 			<OFFFFH,TempCodeSEG,,ATCE,>
	TempCode_SEL	=		TEMPCODE - GDT
;显示缓冲区描述符
	VIDEOBUFF 	DESCRIPTOR 			<80*25*2-1,0B800H,,ATDW,>
	VideoBuff_SEL 	= 		VIDEOBUFF - GDT
	GDNUM			=		($ - EFFGDT)/(SIZE DESCRIPTOR)
	GDTLEN 			= 		$ - GDT
GDTSEG 		ENDS
;V86任务使用的中断描述符表IDT
IDTSEG 	SEGMENT 	PARA 	USE16
	IDT 	LABEL 	BYTE
;对应0~12号中断/异常的中断门描述符
	REPT	13	
		GATE 	<?,TPCode_SEL.0,AT386IGAT+DPL3.0>
	ENDM
;对应一般保护异常的陷阱门描述符
	GATE 		<GPBegin,GPCode_SEL,0,AT386TGAT+DPL3,0>
;对应15-254号中断/异常的中断门描述符
	REPT	256 - 1 - 14
		GATE	 <?,TPCode-SEL,0.AT386IGAT+DPL3,0>
	ENDM
;对应255(0FFH)号中断的任务门描述符
	GATE		<?,INTFF.TSS_SEL,0,ATTASKGAT+DPL3.?>
	IDTLEN 	= $ - IDT
IDTSEG 		ENDS
;INTFF任务的TSS段
INTFFTSSSEG 	SEGMENT 	PARA 	USE16
	DD 		0			;链接字
	DD 		?			;0级堆栈指针
	DW 		?,?
	DD 		?			;1级堆栈指针
	DW 		?,?			;特权级不会变换，无需初始化
	DD 		?			;2级堆栈指针
	DW 		?,?
	DD		0			;CR3
	DW 		INTFFBegin,0;EIP
	DW 		0,0			;EFLAGS
	DD		0			;EAX
	DD 		0			;ECX
	DD 		0			;EDX
	DD		0			;EBX
	DW 		INTFFStackOLEN,0 	;ESP
	DD 		0			;EBP
	DD		0			;ESI
	DD		0			;EDI
	DW 		Normal_SEL,0;ES(段寄存器已初始化妥)
	DW 		INTFFCode SEL,0 	;CS
	DW 		INTFFStack0_SEL,0	;SS
	DW 		Normal_SEL,0		;DS
	DW 		Normal_SEL,0		;FS
	DW 		Normal_SEL,0		;GS
	DW 		INTFFLDT_SEL,0 		;LDT
	DW 		0
	DW		$ + 2				;指向`I/O`许可位图区的指针
	DB 		OFFH				;`I/O`许可位图结束字节
	INTFFTSSLEN	=	$
INTFFTSSSEG ENDS
;
;INTFF社务的LDT段
INTFFLDTSEG 	SEGMENT 	PARA 	USE16
	FLDT 	LABEL 	BYTE
;0级堆钱段描述符
	INTFFSTACK0 	DESCRIPTOR 		<INTFFStack0LEN-1,INTFFStack0SEG,,ATDWA,>
	INTFFStack0_SEL			=		(INTFFSTACK0 - FLDT) + TIL
;代码段描述符
	INTFFCODE		DESCRIPTOR 		<INTFFCodeLEN-1,INTFFCodeSEG,,,ATCER,>
	INTFFCode_SEL			=		(INTFFCODE - FLDT) + TIL
	INTFFLDNUM				=		($ - FLDT)/(SIZE DESCRIPTOR)
	INTFFLDTLEN 			= 		$			;LDT段长度
INTFFLDTSEGENDS
;------------------
;INTFF任务的0级堆栈
INTFFStack0SEG 	SEGMENT 	PARA 	USE16
	INTFFStack0LEN			=		512
									DB INTFFStack0LEN DUP (0)
INTFFStack0SEG	ENDS
;INTFF任务的代码段
INTFFCodeSEG 	SEGMENT 	PARA 	USE16
	ASSUME 		CS:INTFFCodeSEG
	INTFFMESS	DB 'Return to real mode.'
	INTFFMESSLEN	=	$ - INTFFMESS
INTFFBegin:
	MOV 	SI,OFFSET GPERRMESS
	MOV 	AX,VideoBuff.sel
	MOV 	ES,AX			;置显示缓冲区选择子
	MOV 	DI,0			;从屏幕左上角开始显示
	MOV		AH,17H			;置显示属性
	MOV 	CX,INTFFMESSLEN	;置提示信息长度
	CLD
INEXT: 
	MOV 	AL,CS:[SI]		;从代码段取显示信息
	INC 	SI
	STOSW					;显示返回实方式的提示信息
	LOOP 	INEXT
	JUMP16 	TempTSS_SEL,0	;切换到临时任务
	INTFFCodeLEN = $
INTFFCodeSEG 	ENDS
;V86任务的TSS段
V86TSSSEG 	SEGMENT 	PARA 	USE16
	DD		0					;链接字
	DD 		V86Stack0LEN		;0级堆栈指针
	DW 		V86Stack0_SEL,?
	DD 		?					;1级堆栈指针
	DW 		?,?
	DD 		?					;2级堆栈指针
	DW 		?,?
	DD 		0					;CR3
	DW 		V86Begin,0			;EIP
	DW 		IOPL3,VMFL			;EFLAGS(IO特权级为3,VM=1)
	DD 		0					;EAX
	DD 		0					;ECX
	DD 		0					;EDX
	DD		0					;EBX
	DW 		V86Stack3LEN,0		;ESP
	DD		0					;EBP
	DD 		0					;ESI
	DD		0					;EDI
	DW 		V86CodeSEG,0		;ES(V86方式下的段值)
	DW 		V86CodeSEG,0		;CS
	DW 		V86Stack3SEG,0		;SS
	DW 		V86CodeSEG,0		;DS
	DW 		V86CodeSEG,0
	DW 		V86CodeSEG,0		;GS
	DW 		V86LDT_SEL.0		;V86任务的局部描述符表选择子
	DW 		0
	DW		$ + 2				;指向`I/O`许可位图区的指针
	DB 		4000H/8 DUP (0)		;`I/O`许可位图
	DB 		0FFH				;`I/O`许可位图结束字节
	V86TSSLEN = $
V86TSSSEG 	ENDS
;V86任务的LDT段
V86LDTSEG 	SEGMENT 	PARA 	USE16
	VLDT 	LABEL 	BYTE
;V86任务线性地址空间中最低端1M字节段的描述符
	VALLMEM 		DESCRIPTOR 			<0FFFFH,0,,8F00H+ATDWA,>
	VAIIMEM_SEL 	= 		(VALLMEM - VLDT) + TIL
;V86任务0级堆找段描述符
	V86STACK0 		DESCRIPTOR 			<V86StackOLEN-1,V86StackOSEG,,ATDWA,>
	V86Stack0_SEL	=		(V86STACK0 - VLDT) + TIL
;V86任务数据段描述符
	V86DATA 		DESCRIPTOR 			<V86DataLEN-1,V86DataSEG,,ATDR,>
	V86Data_SEL 	= 		(V86DATA - VLDT) + TIL
;V86任务中断/异常处理程序代码段描述符
	TPCODE 			DESCRIPTOR 			<TPCodeLEN-1,TPCodeSEG,,ATCE,>
	TPCode_SEL 		= 		(TPCODE - VLDT) + TIL
;V86任务通用保护异常处理程序代码段描述符
	GPCODE 			DESCRIPTOR 			<GPCodeLEN-1,GPCodeSEG,,ATCE,>
	GPCode_SEL		=		(GPCODE - VLDT) + TIL
	V86LDNUM 		= 		($ - VLDT)/(SIZE DESCRIPTOR)
	V861DTLEN 		= 		$
V86LDTSEG 		ENDS
;V86任务的0级堆栈
V86StackOSEG 	SEGMENT 	PARA 	USE16
	V86StackOLEN 	= 	512
					DB 	V86StackOLEN DUP (0)
V86StackOSEG ENDS
;V86任务的3级堆栈
V86Stack3SEG 	SEGMENT 	PARA 	USE16
	V86Stack3LEN	=	1024
					DB V86Stack3LEN DUP(0)
V86Stack3SEG ENDS
;V86数据段
VB6DataSEG 		SEGMENT 	PARA 	USE16
	GPERRMESS 	DB '......General Protection Error.....'
	GPERRMESSLEN	=	$	-	GPERRMESS
	V86DatalEN		=	$
V86DataSEGENDS
;定义部分代表堆栈单元的符号(参见图10.33)
Perr 	EQU WORD PTR [BP+0]
Pip 	EQU WORD PTR [BP+4]
Pcs 	EQU WORD PTR [BP+8]
Pflag 	EQU WORD PTR [BP+12]
Psp 	EQU WORD PTR [BP+16]
Pss 	EQU WORD PTR [BP+20]
Pes 	EQU WORD PTR [BP+24]
Pds 	EQU WORD PTR [BP+28]
Pfs 	EQU WORD PTR [BP+32]
Pgs 	EQU WORD PTR [BP+36]
;V86任务下的中断/异常处理程序代码段
TPCodeSEG 	SEGMENT 	PARA 	USE16
	ASSUME 	CS:TPCodeSEG
TPBegin:
	COUNT	=	0
	REPT 	256			;对应256个入口
		IF 	COUNT 	EQ 		21H
			ENT21H 	LABEL 	BYTE	;在第21H项处定义标号ENT21H
		ENDIF
		PUSH 	BP
		MOV 	BP,COUNT	;置中断向量号到BP
		JMP		PROCESS		;都转统一的处理程序
		COUNT 	= COUNT + 1
	ENDM
PROCESS:
	PUSH 	BP			;保存BP
	MOV 	BP,SP		;堆栈指针送BP
	PUSH 	EAX
	PUSH	EBX			;保存EAX,EBX
;1在V86堆栈顶形成返回点的现场
	MOV 	AX,VAIIMEM_SEL	;装载描述最低1M字节线性地址空间
	MOV 	DS,AX			;的描述符选择子
	XOR 	EAX,EAX
	MOV 	AX,Psp			;修改在V86任务0级堆栈中保存的
	SUB 	AX,3*2			;3级堆栈指针，减3个字
	MOV 	Psp,AX			;即在V86方式下的堆栈顶空出3个字
	XOR 	EBX,EBX
	MOV 	BX,Pss			;使EBX指向V86堆栈顶
	SHL 	EBX,4
	ADD 	EBX,EAX
	MOV 	AX,Pip			;把保存在0级堆栈中的返回地址的
	MOV		[EBX],AX		;偏移部分送V86堆栈
	MOV 	AX,Pcs
	MOV 	[EBX+2],AX		;段值部分送V86堆栈
	MOV 	[AX],Pflag
	MOV 	[EBX+4],AX		;标志值送V86堆找
;②用对应的中断向量值代替返回地址
	MOV 	BX,[BP]			;取中断号
	SHL 	BX,2			;乘4
	MOV 	AX,[BX]			;取实方式下对应中断向量的偏移
	MOV 	Pip,AX			;代替0级堆栈中的EIP
	MOV 	AX,[BX+2]		;取实方式下对应中断向量的段值
	MOV 	Pcs,AX			;代替0级堆栈中的CS
	POP		EBX				;恢复EBX、EAX等
	POP		EAX
	POP		BP
	POP		BP
;③从保护方式返回V86方式
;先转入对应中断处理程序，再返回中断发生处
	IRETD
	TPCodeLEN = $
TPCodeSEG 	ENDS
;V86任务下的通用保护异常处理程序代码段
GPCodeSEG 	SEGMENT 	PARA 	USE16
	ASSUME 	CS:GPCodeSEG
GPBegin:
	MOV 	AX,V86Data_SEL
	MOV 	DS,AX				;装载V86任务的数据段
	MOV 	SI,OFFSET GPERRMESS
	MOV 	AX,VideoBuff_sel
	MOV 	ES,AX
	MOV		DI,0
	MOV 	AH,17H				;显示属性值
	MOV 	CX,GPERRMESSLEN
	CLD
GNEXT:
	LODSB
	STOSW						;显示发生通用保护异常的提示信息
	LOOP 	GNEXT				;利用DOS的21H功能调用终止引起该异常的程序
	ADD 	ESP,4				;废除堆栈中的出错代码
	MOV 	AX,4C01H
	JUMP16	TPCode_SEL,ENT21H	;转21H号中断处理程序
	GPCodeLEN = $
GPCodeSEG ENDS
;V86方式执行的8086程序段
V86CodeSEG 	SEGMENT 	PARA 	USE16
	ASSUME 	CS:V86CODESEG,DS:V86CODESEG
	Message	DB 	'V86 is OK.',0DH.0AH,24H
V86Begin:
;处于V86方式
	MOV 	AH,9				;显示进入V86方式的提示信息
	MOV 	DX,OFFSET Message
	INT 	21H					;驻留内存方式返回到DOS
	MOV 	AX,RCodeSEG
	SUB 	AX,GDTSEG			;计算驻留的长度
	MOV 	DX,OFFSET TSRLINE +16
	SHR	 	DX,4				;以“节”为单位
	ADD 	DX,AX
	ADD 	DX,10H				;含PSP的节数
	MOV 	AX,3100H
	INT 	21H
V86CodeSEG 	ENDS
;临时任务的TSS段
TempTSSSEG 	SEGMENT 	PARA 	USE16
	DD 		0			;链接字
	DD 		?			;0级堆栈指针
	DW 		?,?			;总是特权级0,无堆栈切换
	DD 		?			;1级堆栈指针
	DW 		?,?
	DD 		?			;2级堆栈指针
	DW 		?,?
	DD		0			;CR3
	DW 		?,0			;EIP
	DD		0			;EFLAGS
	DD 		0			;EAX
	DD 		0			;ECX
	DD 		0			;EDX
	DD 		0			;EBX
	DW 		?,0			;ESP
	DD 		0			;EBP
	DD 		0			;ESI
	DD		0			;EDI
	DW 		?,0			;ES
	DW 		TempCode_SEL,0	;CS
	DW 		?,0			;SS
	DW 		?,0			;DS
	DW 		?,0			;FS
	DW 		?,0			;GS
	DW 		0,0			;LDT(临时任务不使用LDT)
	DW 		0			;指向`I/O`许可位图区的指针
	DW 		$ + 2
	DB 		0FFH		;`I/O`许可位图结束字节
	TempTSSLEN = $
TempTSSSEG 		ENDS
;临时任务的代码段
TempCodeSEG 	SEGMENT 	PARA 	USE16
	ASSUME 	CS:TempCodeSEG
Virtual:;进入保护方式后的入口点
	MOV 	AX,TempTSS_SEL
	LTRAX					;加载TR指向临时任务的TSS
	MOV 	AX,Normal.SEL	;准备切换到V86任务
	MOV 	DS,AX			;给各段寄存器赋适当的选择子
	MOV		ES,AX
	MOV 	FS,AX
	MOV 	GS,AX
	MOV 	SS,AX
	JUMP16 	V86TSS_SEL,0
;转移到V86任务(V86方式)
;从INTFF任务回到临时任务的入口点
ToReal:
	CLTS
	MOV 	EAX,CR0
	AND 	EAX,0FFFFFFFEH
	MOV 	CR0,EAX .			;返回实方式
	JUMP16 	<SEG Real>,<OFFSET Real>
TempCodeSEG 	ENDS
;实方式下的初始化代码和数据
RCodeSEG 	SEGMENT 	PARA 	USE16
	VGDTR 		PDESC		<GDTLEN-1,>		;伪GDTR
	VIDTR		PDESC 		<IDTLEN-1,>		;伪IDTR
	NORVIDTR	PDESC		<3FFH,0>		;保存实方式下的IDTR
	SPVAR		DW			?				;保存实方式下的堆栈指针
	SSVAR		DW			?
	ASSUME 	CS:RCodeSEG,DS:RCodeSEG
Start:
	MOV 	AX,RCodeSEG
	MOV 	DS,AX
	CLD
	CALL 	INIT_GDT			;初始化GDT
	CALL 	INIT_IDT			;初始化IDT
	MOV 	AX,V86LDTSEG
	MOV 	FS,AX
	MOV		CX,V86LDNUM
	MOV 	SI,OFFSET VLDT
	CALL 	INIT_LDT			;初始化V86任务的LDT
	MOV	 	AX,INTFFLDTSEG
	MOV 	FS,AX
	MOV 	CX,INTFFLDNUM
	MOV 	SI,OFFSET FLDT
	CALL 	INIT_LDT			;初始化INTFF任务的LDT
	MOV 	SSVAR,SS			;保存实方式下的堆栈指针
	MOV 	SPVAR,SP
	LGDT 	QWORD PTR VGDTR 	;装载GDTR
	SIDT 	NORVIDTR			;保存IDTR
	CLI
	LIDT 	QWORD PTR VIDTR 	;装载IDTR
	MOV 	EAX,CR0
	OR 		EAX,1
	MOV 	CRO,EAX				;转保护方式下的临时任务
	JUMP16 	<TempCode_SEL>,<OFFSET Virtual>
Real:;从保护方式回到实方式时的入口点
	MOV 	AX,CS
	MOV 	DS,AX
	LIDT 	NORVIDTR			;恢复IDTR
	LSS 	SP,DWORD PTR SPVAR
	STI
	MOV 	AX,4C00H			;结束发出INTFF指令的DOS程序
	INT 	21H
TSRLINE 	LABEL 	BYTE
;实方式下的初始化过程
INIT_GDT	PROC	NEAR
;同实例四
INIT_GDT	ENDP
;初始化局部描述符表的过程
INIT_LDT	PROC
;同实例四
INIT_LDT	ENDP
;初始化IDT表及伪IDTR的过程
INIT_IDT 	PROC
	PUSH 	DS
	MOV 	AX,IDTSEG
	MOV 	DS,AX
	MOV 	CX,256-1		;对FFH号特殊处理
	MOV 	SI,OFFSET IDT
	MOV 	AX,OFFSET TPBegin
IIDT1:
	CMP		CX,256-1-13
	JZ 		IIDT2			;对13号特殊处理
	MOV		[SI],AX
IIDT2:
	ADD		SI,8			;每个门描述符8字节
	ADD 	AX.7			;处理程序开始部分长7字节
	LOOP 	IIDT
	POP		DS
;
	MOV 	BX,16
	MOV 	AX,IDTSEG
	MUL 	BX				;设置伪IDTR
	MOV 	WORD PTR VIDTR.BASE,AX
	MOV 	WORD PTR VIDTR.BASE+2,DX
	RET
INIT_IDTE	NDP
RCodeSEG 	ENDS
	END Start
```

### 2.说明

#### (1) 对IDT表的初始化

为了方便地书写IDT表，采用了重复汇编。从采用重复汇编方式定义的IDT表可见，除对应通用保护异常的13号陷阱门描述符和255号任务门描述符外，其他中断门描述内的偏移均未设定。为此，在实方式下初始化时，把相应的入口偏移填入这些门描述符。从源程序可见，这些处理程序的入口片段也用重复汇编书写，并且字节数相同，所以间隔等长。

#### (2) 任务切换方式进入V86方式

实例从临时任务切换到V86任务时进入V86方式。在V86任务的TSS中，EFLAGS字段内的VM=1，所以随着任务切换，就进入V86方式。为此，TSS中对应各段寄存器字段内的初始值都是V86方式下要执行的8086程序的各段值，而非选择子。由于在发生中断/异常时要进入V86任务的特权级0，所以初始化了0级堆栈指针。V86任务使用局部描述表LDT，所以TSS中对应字段填有相应的选择子。

#### (3) V86方式下对中断的处理

实例对V86方式下响应中断和执行软中断指令`INTn`的处理方法是，转实方式下的对应中断处理程序。具体步骤如下：

1. 在V86方式堆栈(V86任务的3级堆栈)顶形成返回点的现场；
2. 用实方式下对应的中断向量值代替返回地址；
3. 从保护方式返回V86方式。

由于堆栈中保存的EFLAGS内的VM=1，所以在保护方式下执行IRET指令时返回V86方式；由于在0级堆栈中保存的返回地址(段值和偏移)已被修改成实方式下的中断向量，所以这时的返回也就是转入实方式下的对应中断处理程序；由于在V86堆栈顶已安排了返回地址，所以在实方式下执行对应中断处理程序时，遇到IRET指令就返回到V86任务的被中断处。这种处理方法似乎绕了个弯。但就是利用这个方法有效地调用了DOS功能，方便地显示了提示信息`V86isok.`，顺利地实现了驻留退出所以，除为了确定中断向量号在中断处理程序之初的代码不同外，其他代码可重复和用。这也是可用重复汇编和循环填写偏移初始化的条件。
这种处理方法没有充分考虑异常，更没有考虑异常时的出错码。

#### (4) V86任务的通用保护异常处理

在演示的第一阶段和第二阶段，不会发生任何异常。但在这两个阶段之间，由于允许执行其他程序，可能引起异常。为了简单，实例只考虑了通用保护异常，而未考虑其他异常。该可能发生异常的阶段是在V86方式下。如果发生通用保护异常，那么就转入V86任务的通用保护异常处理程序。通用保护异常处理程序在保护方式下显示提示信息`……GeneralProtectionError……`，然后再转21H号中断处理程序，通过设置入口参数AX=4C01H，中止引起通用保护异常的程序。

#### (5) INTFF任务

为了演示以任务切换方式离开V86方式，在实例中安排了这一任务，并称之为INTFF任务，由于IDT表中的255(0FFH)号描述符是任务门描述符，所以当在V86方式下执行`INTFFH`时便从V86方式切换到INTFF任务。INTFF任务的TSS是初始化好的，在INTFF任务下不发生特权级变换，不使用局部描述表LDT。INTFF任务先显示提示信息`Returntorealmode."，然后再切换到临时任务

此外，在V86方式下，指令PUSHF、POPF、INTn和IRET却对IOPL敏感。也就是说，在V86方式下，当IOPL<3时，执行指令PUSHF、POPF、INTn及IRET会引起出错码为0的通用保护故障，并非象10.9.2节所述保持沉默。
采取这些措施的目的是使操作系统软件可以支持一个`虚拟EFALG`寄存器。
