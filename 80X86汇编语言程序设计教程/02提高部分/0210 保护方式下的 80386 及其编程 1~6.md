[toc]

==80386有两种工作方式：实方式和保护方式==。本章介绍保护方式下的80386及相关的程序设计内容。第9章介绍的80386寄存器、寻址方式和指令等基本概念，除特别说明外在保护方式下仍然保持。
在以80386为处理器的硬件平台和DOS为操作系统的软件平台上，可以调试运行本章列出的实例。请用TASM或者MASM汇编这些实例，用TLINK连接(部分实例需要带32位连接选项“/3”)。在调试运行这些实例时，不要安装使用扩展内存的驱动程序，以避免发生冲突。

# 10.1 保护方式简述

尽管实方式下的80386的功能要大大超过其先前处理器(8086/8088、80186、80286)的功能，但只有在保护方式下，80386才能真正发挥作用。==在保护方式下，全部32条地址线有效，可寻址高达4G字节的物理地址空间==；==扩充的存储器分段管理机制和可选的存储==
==器分页管理机制，不仅为存储器共享和保护提供了硬件支持，而且为实现虚拟存储器提供了硬件支持==；==支持多任务，能够快速地进行任务切换和保护任务环境==；==4个特权级和完善的特权检查机制，既能实现资源共享又能保证代码及数据的安全和保密、及任务的隔离支持虚拟8086方式，便于执行8086程序==。

## 10.1.1 存储管理机制

为了对存储器中的程序及数据实现保护和共享提供硬件支持，为了对实现虚拟存储器提供硬件支持，在保护方式下，80386不仅采用扩充的存储器分段管理机制，而且还损供可选的存储器分页管理机制。这些存储管理机制由80386的存储器管理部件MMU实现

### 1. 背景

==80386有32根地址线，在保护方式下，它们都能发挥作用，所以可寻址的物理地址空间高达4G字节==。==在以80386及其以上处理器为CPU的PC兼容机系统中，把**地址在1M以下的内存称为常规内存**，把**地址在1M以上的内存称为扩展内存**==。
80386还要对实现虚拟存储器提供支持。虽然与8086可寻址的1M字节物理地址空间相比，80386可寻址的物理地址空间可谓很大，但实际的微机系统不可能安装如此大的物理内存。所以，为了运行大型程序和真正实现多任务，必须采用虚拟存储器。虚拟存储器是一种软硬件结合的技术，用于提供比在计算机系统中实际可以使用的物理主存储器大得多的存储器空间。这样，程序员在编写程序时，不用考虑计算机中物理存储器的实际容量。
==80386还要对存放在存储器中的代码及数据的共享和保护提供支持==。==任务甲和任务乙并存，任务甲和任务乙必须隔离，以免相互影响==。==但它们又可能要共享部分代码和数据==。所以，==80386既要**支持任务隔离**，又要**支持可共享代码和数据的共享**，还要**支持特权保护**==。

### 2. 地址空间和地址转换

==保护方式下的虚拟存储器由大小可变的存储块构成，这样的存储块称为段==。==80386采用称为描述符的数据来描述段的位置、大小和使用情况==。==虚拟存储器的地址(逻辑地址)由指示描述符的选择子和段内偏移两部分构成，这样的地址集合称为虚拟地址空间==。==80386支持的虚拟地址空间可达64T字节==。程序员编写程序时使用的存储地址空间是虚拟地址空间，所以，他们可认为有足够大的存储空间可供使用。
显然，只有在物理存储器中的程序才能运行，只有在物理存储器中的数据才能访问。因此，==虚拟地址空间必须映射到物理地址空间，二维的虚拟地址必须转换成一维的物理地址==。由于物理地址空间远小于虚拟地址空间，所以只有虚拟地址空间中的部分可以映射到物理地址空间。由于物理存储器的大小要远小于物理地址空间，所以只有上述部分中的部分才能真正映射到物理存储器。
==每一个任务有一个虚拟地址空间==。==为了避免多个并行任务的多个虚拟地址空间直接映射到同一个物理地址空间，采用线性地址空间隔离虚拟地址空间和物理地址空间==。==线性地址空间由一维的线性地址构成，线性地址空间和物理地址空间对等==。==线性地址32位长，线性地址空间容量为4G字节==。
==80386分两步实现虚拟地址空间到物理地址空间的映射，也就是分两步实现虚拟地址到物理地址的转换，但第二步是可选的==。图10.1是地址映射转换的示意。

![image]（https://github.com/YangLuchao/img_host/raw/master/20231127/image.42vfo5us3yu0.jpg ）

==通过**描述符表**和**描述符**，分段管理机制实现虚拟地址空间到线性地址空间的映射，实现把二维的虚拟地址转换为一维的线性地址==。==这一步总是存在的==。
==**分页管理机制**把线性地址空间和物理地址空间分别划分为大小相同的块，这样的块称之为页==。==通过在**线性地址空间的页**与**物理地址空间的页**之间建立的映射表，分页管理机制实现**线性地址空间**到**物理地址空间**的**映射**，实现线性地址到物理地址的转换==。分页管理机制是可选的，在不采用分页管理机制时，线性地址空间就直接等同于物理地址空间，线性地址就直接等于物理地址。
==分段管理机制所使用的可变大小的块，使分段管理机制比较适宜处理复杂系统的逻辑分段==。存储块的大小可以根据适当的逻辑含义进行定义，而不用考虑固定大小的页所强加的人为限制。==每个段可作为独立的单位处理，以简化段的保护及共享==。

==分页机制使用的固定大小的块最适合于管理物理存储器，无论是管理内存还是外存都同样有效==。分页管理机制能够有效地支持实现虚拟存储器。

## 10.1.2 保护机制

==为了支持多任务，对各任务实施保护是必需的==。从80286开始，处理器就具备了保护机制。==保护机制能有效地实现不同任务之间的保护和同一任务内的保护==。

### 1. 不同任务之间的保护

==保护的一个重要方面是应用程序之间的保护==。==通过把每个任务放置在不同的虚拟地址空间的方法来实现任务与任务的隔离，达到应用程序之间保护的目的==。==虚拟地址到物理地址的映射函数在每个任务中进行定义，随着任务切换，映射函数也切换==。任务A的虚拟地址空间映射到物理地址空间的某个区域，而任务B的虚拟地址空间映射到物理地址空间的另外区域，彼此独立，互不相于。==因此，两个不同的任务，尽管虚拟存储单元地址相同，但实际的物理存储单元地址可以不同==。

### 2. 同一任务内的保护

==在一个任务之内，定义有四种执行特权级别，用于限制对任务中的段进行访问==。按照包含在段中的数据的重要性和代码的可信任程度，给段指定特权级别。==把最高的特权级别分配给最重要的数据段和最可信任的代码段==。==具有最高特权级别的数据，只能由最可信任的代码访问==。给不重要的数据段和一般代码段分配较低的特权级别。==具有最低特权级别的数据，可被具有任何特权级别的代码访问==。
==特权级别用数字0~3表示，数字0表示最高特权级别，而数字3表示最低特权级别==。数字较大的级别具有较低的特权。为了避免模糊和混淆，在比较特权级别时，不使用“大于”或“小于”这样的术语，而使用“里面”或“内层”这样的术语表示较高特权级，级别的数字较小，使用“外面”或“外层”这样的术语表示较低特权级别，级别的数字较大。0级为最内层的特权级别，3级为最外层的特权级别，按这样的表示方法，四种特权级的层次关系如图10.2所示。

![image]（https://github.com/YangLuchao/img_host/raw/master/20231127/image.6x8quw650d80.jpg）

==每个存储器段都与一个特权级别相联系==。特权级别限制是指，只有足够级别的程序，才可对相应的段进行访问。在任何时候，一个任务总是在4个特权级之一下运行，==任务在特定时刻的特权级称为当前特权级(Current Privilege Level)，标记为CPL==。==每当一个程序试图访问一个段时，就把`CPL`与要访问的段的特权级进行比较，以决定是否允许这一访问==。==对给定CPL执行的程序，允许访问同一级别或外层级别的数据段==。如图10.2所示，CodeK可访问同级的数据段DataK，也可访问外层的DataOS、DataAP1及DataAP2等。如试图访问内层级别的数据段则是非法的，并引起异常。如图10.2所示，CodeOS可访问同级的DataOS,也可访问外层的DataAP1和DataAP2等，但不能访问内层的DataK。
虽然应用程序都在最外层，但由于各个不同的应用程序存储在不同的虚拟地址空间中，所以各应用程序被隔离保护。如图10.2所示，最外层的CodeAP1只能访问DataAP1,不可能访问同级的另一个应用程序的DataAP2；同样，CodeAP2只能访问DataAP2，不可能访问DataAP1。
这实际上是组合保护。应用程序1和操作系统构成任务A，应用程序2和操作系统构成任务B。操作系统被任务A和任务B共享，在任务A和任务B的两个不同的虚拟地址空间中，操作系统占用虚拟地址空间相同的部分。

==特权级的典型用法是，把操作系统的核心放在0级，操作系统的其余部分放在1级，而应用程序放在3级，留下2级供中间软件使用==。对特权级进行这样的安排，使得在0级的操作系统核心有权访问任务中的所有存储段；在1级的操作系统其余部分有权访间除0级外的所有存储段；而在3级的应用程序只能访问程序本身的存储段，这些存储段也是在3级。

# 10.2 分段管理机制

> 本节介绍==**保护方式下的段定义**以及**由段选择子和段内偏移构成的二维虚拟地址**如何**被转换为一维线性地址**==。
>

## 10.2.1 段定义和虚拟地址到线性地址转换

==段是实现虚拟地址到线性地址转换机制的基础==。

在保护方式下，==每个段由如下三个参数进行定义==：

1. ==段基地址(Base Address)==
2. ==段界限(Limit)==
3. ==段属性(Attributes)==

==段基地址规定线性地址空间中段的开始地址==。在80386保护方式下，段基地址长32位。因为基地址长度与寻址地址的长度相同，所以任何一个段都可以从32位线性地址空间中的任何一个字节开始，而不像实方式下规定段的边界必须被16整除。
==段界限规定段的大小==。==在80386保护方式下，**段界限用20位表示**，而且**段界限可以是以字节为单位或以4K字节为单位**==。==段属性中有一位对此进行定义，把该位称为粒度位，用符号G标记==。==`G=0`表示段界限以字节为单位，于是20位的界限可表示的范围是1字节至1M字节，增量为1字节==；==`G=1`表示段界限以4K字节为单位，于是20位的界限可表示的范围是4K字节至4G字节，增量为4K字节==。当段界限以4K字节为单位时，实际的段界限LIMIT可通过下面的公式从20位段界限Limit计算出来：
$$
LIMIT=Limit*4K+0FFFH=(Limit<<12)+0FFFH
$$
所以，==当粒度位为1时，段的界限实际上就扩展成为32位==。由此可见，在80386保护方式下，段的长度可大大超过64K字节。
==**基地址**和**界限**定义了段所映射的线性地址的范围==。基地址Base是线性地址对应于段内偏移为0的虚拟地址，段内偏移为x的虚拟地址对应`Base+x`的线性地址。段内从偏移0到Limit范围内的虚拟地址对应于从`Base`到`Base+Limit`范围内的线性地址。图10.3表示一个段如何从虚拟地址空间定位到线性地址空间。图中`BaseA`等代表段基地址，`LimitA`等代表段界限。另外，段C接在段A之后，也即
$$
BaseC=BaseA+LimitA。
$$
![image]（https://github.com/YangLuchao/img_host/raw/master/20231127/image.16zrt2jpsduo.jpg ）

例如：设段A的基地址等于`00012345H`，段界限等于`5678H`并且段界限以字节为单位(G-0),那么段A对应线性地址空间中从`00012345H~000179BDH`的区域。如果段界限以4K字节为单位(G=1),那么段A对应线性地址空间中从`00012345H~0568B344H(=00012345H+5678000H+0FFFH)`的区域。
通过增加段界限，可以使段的容量得到扩展。这对于那些要在内存中扩展容量的普通数据段很有效，但对堆栈段情况就不是这样。因为堆栈底在高地址端，随着压栈操作，堆栈向低地址方向扩展。==为了适应普通数据段和堆栈数据段在两个相反方向上的扩展，数据段的段属性中安排一扩展方向位，标记为`ED`==。==`ED=0`表示向高扩展，`ED=1`表示向低扩展==。
==数据段的扩展方向和段界限一起决定了数据段内偏移的有效范围==。如图10.4所示。当段最大为1M字节时，在自然的向高扩展段内，从`0~Limit`的偏移是合法有效的偏移而从`Limit+1~1M-1`的偏移是非法无效的偏移；在向低扩展段内，情形刚好相反，从0~Limit的偏移是法无效的偏移，而从`Limit+1~1M-1`的偏移是合法有s效的偏移，注意边界值Limit对应地址的有效性。当段最大为4G字节时，情形类似。

> ==注意，只有在数据段的段属性中才有扩展方向属性位ED，也就是说只有数据段(堆栈段作为特殊的数据段)才有向高扩展和向低扩展之分，其它段都是自然的向高扩展。==

==在每次把虚拟地址转换为线性地址的过程中，要对偏移进行检查==。==如果偏移不在有效的范围内，那么就引起异常==。

![image]（https://github.com/YangLuchao/img_host/raw/master/20231127/image.6l7wc6yqrrw0.jpg ）

==段属性规定段的主要特性==。例如上面已提到的段粒度G就是段属性的一部分。在对段进行各种访问时，将对访问是否合法进行检查，主要依据是段属性。例如：如果向一个只读段进行写入操作，那么不仅不写入，而且会引起异常。在下面会详细说明各段属性位的定义和作用。

## 10.2.2 存储段描述符

==用于表示上述定义段的三个参数的数据称为描述符==。==每个描述符长8个字节==。在保护方式下，每一个段都有一个相应的描述符来描述。
==按描述符所描述的对象来划分==，描述符可分为如下三类：

1. ==存储段描述符==
2. ==系统段描述符==
3. ==门描述符(控制描述符)==

下面先介绍存储段描述符。

### 1. 存储段描述符

==存储段是存放可由程序直接进行访问的代码和数据的段==。存储段描述符描述存储段，所以==存储段描述符也被称为代码和数据段描述符==。
存储段描述符的格式如图10.5所示。图中上面一排是对描述符8个字节的使用的说明，最低地址字节(假设地址为m)在最右边，其余字节依次向左，直到最高字节，地址为m+7;下一排是对属性域各位的说明。

![image] (https://github.com/YangLuchao/img_host/raw/master/20231127/image.2c7x4sm8mnk0.jpg )

从图10.5可知，长32位的段基地址(段开始地址)被安排在描述符的两个域中，其位0~位23安排在描述符内的第2~第4字节中，其位24~位31被安排在描述符内的第7字节中。长20位的段界限也被安排在描述符的两个域中，其位0~位15被安排在描述符内的第0~第1字节中，其位16~位19被安排在描述符内的第6字节的低4位中。
使用两个域存放段基地址和存放段界限的原因与80286有关。在80286保护方式下，段基地址只有24位长，而段界限只有16位长。80286存储段描述符尽管也是8字节长但实际只使用低6字节，而高2字节必须置为0。80386存储段描述符这样的安排，可使得80286的存储段描述符的格式在80386下继续有效。
==80386描述符中的段属性也被安排在两个域中==。下面对其定义及意义作说明。

1. ==P位称为存在(Present)位==。==P=1表示描述符对地址转换是有效的==，或者表示该描述符所描述的段存在；==P=0表示描述符对地址转换无效==，并且使用该描述符会引走异常。

2. ==`DPL`表示描述符特权级(Descriptor Privilege Level)，共2位。它规定了所描述段的特权级，用于特权检查，以决定对该段能否进行访问==。

3. ==`DT`位说明描述符的类型==。==对于存储段描述符而言，`DT=1`，以区别于系统段描述符和门描述符(`DT=0`)==。

4. ==`TYPE`说明存储段描述符所描述的存储段的具体属性==。
   ==其中的**位0**指示描述符**是否被访问**(Accessed)，用符号A标记。A=0表示尚未被访问，A=1表示段已被访问==。当把描述符的相应选择子装入到段寄存器时，80386把该位置为1，表明描述符已被访问。操作系统可测试访问位，以确定描述符是否被访间过。
   ==其中的**位3**指示所描述的**段是代码段还是数据段**，用符号E标记==。==E=0表示段是不可执行段，也就是数据段==，相应的描述符也就是数据段(包括堆栈段)描述符。==E=1表示段是可执行段，也就是代码段==，相应的描述符也就是代码段描述符。
   在数据段描述符中(==E=0的情况==)：
   ==**TYPE中的位1**指示所描述的**数据段是否可写**，用W标记==。==W=0表示对应的数据段不可写，只能读==，==W=1表示对应的数据段可写==。
   ==**TYPE中的位2**就是ED位，指示所描述的**数据段的扩展方向**==。==ED=0表示数据段向高扩展，也即段内偏移必须小于等于段界限。ED=1表示数据段向低扩展，也即段内偏移必须大于段界限==。
   在代码段描述符中(==E=1的情况==)：
   ==**TYPE中的位1**指示所描述的代码段是否可读，用符号R标记==。==R=0表示对应的代码段不可读，只能执行==，==R=1表示对应的代码段可读可执行==。
   ==T**YPE中的位2**指示所描述的代码段是否是一致码段，用C代表==。==C=0表示对应的代码段不是一致码段(普通代码段)，C=1表示对应的代码段是一致码段==。
   存储段描述符中的TYPE所说明的存储段的属性可归纳为表10.1。![image](https://github.com/YangLuchao/img_host/raw/master/20231127/image.2vovvr4pgsy0.jpg)
   在80286的存储段描述符中，位于描述符内第5字节的段属性各位的意义与上述说明相同，确切地说是80386为了与80286兼容而保持了原有定义。下面说明的属性位是80386在80286基础上的扩充的属性位。

5. ==G位就是段界限粒度(Granularity)位。G=0表示界限粒度为字节，G=1表示界限粒度是4K字节==。注意，界限粒度只对段界限有效，对段基地址无效，段基地址总是以字节为单位。

6. D位是一个很特殊的位，在**描述可执行段**、**向低扩展数据段**或者由**SS寄存器寻址的段(通常就是堆栈段)**的三种描述符中的意义各不相同。

   1. ==在**描述可执行段的描述符**中，D位决定了**指令使用的地址及操作数所默认的大小**==。
      ==**D=1**表示默认情况下指令使用32位地址及32位或8位操作数，这样的代码段也称为32位代码段==；
      ==D=0表示默认情况下使用16位地址及16位或8位的操作数，这样的代码段也称为16位代码段==
      它与80286兼容。就象在第9章中所述，可使用地址大小前缀和操作数大小前缀分别改变默认的地址或操作数的大小。
   2. ==在**向低扩展数据段的描述符**中==，==**D位决定段的上部边界**==。
      ==**D=1**表示段的上部界限为4G;==
      ==**D=0**表示段的上部界限为64K==，这是为了与80286兼容。
   3. ==在描述由**SS寄存器寻址的段描述符**中，D位决定隐式的堆栈访问指令(如PUSH和POP指令)**使用何种堆栈指针寄存器**==。
      ==**D=1**表示使用32位堆栈指针寄存器**ESP**==;
      ==**D=0**表示使用16位堆栈指针寄存器SP==，这与80286兼容。

7. `AVL`位是软件可利用位。80386对该位的使用未做规定，Intel公司也保证今后开发生产的处理器只要与80386兼容，就不会对该位的使用做任何定义或规定。


此外，描述符内第六字节中的位5须置成0,可理解成是为以后的处理器保留的。

### 2. 存储段描述符的结构类型表示

根据如图10.5给出的存储段描述符的结构，可定义如下的描述符结构类型：

> ==基址32位==
>
> ==界限20位==
>
> ==属性12位==

```assembly
DESCRIPTOR STRUC
	LIIMITL		DW	0	;段界限低16位
	BASEL		DW 	0	;基地址低16位
	BASEM		DB	0	;基地址中间8位
	ATTRIBUTES	DW	0	;段属性(含段界限的高4位)
	BASEH		DB	0	;基地址高8位
DESCRIPTOR	ENDS
```

利用结构类型`DESCRIPTOR`能方便地在程序中说明存储段描述符。
例如：如下描述符DATAS描述一个可读写的有效(已存在)的数据段，基地址是100000H，以字节为单位的界限是0FFFFH，描述符特权级DPL=3。

```assembly
DATAS DESCRIPTOR <OFFFFH,0,10H,0F2H,0>
```

再如：如下描述符CODEA描述一个只可执行的有效的32位代码段，基地址是12345678H,以4K字节为单位的界限值是10H(以字节为单位的界限是10FFFH),描述符特权级DPL=0。

```assembly
CODEA DESCRIPTOR <10H,5678H,34H,0C098H,12H>
```

## 10.2.3 全局和局部描述符表

==一个任务会涉及多个段，每个段需要一个描述符来描述，为了便于组织管理，80386把描述符组织成线性表==。==由描述符组成的线性表称为描述符表==。在80386中有三种类型的描述符表：

1. ==全局描述符表`GDT`(Global Descriptor Table)==
2. ==局部描述符表`LDT`(Local Descriptor Table)==
3. ==中断描述符表`IDT`(Interrupt Descriptor Table)==

==在整个系统中，全局描述符表`GDT`和中断描述符表`IDT`只有一张，局部描述符表可以有若干张，每个任务可以有一张==。
例如：下列描述符表有6个描述符构成：

```assembly
DESCTAB LABEL  		BYTE
DESC1 	DESCRIPTOR 	<1234H,5678H,34H,92H,0>
DESC2 	DESCRIPTOR 	<1234H,5678H,34H,93H.0>
DESC3 	DESCRIPTOR 	<5678H,1234H,56H,98H,0>
DESC4 	DESCRIPTOR 	<5678H,1234H,56H,99H,0>
DESC5 	DESCRIPTOR 	<OFFFFH,0,10H,16H,0>
DESC6 	DESCRIPTOR 	<OFFFFH,0,10H,90H,0>
```

每个描述符表本身形成一个特殊的数据段。这样的特殊数据段最多可以含有8K(8096)个描述符。
在10.7.3节中介绍中断描述符表IDT。
==每个任务的局部描述符表`LDT`含有该任务自己的代码段、数据段和堆栈段的描述符，也包含该任务所使用的一些门描述符，如任务门和调用门描述符等==。==随着任务的切换，系统当前的局部描述符表LDT也随之切换==。
全局描述符表`GDT`含有每一个任务都可能或可以访问的段的描述符，通常==包含描述操作系统所使用的代码段、数据段和堆栈段的描述符==，也包含多种特殊数据段描述符，如各个用于描述任务`LDT`的特殊数据段等。在==任务切换时，并不切换`GDT`==。
==通过`LDT`可以使各任务私有的各个段与其他任务相隔离，从而达到受保护的目的==。==通过GDT可以使各任务都需要使用的段能够被共享==。图10.6给出了任务A和任务B所涉及的有关段既隔离受保护，又合用共享的情况。通过任务A的局部描述符表`LdtA`和任务B的局部描述符表`LdtB`，把任务A所私有的代码段CodeA及数据段DataA与任务B所私有的代码段CodeB和数据段DataB及DataB2隔离，但任务A和任务B通过全局描述符表`GDT`共享代码段CodeK及CodeOS和数据段DataK及CodeOS。
==一个任务可使用的整个虚拟地址空间分为相等的两半，一半空间的描述符在全局描述符表中，另一半空间的描述符在局部描述符表中==。==由于全局和局部描述符表都可以包含多达8096个描述符，而每个描述符所描述的段最大可达4G字节==，因此最大的虚拟地址空间可为：
$$
4GB*8096*2=64MMB=64T(字节）
$$
![image]（https://github.com/YangLuchao/img_host/raw/master/20231127/image.6vwp1j4blq80.jpg）

## 10.2.4 段选择子

==在实方式下，逻辑地址空间中存储单元的地址有**段值**和**段内偏移**两部分组成==。==在保护方式下，虚拟地址空间(相当于逻辑地址空间)中存储单元的地址**有段选择子**和**段内偏移**两部分组成==。与实方式相比，段选择子替代了段值。
==**段选择子长16位**==，其格式如图10.7所示。从图中可见，==段选择子的高13位是描述符索引(Index)==。==所谓描述符索引是指描述符在描述符表中的序号==。==段选择子的第2位是引用描述符表指示位==，标记为TI(Table Indicator),==`TI=0`指示从全局描述符表`GDT`中读取描述符：`TI=1`指示从局部描述符表`LDT`中读取描述符==。

![image] (https://github.com/YangLuchao/img_host/raw/master/20231127/image.xvzbmps9cj.jpg)

==**选择子确定描述符，描述符确定段基地址，段基地址与偏移之和就是线性地址**==。

所以，==虚拟地址空间中的由段选择子和偏移两部分构成的二维虚拟地址，就是这样确定了线性地址空间中的一维线性地址==。
==选择子的最低两位是请求特权级`RPL`(Requested Privilege Level)，用于特权检查==。例如：假设某个选择子的内容是0030H。根据图10.7所示选择子的格式可知：`Index=6`，`TI=0`，`RPL=0`，所以它指定全局描述符表中的第6个描述符，请求特权级是0。再如，假设某个选择子的`Index=4`，`TI=1`，`RPL=3`，那么该选择子的内容是27H。

由于选择子中的描述符索引字段用13位表示，所以可区分8096个描述符。这也就是描述符表最多含有8096个描述符的原因。由于每个描述符长8字节，按照图10.7所示选择子格式，屏蔽选择子低3位后所得的值就是选择子所指定的描述符在描述符表中的偏移，这可认为是安排选择子高13位为描述符索引的原因。
有一个特殊的选择子称为空(Null)选择子，它的Index=0，TI=0，而RPL字段可以为任意值。空选择子有特定的用途，当用空选择子进行存储器访问时会引起异常。空选择子是特别定义的，它不对应于全局描述符表GDT中的第0个描述符，因此GDT中的第0个描述符总不会被处理器访问，一般把它置成全0。但当TI=1时，Index为0的选择子不是空选择子，它指定了当前任务局部描述符表LDT中的第0个描述符。

## 10.2.5 段描述符高速缓冲寄存器

在实方式下，段寄存器含有段值，为访问存储器形成物理地址时，处理器引用相应的某个段寄存器得段值。在保护方式下，段寄存器含有段选择子，如上所述，为访问存储器形成线性地址时，处理器要使用选择子所指定的描述符中的基地址等信息。==为了避免在每次存储器访问时，都要访问描述符表而获得对应段描述符，从80286开始每个段寄存器都配有一个高速缓冲寄存器，称之为段描述符高速缓冲寄存器或称为描述符投影寄存器==，对程序员而言它是不可见的。每当把一个选择子装入到某个段寄存器时，处理器自动从描述符表中取出相应的描述符，把描述符中的信息保存到对应的高速缓冲寄存器中。此后在对该段访问时，处理器都使用对应高速缓冲寄存器中的描述符信息，而不用再从描述符表中取描述符。
各段描述符高速缓冲寄存器之内容如表10.2所列。其中，32位段基地址直接取自描述符，32位段界限取自描述符中的段界限，并转换成字节为单位。其它十个特性根据描述符中的属性而定，`Y`表示`是`，`N`表示`否`，`r`表示必须可读，`w`表示必须可写，`p`表示必须存在，`d`表示根据描述符中属性而定。

![image]（https://github.com/YangLuchao/img_host/raw/master/20231127/image.7bbmztonpvs0.jpg）

段描述符高速缓冲寄存器在处理器内，所以可对其进行快速访问。绝大多数情况下，对存储器的访问是在对应选择子装入到段寄存器之后进行的，所以，使用段描述符高速缓冲寄存器可以得到很好的执行性能。

把选择子装入段寄存器和通过段描述符高速缓冲寄存器实现由虚拟地址到线性地址的转换情形如图10.8所示。当不采用分页管理机制时，线性地址就是物理地址。

![image]（https://github.com/YangLuchao/img_host/raw/master/20231127/image.5tfp8f6pezs0.jpg）

设虚拟地址是`10:12345678H`，由选择子`10H`所指定的`GDT`中的存储段描述符所含的基地址是`87654321H`，那么该虚拟地址转换出的线性地址是`9999999H`。如不采用分页管理机制，那么物理地址就是`9999999H`。
段描述符高速缓冲寄存器之内保存的描述符信息将一直保持到重新把选择子装载到段寄存器时再更新。程序员尽管不可见段描述符高速缓冲寄存器，但必须注意到它的存在和它的上述更新时机。例如，==在改变了描述符表中的某个当前段的描述符后，也要更新对应的段描述符高速缓冲寄存器的内容，这可通过重新装载段寄存器实现==。

# 10.3 80386控制寄存器和系统地址寄存器

80386的控制寄存器和系统地址寄存器如图10.9所示，它们用于控制工作方式，控制分段管理机制及分页管理机制的实施。

## 10.3.1 控制寄存器

从图10.9可见，==80386有**四个32位的控制寄存器**，分别命名为`CR0`、`CR1`、`CR2`和`CR3`==。但CR1被保留，供今后开发的处理器使用，在80386中不能使用CR1，否则将引起无效指令操作异常。

==CR0包含指示**处理器工作方式的控制位**，包含**启用和禁用分页管理机制的控制位**，包含控制**浮点协处理器操作的控制位**==。

==CR2及CR3由**分页管理机制使用**==。

==CR0中的`位5~位30`及CR3中的`位0至位11`是保留位，这些位不能是随意值，必须为0==。
控制寄存器`CR0`的低16位等同于80286的机器状态字`MSW`。

![image] (https://github.com/YangLuchao/img_host/raw/master/20231127/image.55fdtjvxwqc0.jpg)

### 1. 保护控制位

 ==控制寄存器`CR0`中的**位0用PE标记**，**位31用PG标记**，这两个位**控制分段和分页管理机制**的操作，所以把它们称为保护控制位== 。

==PE控制分段管理机制。PE=0，处理器运行于实方式；PE=1，处理器运行于保护方式==。

==PG控制分页管理机制。PG=0，禁用分页管理机制，此时分段管理机制产生的线性地址直接作为物理地址使用；PG=1，启用分页管理机制，此时线性地址经过分页管理机制转换成物理地址==。

请参见图10.1。关于分页管理机制的具体介绍在10.9节中进行。

表10.3列出了通过使用PE和PG位选择的处理器工作方式。由于只有在保护方式下才可启用分页机制，所以尽管两个位分别为0和1，共可以有四种组合，但只有三种组合方式有效。PE=0且PG=1是无效的组合，因此，用PG位为1且PE位为0的值装入CRO寄存器将引起通用保护异常。

![image]（https://github.com/YangLuchao/img_host/raw/master/20231127/image.25dgqlcwvc5c.jpg）

### 2. 协处理器控制位

控制寄存器`CR0`中的位1~位4分别标记为MP(算术存在位)、EM(模拟位)、TS(任务切换位)和ET(扩展类型位)，它们控制浮点协处理器的操作。
当处理器复位时，ET位被初始化，以指示系统中数字协处理器的类型。如果系统中存在80387协处理器，那么ET位被置1;如果系统中存在80287协处理器或者不存在协处理器，那么ET位被清0。
EM位控制浮点指令的执行是用软件模拟，还是由硬件执行。EM=0时，硬件控制浮点指令传送到协处理器；EM=1时，浮点指令由软件模拟。
TS位用于加快任务的切换，通过在必要时才进行协处理器切换的方法实现这一目的。每当进行任务切换时，处理器把TS置1。TS = 1时，浮点指令将产生设备不可使用(DNA)异常。MP位控制WAIT指令在TS = 1时，是否产生DNA异常。MP = 1和TS = 1时，WAIT产生异常；MP=0时，WAIT指令忽略TS条件。

### 3. CR2和CR3

==控制寄存器`CR2`和`CR3`由分页管理机制使用==。
==CR2用于发生页异常时报告出错信息==。当发生页异常时，处理器把引起页异常的线性地址保存于CR2中。操作系统中的页异常处理程序可以检查CR2的内容，从而查出线性空间中的哪一页引起本次异常。
==CR3用于保存页目录表的起始物理地址==。==由于目录是页对齐的，所以**仅高20位有效**，**低12位保留未用**==。

==向CR3中装入新的值时，低12位必须为0，但从CR3中取值时，低12位被忽略==。每当用`MOV`指令重置`CR3`值时，会导致分页高速缓冲区内容无效。

在实方式下也可设置`CR3`，以便进行分页机制的初始化。在任务切换时，CR3要被改变，但是如果新任务中CR3的值与原任务中CR3的值相同，那么处理器不刷新分页高速缓冲寄存器，以便当任务共享页表时有较快的执行速度。

## 10.3.2 系统地址寄存器

==全局描述符表`GDT`、局部描述符表`LDT`和中断描述符表`IDT`等是保护方式下非常重要的特殊段，它们包含有对段机制所用的重要表格==。为了方便快速地定位这些段，处理器采用一些特殊的寄存器保存这些段的基地址和界限。我们把这些特殊的寄存器称为系统地址寄存器。

### 1. 全局描述符表寄存器GDTR

如图10.9所示，==`GDTR`长48位，其中高32位含基地址，低16位含界限==。由于`GDT`不能由`GDT`本身之内的描述符进行描述定义，所以处理器采用`GDTR`为`GDT`这一特殊的系统段提供一个伪描述符。`GDTR`给定了`GDT`，如图10.10所示。

![image] (https://github.com/YangLuchao/img_host/raw/master/20231127/image.4zpw0u8tfzk0.jpg)

==GDTR中的段界限以字节为单位==。由于段选择子中只有13位作为描述符索引，而每个描述符长8个字节，所以用16位表示GDT的界限足够。通常，对于含有N个描述符的描述符表的段界限应设置为`8*N-1`。
利用结构类型可定义伪描述符如下：

```assembly
PDESC 	STRUC
	LIMIT	DW	0
	BASE	DD 	0
PDESC	ENDS
```

### 2. 局部描述符表寄存器LDTR

==局部描述符表寄存器`LDTR`规定当前任务使用的局部描述符表`LDT`==。如图10.9所示，==LDTR类似于段寄存器，由程序员可见的一个16位的寄存器和程序员不可见的高速缓冲寄存器组成==。实际上，每个任务的局部描述符表`LDT`作为系统的一个特殊段，由一个描述符描述，而用于描述`LDT`的描述符存放在`GDT`中。在初始化或任务切换过程中，把指示描述对应任务`LDT`的描述符的选择子装入`LDTR`，处理器根据装入`LDTR`可见部分的选择子，从`GDT`中取出对应的描述符，并把`LDT`的基地址和界限等信息保存到`LDTR`的不可见的高速缓冲寄存器中。随后对`LDT`的访问，就可根据保存在高速缓冲寄存器中的有关信息进行合法性检查。
==LDTR寄存器包含当前任务的LDT的选择子==。所以，==装入到LDTR的选择子必须确定一个位于GDT的类型为LDT的系统段描述符，也即选择子中的T1位必须是0，而且描述符中的类型字段所表示的类型必须是LDT==。
可以用一个空选择子装入`LDTR`，这表示当前任务没有`LDT`。在这种情况下，所有装入到段寄存器的选择子都必须指示`GDT`中的描述符，也即当前任务涉及的段均由`GDT`中的描述符来描述。如果再把一个`T1`为1的选择子装入到段寄存器，将引起异常

### 3. 中断描述符表寄存器IDTR

==中断描述符表寄存器IDTR指向中断描述符表IDT==。如图10.9所示，==IDTR长48位，其中32位的基地址规定IDT的基地址，16位的界限规定IDT的段界限==。由于8038只支持256个中断/异常，所以IDT表最大长度是2K,以字节为单位的段界限为7FFH。IDTR指示IDT表的方式与GDTR指示GDT表的方式相同。

### 4. 任务状态段寄存器TR

==任务状态段寄存器`TR`包含指示描述当前任务的任务状态段的描述符选择子，从而规定了当前任务的状态段==。任务状态段的格式在10.5.2节说明。如图10.9所示，TR也有程序员可见和不见两部分。当把任务状态段的选择子装入到`TR`可见部分时，处理器自动把选择子所索引的描述符中的段基地址等信息保存到不可见的高速缓冲寄存器中。在此之后，对当前任务状态段的访问可快速方便地进行。装入到TR的选择子不能为空，必须索引位于GDT中的描述符，且描述符的类型必须是TSS。

# 10.4 实方式与保护方式切换实例

本节介绍两个实现实方式与保护方式切换的实例，通过它们说明如何实现实方式与保护方式的切换，也说明保护方式下的80386及其编程。

## 10.4.1 演示实方式和保护方式切换的实例(实例一)

实例一的逻辑功能是，以十六进制数的形式显示从内存地址110000H开始的256个字节的值。本实例指定该内存区域的目的仅仅是想说明切换到保护方式的必要性，因为在实方式下不能访问该指定内存区域，只有在保护方式下才能访问到该指定区域。
本实例的具体实现步骤是：

1. 作切换到保护方式的准备；
2. 切换到保护方式；
3. 把指定内存区域的内容传送到位于常规内存的缓冲区中；
4. 切换回实方式；
5. 显示缓冲区内容。

### 1.实例一源程序

实例一的源程序如下所示：

```assembly
;程序名：T10-1.ASM
;功能：演示实方式和保护方式切换
;16位偏移的段间直接转移指令的宏定义
;该宏编译后为：jump selector:offsetv
JUMP MACRO selector,offsetv
         DB 0EAH        ;操作码，'Far Jump'指令
         DW offsetv     ;16位偏移
         DW selector    ;段值或者选择子
ENDM
;字符显示宏指令的定义
;该宏为执行AH=2的INT21H指令显示一个字符
ECHOCH MACRO ascii
           MOV AH,2
           MOV DL,ascii
           INT 21H
ENDM
;存储段描述符结构类型的定义
;共64位
DESCRIPTOR 	STRUC
	LIMITL 			DW 	0	;段界限(0~15)
	BASEL			DW 	0	;段基地址(0~15)
	BASEM			DB	0	;段基地址(16~23)
	ATTRIBUTES 		DW 	0	;段属性
	BASEH			DB 	0	;段基地址(24~31)
DESCRIPTOR 	ENDS
;GDTR伪描述符结构类型的定义
PDESC	STRUC
	LIMIT 	DW 0	;16界限
	BASE	DD 0	;基地址
PDESC	ENDS
;常量定义
;AT为存储段描述符40~55位
ATDW = 0092H	;存在的可读写数据段属性值
                ;0092H的二进制表示为：0000 0000 1001 0010
                ;0 0 0 0    0000    1 00    1   0010
                ;G D 0 AVL  LIMIT   P DPL   DT  TYPE
                ;G=0:界限粒度为字节
                ;P=1表示描述符对地址转换是有效
                ;DPL表示描述符特权级
                ;DT=1，段储存描述符
                ;TYPE，位3=0，位2=0，位1=1，位0=1
                ;位1=1，W=1表示可写
                ;位3=0，数据段
                ;所以0092H的含义是：R0可读写数据段

ATCE = 0098H	;存在的只执行代码段属性值
                ;0098H的二进制表示为：0000 0000 1001 1000
                ;0 0 0 0    0000    1 00    1   1000
                ;G D 0 AVL  LIMIT   P DPL   DT  TYPE
                ;G=0:界限粒度为字节
                ;P=1表示描述符对地址转换是有效
                ;DPL表示描述符特权级
                ;DT=1，段储存描述符
                ;TYPE，位3=1，位2=0，位1=0，位0=0
                ;位1=0，不可写，只能读
                ;位3=1，可执行，代码段
                ;所以0098H的含义是：R0只执行代码段
.386P
;数据段
DSEG SEGMENT 	USE16                                       ;16位段
              GDT   LABEL 		BYTE                          ;全局描述符表GDT，标号标识
              DUMMY DESCRIPTOR 	<>                        ;空描述符，占8个字节64位
              CODE  DESCRIPTOR 	<0FFFFH,,,ATCE,>          ;含义为：界限为0FFFFH，基地址为0,属性为R0只执行代码段
    ;CODE为GDT第二个描述符，一个描述符结构体的长度位8h，所以CODE - 0 = 0008h
    ;0008h = 0000 0000 0000 1000 = 0000000000001 0 00
    ;表示0环GDT中index = 1的描述符
    CODE_SEL  =     CODE - GDT                            ;代码段描述的选择子
              DATAS DESCRIPTOR 	<0FFFFH,0H,11H,ATDW,0>    ;含义为：界限为0FFFFH，基地址为0011 0000H,属性为R0可读写数据段
    ;DATAS位GDT中第三个描述符，一个描述符结构体的长度位8h，所以DATAS - 0 = 0010h
    ;0010h = 0000 0000 0001 0000 = 0000000000010 0 00
    ;表示0环GDT中index = 2的描述符
    DATAS_SEL =     DATAS - GDT                           ;源数据段描述符的选择子
              DATAD DESCRIPTOR 	<0FFFFH,,,ATDW,>          ;含义为：界限为0FFFFH，基地址为0000 0000H,属性为R0可读写数据段
    ;DATAD位GDT中第四个描述符，一个描述符结构体的长度位8h，所以DATAS - 0 = 0018h
    ;0018h = 0000 0000 0001 1000 = 0000000000011 0 00
    ;表示0环GDT中index = 3的描述符
    DATAD_SEL =     DATAD - GDT                           ;目标数据段描述符的选择子
    GDTLEN    =     $ - GDT
              VGDTR PDESC 		<GDTLEN - 1,>                 ;VGDTR为GDT的伪描述符，GDTLEN - 1为GDT界限，就是所有描述符的长度
    BUFFERLEN =     256                                   ;缓冲区字节长度
    BUFFER    DB    BUFFERLEN DUP (0)                     ;缓冲区，被定义为真正的数据段
DSEG ENDS
;代码段
;在保护模式或长模式下（32 位或 64 位），不再需要显式地指定
CSEG SEGMENT 	USE16                                ;指示编译器在生成目标代码时使用 16 位模式
             ASSUME CS:CSEG,DS:DSEG                ;假设，代码段为自定义代码段，数据段为自定义数据段
    START:   
             MOV    AX,DSEG                        ;数据段标号挪到AX中
             MOV    DS,AX                          ;设置DS数据段段值
    ;准备要加载到GDTR的伪描述符
             MOV    BX,16                          ;将段标号转为段地址，在x86架构中，段地址是由段标号左移4位得到的
             MUL    BX                             ;乘以16相当于将段标号乘以16，将结果存储在AX寄存器中，作为段地址的一部分
             ADD    AX,OFFSET GDT                  ;界限已在定义时设置妥当
    ;在x86的实模式中，内存寻址是通过物理地址进行的，物理地址由段基址（由左移4位的段标号计算而来）和偏移地址组成
             ADC    DX,0                           ;ADC DX的意思是看 ADD AX,OFFSET GDT 有没有进位
             MOV    WORD PTR VGDTR.BASE,AX         ;设置GDTR的基址
             MOV    WORD PTR VGDTR.BASE+2,DX       ;设置基址进位
    ;设置代码段描述符
             MOV    AX,CS                          ;将代码段标号挪到AX中
             MUL    BX                             ;乘以16 将标号转换为物理地址
             MOV    CODE.BASEL,AX                  ;代码段描述符基址，低16位
             MOV    CODE.BASEM,DL                  ;代码段描述符基址，中8位
             MOV    CODE.BASEH,DH                  ;代码段描述符基址，高8位
             MOV    AX,DS                          ;将数据段标号挪到AX中
             MUL    BX                             ;乘以16 将标号转换为物理地址
             ADD    AX,OFFSET BUFFER               ;缓冲区地址挪到AX中
             ADC    DX,0                           ;如果有进位，将进位挪到DX中
             MOV    DATAD.BASEL,AX                 ;设置定义的真正的数据段基址
             MOV    DATAD.BASEM,DL
             MOV    DATAD.BASEH,DH
    ;加载GDTR
             LGDT   QWORD PTR VGDTR                ;将定义的VGDTR挪到GDTR寄存器中
             CLI                                   ;关中断
             CALL   ENABLEA20                      ;打开地址线A20
    ;切换到保护方式
             MOV    EAX,CR0                        ;控制寄存器cr0挪到EAX中
             OR     EAX,1                          ;将PE位置1，切换到保护模式
             MOV    CR0,EAX                        ;挪回到CR0
    ;清指令预取队列，并真正进入保护方式
    ;当前在保护模式下运行，CODE_SEL为段选择子，virtual为偏移
    ;配合jump指令，意思是在GDT中寻找偏移为CODE_SEL的段描述符
    ;拿到CODE_SEL段描述符后，找到段的基地址，加上偏移，得到真正的偏移地址
             JUMP   <CODE_SEL>,<OFFSET VIRTUAL>
    VIRTUAL:                                       ;现在开始在保护方式下
             MOV    AX,DATAS_SEL
             MOV    DS,AX                          ;加载源数据段描述符
             MOV    AX.DATAD_SEL
             MOV    ES,AX                          ;加载目标数据段描述符
             CLD                                   ;设置方向为正向
             XOR    SI,SI                          ;SI,DI清空
             XOR    DI,DI
             MOV    CX,BUFFERLEN/4                 ;设置4字节为单位的缓冲区长度
             REPZ   MOVSD                          ;传送
    ;切换回实方式
             MOV    EAX,CR0
             AND    EAX,OFFFFFFFEH                 ;将PE位设置为0，切换到实模式
             MOV    CR0,EAX
    ;清指令预取队列，进入实模式
    ;实模式下，JUMP 段值:偏移
             JUMP   <SEG REAL>,<OFFSET REAL>
    REAL:                                          ;现在又回到实方式
	
             CALL   DISABLEA20                     ;关闭地址线A20
             STI                                   ;开中断
    ;
    ;重置数据段寄存器
             MOV    AX,DSEG                        ;设置数据段到AX中
             MOV    DS,AX                          ;设置数据段段值
             MOV    SI,OFFSET BUFFER               ;设置源寄存器地址
             CLD                                   ;显示缓冲区内容
             MOV    BP,BUFFERLEN/16                ;计算打印行数
    NEXTLINE:
             MOV    CX,16                          ;设置每行打印16个字符
    NEXTCH:  
             LODSB                                 ;挪2个字节到AX中，SI+16
             PUSH   AX
             SHR    AL,4
             CALL   TOASCII
             ECHOCH AL
             POP    AX
             CALL   TOASCII
             ECHOCH AL
             ECHOCH ''
             LOOP   NEXTCH
             ECHOCH 0DH                            ;输出换行符
             ECHOCH 0AH
             DEC    BP
             JNZ    NEXTLINE
    ;
             MOV    AX,4C00H                       ;结束
             INT    21H
TOASCII PROC
    ;把AL低4位的十六进制数转换成对应的ASCII,保存在AL
TOASCII ENDP
    ;打开地址线A20
EA20 PROC
             PUSH   AX
             IN     AL,92H
             OR     AL,2
             OUT    92H,AL
             POP    AX
             RET
EA20 ENDP
    ;关闭地址线A20
DA20 PROC
             PUSH   AX
             IN     AL,92H
             AND    AL,0FDH                        ;0FDH = NOT 20H
             OUT    92H,AL
             POP    AX
             RET
DA20 ENDP
CSEG ENDS
	END START
```

### 2. 关于实现步骤的注释

在源程序中首定义了两条宏指令，一条是段间直接转移宏指令，另一条是显示字符宏指令。此外还定义了描述符和伪描述符的结构类型。下面对各实现步骤作些说明。

#### (1)切换到保护方式的准备工作

在从实方式切换到保护方式之前，必须作必要的准备。准备工作的内容根据实际应用而定。最起码的准备工作是 ==建立合适的全局描述符表，并使`GDTR`指向该`GDT`== 。==因为在切换到保护方式之时，至少要把代码段的选择子装载到`CS`，所以`GDT`中至少要含有代码段的描述符==。
从本实例源程序可见，全局描述符表`GDT`仅有四个描述符：==第一个是空描述符；第二个是代码段描述符；第三和第四个是数据段描述符==。

本实例各描述符中的段界限是在定义时预置的，并且==除伪描述符`VGDTR`中的界限按`GDT`的实际长度设置==外，各使用的存储段描述符的界限都规定为`0FFFFH`。另外，描述符中的段属性也根据所描述段的类型被预置，==`98H`表示存在的只可执行代码段，`92H`表示存在的可读写数据段==。从属性值可知，这三个存储段都是16位段。
==由于在切换到保护方式后，就要引用`GDT`，所以在切换到保护方式前须装载`GDTR`。本实例使用如下指令装载`GDTR`==:

```assembly
LGDT QWORD PTR VGDTR
```

==该指令的功能是把存储器中的伪描述符`VGDTR`装入到全局描述符表寄存器`GDTR`==。伪描述符VGDTR的结构如前述结构类型PDESC所示，低字是以字节为单位的界限，高双字是基地址。在10.8节中对LGDT指令作详细说明。

#### (2)由实方式切换到保护方式

在做好准备后，从实方式切换到保护方式并不繁难。==原则上只要把控制寄存器CR0中的PE位置1就可==。本实例采用如下三条指令设置PE位：

```assembly
MOV		EAX,CR0		;把CR0复制到EAX
OR		EAX,1		;把对应的PE位置1
MOV		CRO,EAX		;使CR0的PE位为1
```

实际情况要比这复杂些。==在执行上面的三条指令后，处理器转入保护方式，但`CS`中的内容还是实方式下代码段的段值，而不是保护方式下代码段的选择子，所以在取指令之前得把代码段选择子装入`CS`==。为此，紧接着这三条指令，安排一条如下所示的==段间转移指令==：

```assembly
JUMP	 <CODE_SEL>,<OFFSET VIRTUAL>
```

==这条段间转移指令在实方式下被预取，在保护方式下被执行==。==利用这条段间转移指令可把保护方式下代码段的选择子装入`CS`,同时也刷新指令预取队列==。==从此真正进入保护方式==。

#### (3)由保护方式切换到实方式

在80386上，==从保护方式切换到实方式的过程类似于从实方式切换到保护方式==。==原则上只要把控制寄存器`CR0`中的`PE`位清0就可==。实际上，==在此之后也要安排一条段间转移指令，一方面清指令预取队列，另一方面把实方式下代码段的段值送`CS`==。==这条段间转移指令在保护方式下被预取，在实方式下被执行==。

#### (4)传送

传送是在保护方式下进行的，首先，==把源数据段和目标数据段描述符的选择子装入`DS`和`ES`寄存器，这两个描述符已在实方式下设置好，把选择子装入段寄存器就意味着把包括段基地址在内的段信息装入段描述符高速缓冲寄存器==。然后，设置指针寄存器`SI`和`DI`的初值，也设置计数器`CX`初值。根据预置的段属性，在保护方式下，代码段也仅是16位段，串操作指令只使用16位的`SI`、`DI`和`CX`等寄存器。最后利用串操作指令实施传送。

#### (5)显示缓冲区内容

由于缓冲区在常规内存中，所以在实方式下根据要求按十六进制显示其内容是容易的。

### 3. 内存映象

==源程序中没有把`GDT`单独作为一个段对待，但在进入保护方式后，它是一个独立的段==。从对代码段和源数据段描述符所赋的基地址和界限可见，代码段和数据段有部分覆盖。尽管这样做不利于代码和数据的安全，但如果需要，这样做是可行的。本实例运行时的内存映象如图10.11所示。

![image] (https://github.com/YangLuchao/img_host/raw/master/20231127/image.2qlu9z1bxrw0.jpg)

### 4. 特别说明

作为第一个实方式和保护方式切换的例子，本实例作了大量的简单化处理。
==通常由实方式切换到保护方式的准备工作还应包含建立中断描述符表==。但本实例没有建立中断描述符表。为此，要求整个过程在关中断的情况下进行；要求不使用软中断指令；假设不发生任何异常。否则会导致系统崩溃。
本实例没有使用局部描述符表，所以在进入保护方式后没有设置局部描述符表寄存器`LDTR`。为此，在保护方式下使用的段选择子都指定`GDT`中的描述符。

本实例没有定义保护方式下的堆栈段，`GDT`中没有堆栈段描述符，在保护方式下没有设置`SS`,所以在保护方式下没有涉及堆栈操作的指令。
本实例各描述符特权级`DPL`和各选择子请求特权级`RPL`均是0，在保护方式下执行时的当前特权级`CPL`也是0。
本实例没有采用分页管理机制，也即`CR0`中的PG位为0，线性地址就是存储单元的物理地址。

### 5. 打开和关闭地址线A20

PC及其兼容机的第20根地址线较特殊，计算机系统中一般安排一个`门`控制该地址线是否有效。为了访问地址在1M以上的存储单元，应先打开控制地址线A20的`门`。
这种设置与实方式下只使用最低端的1M字节存储空间有关，与处理器是否工作在实方式和保护方式无关，即使在关闭地址线A20时，也可进入保护方式。
如何打开和关闭地址线A20与计算机系统的具体设置有关。如下的两个过程，在一般的PC兼容机上都是可行的。

```assembly
;打开地址线A20
EA20 	PROC
	PUSH	AX
	IN 		AL,92H
	OR 		AL,2
	OUT		92H,AL
	POP		AX
	RET
EA20 	ENDP
;关闭地址线A20
DA20 	PROC
	PUSH	AX
	IN 		AL,92H
	AND 	AL,0FDH		;0FDH = NOT 20H
	OUT		92H,AL
	POP		AX
	RET
DA20 	ENDP
```

## 10.4.2 演示32位代码段和16位代码段切换的实例(实例二)

实例二的逻辑功能是，==以十六进制数和ASCII字符两种形式显示从内存地址100000H开始的16个字节的内容==。
从功能上看本实例类似于实例一，但在实现方法上却有了改变，它更能反映出实方式和保护方式切换的情况。具体实现步骤是：

1. 作切换到保护方式的准备；

2. 切换到保护方式的个32位代码段；

3. 把指定内存区域的内容以字节为单位，转换成对应十六进制数的ASCII码，并直接填入显示缓冲区实现显示；

4. 再变换到保护方式下的一个16位代码段；

5. 把指定内存区域的内容直接作为ASCII码填入显示缓冲区实现显示；

6. 切换回实方式。


### 1.实例二源程序

实例二的源程序如下所示：

```assembly
;程序名：T10-2.ASM
;功能，演示实方式和保护方式切换
;说明，该程序使用TASM汇编
;16位偏移的段间转移指令的宏定义
JUMP16 MACRO selector,offsetv
           DB 0EAH        ;操作码，'Far Jump'指令
           DW offsetv     ;16位偏移
           DW selector    ;段值或者选择子
ENDM
;32位偏移的段间转移指令的宏定义
JUMP32 MACRO selector,offsetv
           DB 0EAH        ;操作码，'Far Jump'指令
           DW offsetv     ;32位偏移
           DW 0
           DW selector    ;选择子
ENDM
;存储段描述符结构类型的定义
DESCRIPTOR 	STRUC
		LIMITL		DW 0	;段界限(0~15)
		BASEL 		DW 0	;段基地址(0~15)
		BASEM		DB 0	;段基地址(16~23)
		ATTRIBUTES 	DW 0	;段属性
		BASEH		DB 0	;段基地址(24~31)
DESCRIPTOR 	ENDS
;GDTR伪描述符结构类型的定义
PDESC 	STRUC
		LIMIT 	DW 0	;16界限
		BASE	DD 0	;基地址
PDESC 	ENDS
;常量定义
ATDR	=	90H			;存在的只读数据段属性值
ATDW	=	92H			;存在的可读写数据段属性值
ATDWA	=	93H			;存在的已访问可读写数据段属性值
ATCE	=	98H			;存在的只执行代码段属性值
ATCE32 	=	4098H		;存在的只执行32位代码段属性值
DATALEN = 	16
;
		.386P
;----------------------------
;数据段
DSEG SEGMENT 	USE16                                                   ;16位段
               GDT    LABEL 		BYTE                                    ;全局描述符表
               DUMMY  DESCRIPTOR 	<>                                  ;空描述符
    ;0080h = 0000 0000 0000 1000 = 0000000000001 0 00
    ;表示r0环GDT中index = 1的描述符
    CODE32_SEL =      08H                                             ;32位代码段描述符选择子
    ;CODE32LEN-1是32位代码段实际长度作为界限
    ;基址为0h，后面再代码中设置
    ;属性为R032位只执行代码段
               CODE32 DESCRIPTOR 	<CODE32LEN-1,,,ATCE32,>
    CODE16_SEL =      10H                                             ;16位代码段描述符选择子
    ;0FFFFH是16位代码段指定界限
    ;基址为0h，后面再代码中设置
    ;属性为R0位只执行代码段
               CODE16 DESCRIPTOR 	<0FFFFH,,,ATCE,>
    DATAS_SEL  =      18H                                             ;源数据段描述符选择子
    ;DATALEN-1是指定长度 16 - 1 = 15 个字节作为界限
    ;基址为0FFFFFh
    ;属性为只读数据段
               DATAS  DESCRIPTOR 	<DATALEN-1,0FFFOH,0FH,ATDR,0>
    DATAD_SEL  =      20H                                             ;目标数据段描述符选择子
    ;DATALEN-1是指定长度 16 * 8 - 1 = 127 个字节作为界限
    ;基址为0000 000B 80A8h
    ;属性为可读可写数据段
               DATAD  DESCRIPTOR 	<DATALEN * 8-1,80A0H,0BH,ATDW.0>
    STACKS_SEL =      28H                                             ;堆栈段描述符选择子
    ;0FFFFH字节作为界限
    ;基址为0h，后面再代码中设置
    ;属性为可写可访问数据段
               STACKS DESCRIPTOR 	<0FFFFH,,,ATDWA,>
    NORMAL_SEL =      30H                                             ;规范段描述符选择子
    ;0FFFFH字节作为界限
    ;基址为0h
    ;属性为可读可写数据段
               NORMAL DESCRIPTOR 	<0FFFFH,0,0,ATDW,0>
    GDTLEN     =      $ - GDT
    ;
               VGDTR  PDESC 		<GDTLEN - 1,>                           ;GDT伪描述符
    VARSS      DW     ?                                               ;用于保存SS的变量
DSEG ENDS
;
;--------------------------------------
;实方式下的代码段
CSEG1 SEGMENT USE16 'REAL'
           ASSUME CS:CSEG1,DS:DSEG
    START: 
           MOV    AX,DSEG
           MOV    DS,AX                        ;代码段段值挪到ds中
    ;
           MOV    BX,16                        ;设置GDT的基地址
           MUL    BX                           ;将段值转换为物理地址
           ADD    AX,OFFSET GDT                ;找到GDT的地址
           ADC    DX,0
           MOV    WORD PTR VGDTR.BASE,AX
           MOV    WORD PTR VGDTR.BASE+2,DX     ;设置GDTR的基地址
    ;
           MOV    AX,CSEG2                     ;设置32位代码段的基地址
           MUL    BX                           ;找到32位代码段的物理地址
           MOV    CODE32.BASEL,AX
           MOV    CODE32.BASEM,DL
           MOV    CODE32.BASEH,DH              ;设置32位代码段基址
    ;
           MOV    AX,CSEG3                     ;设置16位代码段的基地址
           MUL    BX                           ;找到16位代码段的物理地址
           MOV    CODE16.BASEL,AX
           MOV    CODE16.BASEM,DL
           MOV    CODE16.BASEH,DH              ;设置16位代码段的基址
    ;
           MOV    AX,SS                        ;设置堆栈段的基地址
           MUL    BX                           ;找到堆栈段的物理地址
           MOV    STACKS.BASEL,AX
           MOV    STACKS.BASEM,DL
           MOV    STACKS.BASEH,DH              ;设置堆栈段的基地址
           MOV    VARSS,SS                     ;保存实方式下的SS
    ;
           LGDT   QWORD PTR VGDTR              ;装载GDTR
    ;
           CLI                                 ;关中断
           CALL   EA20                         ;打开地址线A20
           MOV    EAX,CR0                      ;切换到保护方式
           OR     EAX,1                        ;cr0,pe位设置为1
           MOV    CR0,EAX                      ;切换到保护模式
    ;进入32位代码段
           JUMP16 CODE32_SEL,<OFFSET SPM32>    ;跳到32位代码段SPM32标号处
    TOREAL:                                    ;现在又回到实方式
           MOV    AX,DSEG
           MOV    DS,AX
           MOV    SS,VARSS                     ;恢复实方式下的SS
           CALL   DA20                         ;关闭地址线A20
           STI
           MOV    AH,4CH
    ;结束
           INT    21H
	
EA20 PROC
    ;打开地址线A20
EA20 ENDP

DA20 PROC
    ;关闭地址线A20
DA20 ENDP

CSEG1 ENDS
	
	;32位代码段
CSEG2 SEGMENT USE32 	'PM32'
              ASSUME CS:CSEG2
    SPM32:    
              MOV    AX,STACKS_SEL                ;堆栈段选择子挪到AX中
              MOV    SS,AX                        ;装载堆栈段寄存器SS，SS当前保护模式下为堆栈段选择子
              MOV    AX,DATAS_SEL
              MOV    DS,AX                        ;装载源数据段寄存器DS，DS当前保护模式下为源数据段选择子
              MOV    AX,DATAD_SEL
              MOV    ES,AX                        ;装载目标数据段寄存器ES，ES当前保护模式下为目标数据段选择子
              XOR    ESI,ESI                      ;设置指针和计数器
              XOR    EDI,EDI
              MOV    ECX,DATALEN
              CLD
    NEXT:     
              LODSB                               ;取一字节
              PUSH   AX
              CALL   TOASCII                      ;低4位转换成ASCII
              MOV    AH,7                         ;显示属性为黑底白字
              SHL    EAX,16
              POP    AX
              SHR    AL,4
              CALL   TOASCII                      ;高4位转换成ASCII
              MOV    AH,7
              STOSD                               ;显示
              MOV    AL,''
              STOSW                               ;显示空格
              LOOP   NEXT
    ;变换到16位代码段
              JUMP32 CODE16_SEL,<OFFSET SPM16>
    ;
TOASCII PROC
    ;把AL低位转换成对应ASCH码
TOASCII ENDP
    CODE32LEN =      $
CSEG2 ENDS
;---------------------------------------
;16位代码段
CSEG3 SEGMENT USE16	'PM16'
          ASSUME CS:CSEG3
    SPM16:
          XOR    SI,SI             ;设置指针和计数器
          MOV    DI,DATALEN*3*2
          MOV    AH,7
          MOV    CX,DATALEN
    AGAIN:
          LODSB                    ;把指定区域内容直接
          STOSW                    ;作为ASCII码显示
          LOOP   AGAIN
    ;
          MOV    AX,NORMAL_SEL
          MOV    DS,AX             ;把NORMAL段选择子装入DS和ES
          MOV    ES,AX
          MOV    EAX,CR0           ;切换到实方式
          AND    EAX,OFFFFFFFEH    ;将PE位设置为0，切换到实模式
          MOV    CR0,EAX
    ;切换回到实方式
          JMP    FAR PTR TOREAL
CSEG3 ENDS
		END START
```

### 2. 关于实现步骤的注释

#### (1)切换到保护方式的准备工作

建立全局描述符表，这里的全局描述符表含有两个16位数据段的描述符、一个16位代码段的描述符和一个16位堆栈段的描述符。此外，`GDT`还有一个32位代码段的描述符，描述32位代码段，该描述符的属性字段中的D为是1。

#### (2)工作方式切换

由==实方式切换到保护方式32位代码段的方法与切换到保护方式16位代码段的方法相同==。由保护方式16位代码段切换回实方式的方法与实例一相似。
==在保护方式下，通过如下直接段间转移指令从32位代码段切换到16位代码==段：

```assembly
JUMP32 CODE16_SEL,<OFFSET SPM16>
```

==从该宏指令的定义可知，该转移指令含48位指针，其高16位是16位代码段的选择子，低32位是16位代码段入口偏移==。==该指令在32位方式下预取，在16位方式下执行==。==由于在32位方式下，所以要使用48位指针==。

#### (3)显示指定区域的内容

在本实例中，采用直接写显示缓冲区的方法实现显示。假设显示缓冲区的开始物理地址是B8000H,3号显示方式下，在屏幕的第2行上进行显示。

### 3. 特别说明

尽管本实例没有自己专用的堆栈段，但还是在原堆栈的基础上建立了堆栈段，所以在保护方式下使用了涉及堆栈操作的指令。
本实例仍作了大量的简单化处理。如：没有建立IDT和LDT等，各特权级均是0。也没有采用分页管理机制。
从本实例的GDT中可见，两个数据段的界限都是根据实际大小而设置的。==从源程序代码段`CSEG3`可见，在切换到实方式之前，把一个指向似乎没有用的数据段描述符`NORMAL`的选择子装载到`DS`和`ES`==。这是为什么呢？

![image] (https://github.com/YangLuchao/img_host/raw/master/20231127/image.3saa4dd3ug60.jpg)

在10.2.5节中已介绍过==每个段寄存器都配有段描述符高速缓冲寄存器，这些高速缓冲寄存器在实方式下仍发挥作用，只是内容上与保护方式下有所不同==。如表10.4所示，==其中`Y`表示`是`；`N`表示`否`；`B`表示字节；`U`表示向高扩展段；`W`表示字方式操作堆栈==。段基地址仍是32位，其值是相应段寄存器值(段值)乘16，在把段值装载到段寄存器时被刷新。==由于其值是16位段值乘上16，所以在实方式下基地址实际有效位只有20位。每个段的32位段界限都固定为`0FFFFH`，段属性的许多位也是固定的==。所谓固定是指在实方式下必须是表10.4中所列值。==但在实方式下，不可设置这些属性值，只能继续沿用保护方式下所设置的值==。==因此，在准备结束保护方式回到实方式之前，要通过加载一个合适的描述符的选择子到有关段寄存器，以使得对应段描述符高速缓冲寄存器中含有合适的段界限和属性==。==本实例GDT中的段描述符`NORMAL`就是这样的一个描述符，在返回实方式之前把对应选择子`NORMAL_SEL`加载到`DS`和`ES`就是为此目的==。由于`SS`段描述符中的内容已符合实方式的需要，所以尽管在也改变了`SS`后，但没有重新加载`SS`。16位代码段描述符中的内容也符合实方式的需要，所以在通过16位代码段返回时，CS段描述符高速缓冲寄存器中的内容也是符合要求的。顺便说一下，实例一的描述符都是符合实方式要求的。

### 4. 关于32位代码段程序设计的说明

在32位代码段中，缺省的操作数大小是32位，缺省的存储单元地址大小也是32位。由于串操作指令使用的指针寄存器是`ESI`和`EDI`，`LOOP`指令使用的计数器是`ECX`，所以，在代码段CSEG2中，为了使用串操作指令，对`ESI`和`EDI`等寄存器赋初值。请比较代码段CSEG3中的相关片段和实例一中的相关片段，它们是16位代码段。

# 10.5 任务状态段和控制门

==每个任务有一个任务状态段`TSS`，用于保存任务的有关信息，在任务内变换特权级和任务切换时，要使用这些信息==。==为了控制任务内发生特权级变换的转移，为了控制任务切换，一般要通过控制门进行这些转移==。本节介绍任务状态段和控制门。

## 10.5.1 系统段描述符

==系统段是为实现存储管理机制所使用的一种特别的段==。

在80386中，==有两种系统段：任务状态段`TSS`和局部描述符表`LDT`段==。==用于描述系统段的描述符称为系统段描述符，也称为特殊段描述符==。

### 1. 系统段描述符的一般格式

系统段描述符的一般格式如图10.12所示。与图10.5所示的存储段描述符相比，它们很相似，区分的标志是属性字节中的描述符类型位`DT`的值。==`DT=1`表示存储段，`DT=0`表示系统段==。系统段描述符中的段基地址和段界限字段与存储段描述符中意义完全相同；属性中的`G`位、`AVL`位、`P`位和`DPI`，字段的作用也完全相同。存储段描述符属性中的D位在系统段描述符中不使用，现用符号X表示。系统段描述符的类型字段`TYPE`仍是4位，其编码及表示的类型列于表10.5，其含义与存储段描述符的类型却完全不同。

![image](https://github.com/YangLuchao/img_host/raw/master/20231127/image.446p4nf8zmc0.jpg)

从表10.5可见，只有类型编码为2、1、3、9和B的描述符才是真正的系统段描述符，它们用于描述系统段`LDT`和任务状态段`TSS`，其它类型的描述符是门描述符。利用在10.2节中定义的存储段描述符结构类型`DESCRIPTOR`仍能方便地在程序中说明系统段描述符。

![image]（https://github.com/YangLuchao/img_host/raw/master/20231127/image.1b83gqg36ajk.jpg）

### 2. LDT段描述符

==LDT段描述符描述任务的局部描述符表段==。例如：如下描述符LDTABLE描述一个局部描述符表段，基地址是654321H，以字节为单位的界限是1FH，描述符特权级是0。

```assembly
LDTABLE DESCRIPTOR <1FH,4321H,65H,82H,0>
```

==LDT 段描述符必须安排在全局描述符表中才有效==。==在装载`LDTR`寄存器时，描述符中的`LDT`段基地址和段界限等信息被装入==如图10.9所示的==`LDTR`高速缓冲寄存器中==。

### 3. 任务状态段描述符

==任务状态段`TSS`用于保存任务的各种状态信息==。==任务状态段描述符描述某个任务状态段==。==`TSS`描述符分为`286TSS`和`386TSS`两类==。==`TSS`描述符规定了任务状态段的基地址和任务状态段的大小==。例如：如下描述符TEMPTASKS描述一个可用的386任务状态段，基地址是123456H，以字节为单位的界限是104，描述符特权级是0。

```assembly
MONTASKS DESCRIPTOR <104,3456H,12H,89H,0>
```

在装载任务状态段寄存器`TR`时，描述符中的`TSS`段基地址和段界限等信息被装入如图10.9所示的`TR`高速缓冲寄存器中。==在任务切换或执行`LTR`指令时，要装载`TR`寄存器==。
==`TSS`描述符中的类型规定：`TSS`要么为`忙`，要么为`可用`==。如果一个任务是当前正执行的任务，或者是用`TSS`中的链接字段沿挂起任务链接到当前任务上的任务，那么该任务是`忙`的任务；否则该任务为`可用`任务。利用段间转移指令`JMP`和段间调用指令`CALL`，直接通过`TSS`描述可实现任务切换。

## 10.5.2 门描述符

==除存储段描述符和系统段描述符外，还有一类门描述符==。==门描述符并不描述某种内存段，而是描述控制转移的入口点==。==这种描述符好比一个通向另一代码段的门==。==通过这种门，可实现任务内特权级的变换和任务间的切换==。==所以，这种门描述符也称为控制门==。

### 1.门描述符的一般格式

门描述符的一般格式如图10.13所示。门描述符只有位于描述符内偏移5的类型字节与系统段描述符保持一致，也由该字节标识门描述符和系统段描述符。==该字节内的`P`和`DPL`的意义与其他描述符中的意义相同==。==其它字节主要用于存放一个48位的全指针(16位的选择子和32位的偏移量)==。

![image]（https://github.com/YangLuchao/img_host/raw/master/20231127/image.6n50pygcozg0.jpg）

根据如图10.13给出的门描述符的结构，可定义如下的门描述符结构类型：

```assembly
GATE	STRUC	;门结构类型定义
	OFFSETL		DW	0	;32位偏移的低16位
	SELECTOR 	DW 	0 	;选择子
	DCOUNT		DB	0	;双字计数字段
	GTYPE 		DB 	0 	;类型
	OFFSETH		DW	0	;32位偏移的高16位
GATE 	ENDS
```

利用门描述符结构类型`GATE`能方便地在程序中说明门描述符。
例如，如下门描述符SUBRG描述一个386调用门，门内的选择子是10H，入口偏移是123456H，门描述符特权级是3，双字计数是0。

```assembly
SUBRG GATE <3456H,10H,0,8CH+60H,0012H>
```

从表10.5可见，==门描述符又可分为：任务门、调用门、中断门和陷阱门，并且除任务门外，其他门描述符还各分成286和386两种==。

### 2. 调用门

==调用门描述某个子程序的入口==。==调用门内的选择子必须指向代码段描述符，调用门内的偏移是对应代码段内的偏移==。==利用段间调用指令`CALL`，通过调用门可**实现任务内从外层特权级变换到内层特权级**==。
在图10.13所示门描述符内偏移4字节的位0至位4是双字计数字段，该字段只在调用门描述符中有效，在其它门描述符中无效。==主程序通常通过堆栈把入口参数传递给子程序，如果在利用调用门调用子程序时引起特权级的转换和堆栈的改变，那么就需要将外层堆栈中的参数复制到内层堆栈==。==该双字计数字段就是用于说明这种情况发生时，要复制的双字参数的数量==。

### 3. 任务门

 ==任务门指示任务== 。==任务门内的选择子必须指向`GDT`中的任务状态段`TSS`描述符，门中的偏移无意义==。==任务的入口点保存在`TSS`中==。==利用段间转移指令`JMP`和段间调用指令`CALL`，通过任务门可实现任务切换==

### 4. 中断门和陷阱门

==中断门和陷阱门描述中断/异常处理程序的入口点==。==中断门和陷阱门内的选择子必须指向代码段描述符，门内的偏移就是对应代码段的入口点偏移==。==中断门和陷阱门只有在中断描述符表`IDT`中才有效==。关于中断门和陷阱门的区别在10.7节中介绍。

## 10.5.3 任务状态段

==任务状态段(Task State Segment)是保存一个任务重要信息的特殊段==。==任务状态段描述符用于描述这样的系统段==。==任务状态段寄存器`TR`的可见部分含有当前任务的任务状态段描述符的选择子，`TR`的不可见部分含有当前任务状态段的段基地址和段界限等信息==。
==`TSS`在任务切换过程中起着重要作用，通过它实现任务的挂起和恢复==。所谓任务切换是指，挂起当前正在执行的任务，恢复另一个任务的执行。在任务切换过程中，首先，处理器中各寄存器的当前值被自动地保存到`TR`所指定的`TSS`中；然后，下一任务的TSS的选择子被装入`TR`;最后从`TR`所指定的`TSS`中取出各寄存器的值送到处理器的各寄存器中。==由此可见，通过在`TSS`中保存任务现场各寄存器状态的完整映象，实现任务的切换==。
任务状态段`TSS`的基本格式如图10.14所示。从中可见，==`TSS`的基本格式有104字节组成==。这104字节的基本格式是不可改变的，但在此之外系统软件还可定义若干附加信息。==基本的104字节可分为链接字段区域、内存堆栈指针区域、地址映射寄存器区域、寄存器保存区域和其它字段等五个区域==。

![image](https://github.com/YangLuchao/img_host/raw/master/20231127/image.5t74uepogls0.jpg)

### 1. 寄存器保存区域

==寄存器保存区域位于`TSS`内偏移`20H`至`5FH`处，用于保存通用寄存器、段寄存器、指令指针和标志寄存器==。==当`TSS`对应的任务正在执行时，保存区域是未定义的；在当前任务被切换出时，这些寄存器的当前值就保存在该区域==。==当下次切换回原任务时，再从保存区域恢复出这些寄存器的值，从而使处理器恢复成该任务换出前的状态，最终使任务能够恢复执行==。
从图10.14可见，各通用寄存器对应一个32位的双字，指令指针和标志寄存器各对应一个32位的双字；各段寄存器也对应一个32位的双字，段寄存器中的选择子只有16位，安排在双字的低16位，高16位空着未用。

### 2. 内层堆栈指针区域

==为了有效地实现保护，一个任务在不同的特权级下使用不同的堆栈==。例如，当从外层特权级3变换到内层特权级0时，任务使用的堆栈也同时从3级堆栈变换到0级堆栈，当从内层特权级0变换到外层特权级3时，任务使用的堆栈也同时从0级堆栈变换到3级堆栈。==所以，一个任务可能具有四个堆栈，对应四个特权级。四个堆栈需要四个堆栈指针==。

==`TSS`的内层堆栈指针区域中有三个堆栈指针，它们都是48位的全指针(16位的选择子和32位的偏移)，分别指向0级、1级和2级堆栈的栈顶，依次存放在`TSS`中偏移为4、12及20开始的位置==。==当发生向内层转移时，则把适当的堆栈指针装入到`SS`及`ESP`寄存器以变换到内层的堆栈，外层堆栈的指针保存在内层堆栈中==。没有指向3级堆栈的指针，因为3级是在最外层，所以任何一个向内层的转移都不可能转移到3级。
但是，当特权级由内层向外层变换时，并不把内层堆栈的指针保存到`TSS`的内层堆栈指针区域。这表明向内层转移时，总是把内层堆栈认为是一个空栈。因此，不允许发生同级内层转移的递归，一旦发生向某级内层转移，那么返回到外层的正常途径是相匹配的向外层返回。

### 3. 地址映射寄存器区域

==由虚拟地址空间到线性地址空间的映射由`GDT`和`LDT`确定，与特定任务相关的部分由`LDT`确定，而`LDT`又由`LDTR`确定==。==如果采用分页机制，那么由线性地址空间到物理地址空间的映射由包含页目录表起始物理地址的控制寄存器`CR3`确定==。所以，与==特定任务相关的虚拟地址空间到物理地址空间的映射由`LDTR`和`CR3`确定==。显然，==随着任务的切换，地址映射关系也要切换==。
==`TSS`的地址映射寄存器区域由位于偏移`1CH`处的双字字段(`CR3`)和位于偏移`60H`处的字字段(`LDT`)组成==。在任务切换时，处理器自动从轮到执行的任务的`TSS`中取出这两个字段，分别装入到寄存器`CR3`和寄存器`LDTR`。这样就改变了虚拟地址空间到物理地址空间的映射。
但是，在任务切换时，处理器并不把换出任务当时的寄存器`CR3`和`LDTR`的内容保存到`TSS`中的地址映射寄存器区域。因此，如果程序改变了`LDTR`或`CR3`,那么必须把新值保存到`TSS`中的地址映射寄存器区域相应字段中。

### 4. 链接字段

==链接字段安排在`TSS`内偏移0开始的双字中==，其高16位未用。==在起链接作用时，低16位保存前一任务的`TSS`描述符的选择子==。==如果当前的任务由段间调用指令`CALL`或者中断/异常而激活，那么链接字段保存被挂起任务的`TSS`的选择子，并且标志寄存器`EFLAG`中的`NT`位被置1，使链接字段有效。在返回时，由于NT位为1，中断返回指令`IRET`将使得控制沿着链接字段所指恢复到链上的前一个任务。==

### 5. 其它字段

==为了实现输入/输出保护，要使用`I/O`许可位图。任务使用的`I/O`许可位图也存放`TSS`中，作为`TSS`的扩展部分==。在`TSS`内偏移`66H`处的字用于存放`I/O`许可位图在`TSS`内的开始偏移。关于`I/O`许可位图的作用在10.9节中介绍。在`TSS`内偏移64H处的字是为任务提供的特别属性。在80386中，只定义了一种属性，即调试陷阱。该属性是字的最低位，用T表示。该字的其他位被保留，必须被置成0。发生任务切换时，如果进入任务的T位为1,那么在任务切换完成之后，新任务的第一条指令执行之前产生调试陷阱。

### 6. 用结构类型定义TSS

根据如图10.14给出的任务状态段TSS的结构，可定义如下的TSS结构类型：

```assembly
TASKSS 	STRUC
	DW 	?,0		;链接字
	DD 	?,0		;0级堆栈指针
	DW 	?,0
	DD 	? 		;1级堆栈指针
	DW 	?,0
	DD	? 		;2级堆栈指针
	DW 	?,0
	DD 	? 		;CR3
	DD 	? 		;EIP
	DW 	?,? 	;EFLAGS
	DD 	? 		;EAX
	DD	?		;ECX
	DD 	? 		;EDX
	DD 	? 		;EBX
	DD 	? 		;ESP
	DD 	? 		;EBP
	DD 	? 		;ESI
	DD 	? 		;EDI
	DW 	?,0 	;ES
	DW 	?,0 	;CS
	DW 	?,0 	;SS
	DW 	?,0 	;DS
	DW 	?,0 	;FS
	DW 	?,0 	;GS
	DW 	?,0 	;LDT
	DW 	0 		;TSS的特别属性字
	DW	$ + 2	;指向`I/O`许可位图区的指针
	DB	0FFH	;I/O许可位图结束字节
TASKSS 	ENDS
```

# 10.6 控制转移

==控制转移基本上可分为两大类：==

1. ==同一任务内的控制转移==
2. ==任务间的控制转移(任务切换)==

==同一任务内的控制转移又分为：==

1. ==段内转移==
2. ==特权级不变的段间转移==
3. ==特权级变换的段间转移==

==段内转移与实方式下相似，不涉及特权级变换和任务切换==。==只有段间转移才涉及特权级变换和任务切换==。本节介绍保护方式下的控制转移，重点是任务内的特权级变换和任务间的切换

## 10.6.1 任务内无特权级变换的转移

各种段内转移与实方式下相似，当然不涉及特权级变换和任务切换。只有各种形式的段间转移才涉及特权级变换和任务切换。

### 1. 段间转移指令

==与实方式下一样，指令`JMP`、`CALL`和`RET`都具有段间转移的功能，指令`INT`和`IRET`总是段间转移==。此外，中断/异常也将引起段间转移。有时把这些具有段间转移功能的指令统称为段间转移指令。
==在保护方式下，段间转移的目标位置由选择子和偏移构成的地址表示，常把它称为目标地址指针==。==在32位代码段中，上述指针内的偏移使用32位表示，这样的指针也称为48位全指针==。在实例二的32位代码段内就使用了48位全指针。在16位代码段中，上述指针内的偏移只使用16位表示。
==与实方式下相似，段间转移指令`JMP`和段间调用指令`CALL`还可分为段间直接转移和段间间接转移两类==。==如果指令`JMP`和`CALL`在指令中直接含有目标地址指针，那么就是段间直接转移==；==如果指令中含有指向包含目标地址指针的门描述符或`TSS`描述符的==
==指针，那么就是段间间接转移==，==这种指针只有选择子部分有效，指示调用门、任务门或`TSS`描述符，而偏移部分不起作用==。实际上，==当段间转移指令`JMP`和段间调用指令`CALL`所含指针的选择子部分指示代码段描述符，那么就是段间直接转移，偏移部分表示目标代码段的入口点==；==当选择子部分指示门描述符或`TSS`描述符时，就是段间间接转移==。

### 2. 向目标代码段转移的步骤

处理器在执行上述段间转移指令向目标代码段实施转移的过程中，一般至少要经过如下步骤：

1. ==判别目标地址指针内的选择子指示的描述符是否为空描述符==。空描述符是`GDT`中的第0个描述符，是一个特殊的描述符。目标代码段描述符不能为空描述符，也即选择子的高14位不能为0。
2. ==从全局或者局部描述符表内读出目标代码段描述符==。由选择子内的`TI`位，确定使用全局描述符表还是局部描述表。
3. 根据情况，检测描述符类型是否正确；调整`RPL`。
4. 把目标代码段描述符内的有关内容装载到`CS`高速缓冲寄存器。
5. 判别目标地址指针内的偏移是否越出代码段。==目标地址指针内的偏移必须不超过目标代码段界限==
6. 装载`CS`段寄存器和指令指针寄存器`EIP`；`CPL`存入`CS`内选择子的`RPL`字段。

上述步骤只是对转移过程的简单说明，实际的动作还要复杂。==在把目标代码段描述符内的有关内容装载到`CS`高速缓冲寄存器时，还要进行如下保护检测，其中的`DPL`表示目标代码段描述符特权级==：

1. ==对于非一致代码段，要求CPL = DPL，RPL <= DPL；对于一致代码段，要求CPI = DPL==。
2. ==代码段必须存在，即描述符中的P位必须为1==。

通常描述符特权级`DPL`规定了对应段的特权级。如果描述符描述的是数据段，那么`DPL`就规定了访问该数据段的最外层特权级；如果描述符描述的是代码段，那么`DPL`就规定了执行该代码段所需要的`CPL`。但从上述装载`CS`高速缓冲寄存器时进行的保护检测可见，对于一致代码段，却要求`CPL>=DPL`，也就是说，一致代码段描述符中的`DPL`规定可以转移到一致的代码段的最内层特权级。于是，3级的程序可以转移到任何一致的代码段，而0级的程序只允许转移到`DPL`等于0的一致代码段。一致代码段描述符内`DPL`的这种解释，正好与正常的`DPL`的解释相反。
一致的可执行段是一种特别的存储段。这种存储段，为在多个特权级执行的程序，提供对子例程的共享支持，而不要求改变特权级。例如，通过把数值库例程放在一致的代码段中，可以使不同级执行的程序共享数值库例程。这样，任何特权级的程序可以使用段间调用指令，调用库中的例程，并在调用者所具有的特权级执行该例程。

### 3. 任务内无特权级变换的转移

==所谓任务内无特权级变换的转移指：在转移到新的代码段时，当前特权级`CPL`保持不变==。利用段间转移指令`JMP`、段间调用指令`CALL`和段间返回指令`RET`可实现任务内无特权级变换的转移。利用`INT`指令和`IRET`指令也可实现任务内无特权级变换的转移。

#### (1)利用段间直接转移指令JMP或CALL

在执行段间转移指令`JMP`时，如果指令内所含指针指示一个代码段，那么就直接开始上述向目标代码段转移的步骤；在执行段间调用指令`CALL`时，如果指令内所含指针指示一个代码段，那么就把返回地址指针压入堆栈，然后就直接开始上述向目标代码段转移的步骤。顺利通过这几步(不调整`RPL`)，就完成了任务内无特权级变换的转移。
由此可见，利用段间直接转移指令`JMP`或调用指令`CALL`可方便地进行任务内无特权级变换的转移，但不能进行任务内特权级变换的转移。

#### (2)利用段间返回指令RET

在执行段间返回指令`RET`时，如果从堆栈中弹出的目标地址指针指示一个代码段，并且选择子符合`RPL==CPL`的条件，那么就开始上述向目标代码段转移的步骤。顺利通过这几步，就完成了任务内无特权级变换的转移。
通常情况下，段间返回指令`RET`与段间调用指令`CALL`对应。在利用段间调用指令`CALL`以任务内无特权级变换的方式转移到某个子程序后，在子程序内利用段间返回指令RET以任务内无特权级变换的方式返回主程序。由于调用时无特权级变换，所以返回时也无特权级变换，如果真是如此，那么必定能够满足条件`RPL==CPL`。

#### (3)利用调用门和其他途径

如何利用调用门实现任务内无特权级变换的转移在10.6.3节中介绍。其他实现任务内无特权级变换的途径在10.7节中介绍。

### 4. 装载数据段和堆栈段寄存器时的特权检测

上面简单地说明了把选择子装入代码段寄存器`CS`时为实现保护而进行的检测，下面也简单地说明在把选择子装入数据段寄存器和堆栈段寄存器时要进行的检测。
在把选择子装入数据段寄存器`DS`、`ES`、`FS`或`GS`时，要进行如下检测：

1. 选择子不能为空；
2. 选择子指定的描述符必须是数据段描述符、可读可执行的代码段或一致的可读可执行代码段；
3. 对于数据段和可读可执行代码段，要求`CPL<=DPL`，`RPL<=DPL`;
4. 对应段必须存在。

在把选择子装入堆栈段寄存器`SS`时要进行如下检测：

1. 选择子不能为空；
2. 选择子指定的描述符必须是可读可写数据段描述符：
3. 要求`CPL=RPL-DPL`;
4. 对应段必须存在。

## 10.6.2 演示任务内无特权级变换转移的实例(实例三)

在实例二中，32位代码段到16位代码段的转移就是任务内无特权级变换转移的例子。

下面再给出一个用于演示==任务内无特权级变换转移的实例==。==该实例使用了段间转移指令`JMP`、段间调用指令`CALL`和段间返回`RET`指令实现同一任务内相同特权级转移==。
该实例还建立并使用了局部描述符表`LDT`。

### 1.实现步骤和源程序

实现步骤如下：

1. 实方式下初始化，包括对`GDT`和演示任务`LDT`的初始化，装载`GDTR`;
2. 从实方式切换到保护方式，处于0特权级；
3. 装载`LDTR`，并设置堆栈；
4. 利用段间转移指令`JMP`实现从代码段K到同级代码段L的转移；
5. 利用段间`CALL`指令调用同级代码段C中的子程序D显示字符串信息；
6. 利用段间`CALL`指令调用同级代码段C中的子程序H把十六进制数转换成对应的ASCII码；
7. 再利用段间`CALL`指令调用同级代码段C中的子程序D显示字符串信息；
8. 利用段间转移指令`JMP`实现从代码段L到代码段K的转移；
9. 从保护方式切换到实方式；
10. 在实方式下结束。
    该实例的逻辑功能是用十六进制数的形式显示代码段`L`的段界限值。源程序如下：

```assembly
;程序名：T10-3.ASM
;演示任务内无特权级变换的转移
;INCLUDE 386SCD.ASM
;文件386SCD.ASM含有关结构、
;宏指令和符号常量的定义
INCLUDE 386SCD.ASM
	.386P
;---------------------------------
;常量定义
ATDR	=	90H			;存在的只读数据段属性值
ATDW	=	92H			;存在的可读写数据段属性值
ATDWA	=	93H			;存在的已访问可读写数据段属性值
ATCE	=	98H			;存在的只执行代码段属性值
ATCE32 	=	4098H		;存在的只执行32位代码段属性值
DATALEN = 	16
ATLDT	=	82H			;局部描述符(系统段)表段类型值
;全局描述符表
GDTSEG SEGMENT 	PARA 	USE16 	'GDT'
               GDT     LABEL 	BYTE
               DUMMY   DESCRIPTOR	<>                        ;空描述符
    ;规范数据段描述符，刷缓冲区寄存器用
               NORMAL  DESCRIPTOR 	<0FFFFH,0,0,ATDW,0>
    ;R0环数据段index = 1 的描述符
    ;描述符内容为，段界限为FFFFH，基址为0h，属性为R0位可读写数据段
    NORMAL_SEL =       NORMAL - GDT
    ;代码段K的描述符
               CODEK   DESCRIPTOR 	<0FFFFH,,,ATCE,>
    ;R0环代码段index = 2 的描述符
    ;描述符内容为，段界限为FFFFH，基址为0h，属性为R0位只执行代码段
    CODEK_SEL  =       CODEK - GDT
    ;局部描述符表段的描述符
               LDTABLE DESCRIPTOR 	<LDTLEN - 1,,,ATLDT,>
    ;LDT段index = 3 的描述符
    ;描述符内容为，段界限为LDTLEN - 1，基址为0h，属性为LDT段地址
    LDT_SEL    =       LDTABLE - GDT
    GDTLEN     =       $
GDTSEG ENDS
;-----------------------------------
;演示任务局部描述符表
LDTSEG SEGMENT 	PARA 	USE16 	'LDT'
              LDT       LABEL 	BYTE

    ;代码段L描述符
    ;描述符内容为，段界限为CODELLEN - 1，基址为CODELSEG段，属性为R0只执行代码段
              CODEL     DESCRIPTOR 	<CODELLEN - 1,CODELSEG,,ATCE,>
    ;代码段L选择子，一个描述符的长度位8h,64位，所以CODEL - LDT = 0 * 8 = 0h + 4h = 04h
    ;04H = 0000 0000 0000 1100 = 0000000000000 1 00
    ;TI=0，为LDT描述符，该选择子含义为，在LDT中，index = 0 的描述符
    CODEL_SEL =         (CODEL - LDT) + TIL                               ;TIL=4h


    ;代码段C描述符
    ;描述符内容为，段界限为CODECLEN - 1，基址为CODECSEG段，属性为R0只执行代码段
              CODEC     DESCRIPTOR 	<CODECLEN - 1,CODECSEG,,ATCE,>
    ;代码段C选择子,一个描述符的长度位8h,64位，所以CODEL - LDT = 1 * 8 = 8h + 4h = 0Ch
    ;0C = 0000 0000 0000 1100 = 0000000000000 1 00
    ;TI=0，为LDT描述符，该选择子含义为，在LDT中，index = 1 的描述符
    CODEC_SEL =         (CODEC - LDT) + TIL


    ;显示缓冲区段描述符
    ;描述符的含义为，段界限为OFFFFH，基址为0h，属性为R0可读写数据段
              VIDEOBUFF DESCRIPTOR <OFFFFH,0,0,0F00H+ATDW,0>
    ;显示缓冲区段选择子,一个描述符的长度位8h,64位，所以VIDEOBUFF - LDT = 2 * 8 = 10h + 4h = 14h
    ;14 = 0000 0000 0001 0100 = 0000000000010 1 00
    ;TI=0，为LDT描述符，该选择子含义为：在LDT中，index = 2 的描述符
    VIDEO_SEL =         (VIDEOBUFF - LDT) + TIL


    ;演示任务LDT别名段描述符(DPL=3)
    ;描述符的含义为，段界限为LDTLEN - 1，基址为LDTSEG标号地址，属性为R3只读数据段
              TOLDT     DESCRIPTOR <LDTLEN - 1,LDTSEG,,ATDR+DPL3,>
    ;演示任务LDT别名段选择子，一个描述符的长度位8h,64位，所以TOLDT - LDT = 3 * 8 = 18h + 4h = 1Ch
    ;1C = 0000 0000 0001 1100 = 0000000000011 1 00
    ;TI=0，为LDT描述符，该选择子含义为：在LDT中，index = 3 的描述符
    TOLDT_SEL =         (TOLDT - LDT) + TIL


    ;显示信息缓冲区段描述符(DPL=3)
    ;描述符的含义为，段界限为MDATALEN - 1，基址为MDATASEG标号地址，属性为R3可读写数据段
              MDATA     DESCRIPTOR <MDATALEN - 1,MDATASEG,,ATDW+DPL3,>
    ;显示信息缓冲区段选择子，一个描述符的长度位8h,64位，所以MDATA - LDT = 4 * 8 = 20h + 4h = 24h
    ;24 = 0000 0000 0010 0100 = 0000000000100 1 00
    ;TI=0，为LDT描述符，该选择子含义为：在LDT中，index = 4 的描述符
    MDATA_SEL =         (MDATA-LDT) + TIL + RPL3


    ;堆栈段描述符
    ;描述符的含义为，段界限为TOPOFS - 1，基址为STACKSEG标号地址，属性为R0可读写数据段
              STACKS    DESCRIPTOR <TOPOFS - 1,STACKSEG,,ATDWA,>
    ;堆栈段选择子，一个描述符的长度位8h,64位，所以STACKS - LDT = 5 * 8 = 28h + 4h = 2Ch
    ;2C = 0000 0000 0010 1100 = 0000000000101 1 00
    ;TI=0，为LDT描述符，该选择子含义为：在LDT中，index = 5 的描述符
    STACK_SEL =         (STACKS - LDT) + TIL

    ;LDT含描述符个数
    LDNUM     =         ($ - LDT)/(SIZE DESCRIPTOR)
    ;LDT字节长度
    LDTLEN    =         $ - LDT
LDTSEG ENDS
;------------------------------------------
;显示信息缓冲区段
MDATASEG SEGMENT 	PARA 	USE16 	'MDATA'
    MESSAGE  DB 'Value=',0
    BUFFER   DB 80 DUP (0)
    MDATALEN =  $
MDATASEG ENDS
;--------------------------------------------
;演示任务堆栈段
STACKSEG SEGMENT 	PARA 	USE16	'STACK'
             DW 512 	DUP (0)
    TOPOFS   =  $
STACKSEG ENDS
;演示任务代码段C(含子程序D和子程序H)
CODECSEG SEGMENT 	PARA 	USE16 	'CODEC'
             ASSUME CS: CODECSEG
    ;显示信息子程序D
    ;人口参数:	 FS:SI指向要显示字符串，字符串以0结束
    ;			ES:EDI指向显示缓冲区
DISPMESS PROC 	FAR
             MOV    AH,7
    DISP1:   
             MOV    AL,FS:[SI]
             INC    SI
             OR     AL,AL
             JZ     DISP2           ;判断原始字符串是否结束，结束退出函数
             MOV    ES:[EDI],AX     ;将目标地址字符挪到缓冲区中，显示字符
             INC    EDI
             INC    EDI
             JMP    DISP1
    DISP2:   
             RET
DISPMESS ENDP
    ;
    ;子程序H,把一位十六进制数转换成对应字符的ASCII码
HTOASC PROC 	FAR
             AND    AL,0FH
             ADD    AL,90H
             DAA
             ADC    AL,40H
             DAA
             RET
HTOASC ENDP
    CODECLEN =      $

CODECSEG ENDS
;-------------------------------------
;演示任务代码段L
CODELSEG SEGMENT 	PARA 	USE16 	'CODEL'
             ASSUME CS:CODELSEG
    VIRTUAL2:
             MOV    AX,VIDEO_SEL
             MOV    ES,AX                   ;设置显示缓冲区指针
             MOV    EDI,0B8000H             ;显示缓冲区地址
    ;
             MOV    AX,MDATA_SEL
             MOV    FS,AX                   ;设置提示信息缓冲区指针
             MOV    SI,OFFSET MESSAGE
    ;
             CALL16 CODEC_SEL,DISPMESS      ;显示提示信息
    ;
             MOV    AX,TOLDT_SEL            ;把演示任务的LDT的
             MOV    GS,AX                   ;别名段的描述符选择子装入GS
    ;
             MOV    DX,GS:CODEL.LIMIT       ;取代码段L的段界限值挪到DX中
             MOV    SI,OFFSET BUFFER        ;并转成对应可显示字符串
             MOV    CX,4
    VIR:     
             ROL    DX,4
             MOV    AL,DL
             CALL16 CODEC_SEL,HTOASC        ;转换出ASCII码
             MOV    FS:[SI],AL
             INC    SI
             LOOP   VIR
             MOV    WORD PTR FS:[SI],'H'
    ;
             MOV    SI,OFFSET BUFFER
             CALL16 CODEC_SEL,DISPMESS      ;显示转换出的字符申
    ;
             JUMP16 CODEK_SEL,VIRTUAL3      ;跳转到代码段K
    CODELLEN =      $
CODELSEG ENDS
;------------------------------------------------
;演示任务代码段K
CODEKSEG SEGMENT 	PARA 	USE16 'CODEK'
             ASSUME CS:CODEKSEG
    VIRTUAL1:
             MOV    AX,LDT_SEL                  ;将LDT段的描述符选择子装入AX
             LLDT   AX                          ;装载局部描述符表寄存器LDTR
    ;
             MOV    AX,STACK_SEL                ;将LDT中的STACK_SEL选择子挪到SS中
             MOV    SS,AX                       ;建立演示任务堆栈
             MOV    SP,OFFSET TOPOFS            ;设置栈顶
    ;
             JUMP16 CODEL_SEL,VIRTUAL2          ;跳转到代码段L的VIRTUAL2偏移处
    VIRTUAL3:
             MOV    AX,NORMAL_SEL               ;准备返回实方式
             MOV    ES,AX
             MOV    FS,AX
             MOV    GS,AX
             MOV    SS,AX                       ;恢复各个段寄存器
             MOV    EAX,CR0
             AND    EAX,0FFFFFFFEH              ;将PE位置0
             MOV    CR0,EAX                     ;返回实模式
    ;返回实方式
             JUMP16 <SEG REAL>,<OFFSET REAL>
    CODEKLEN =      $
CODEKSEG ENDS
;-------------------------------------------------
;实方式数据段
RDATASEG SEGMENT 	PARA 	USE16
             VGDTR PDESC 	<GDTLEN-1,>    ;GDT伪描述符
    SPVAR    DW    ?                     ;保存实方式下堆栈指针
    SSVAR    DW    ?
RDATASEG ENDS
;-------------------------------------------------
;实方式代码段
RCODESEG SEGMENT 	PARA 	USE16
              ASSUME CS:RCODESEG
    START:    
              ASSUME DS:GDTSEG
              MOV    AX,GDTSEG                        ;GDT挪到AX中
              MOV    DS,AX                            ;GDT挪到DS中
    ;初始化全局描述符表
              MOV    BX,16
              MOV    AX,CODEKSEG
              MUL    BX                               ;找到CODEKSEG的物理地址
              MOV    CODEK.BASEL,AX                   ;设置代码段K基地址
              MOV    CODEK.BASEM,DL
              MOV    CODEK.BASEH,DH
              MOV    AX,LDTSEG                        ;LDT段挪到AX中
              MUL    BX                               ;计算LDT段的物理地址
              MOV    LDTABLE.BASEL,AX                 ;设置LDT段基址
              MOV    LDTABLE.BASEM,DL
              MOV    LDTABLE.BASEH,DH
    ;设置GDT伪描述符
              ASSUME DS:RDATASEG
              MOV    AX,RDATASEG                      ;实方式下数据段标号挪到AX中
              MOV    DS,AX                            ;实方式下数据段标号挪到DS中
              MOV    AX,GDTSEG                        ;GDT段标号挪到AX中
              MUL    BX                               ;计算GDT段的物理地址
              MOV    WORD PTR VGDTR.BASE,AX           ;设置GDTR的基地址低16位
              MOV    WORD PTR VGDTR.BASE+2,DX         ;设置GDTR的基地址高16位
    ;初始化演示任务LDT
              CLD                                     ;清空方向
              CALL   INIT_MLDT                        ;初始化LDT中各段的基址
    ;保存实方式堆栈指针
              MOV    SSVAR,SS
              MOV    SPVAR,SP
    ;装载GDTR
              LGDT   QWORD PTR VGDTR                  ;将定义的VGDTR挪到GDTR寄存器中
              CLI                                     ;关中断
    ;切换到保护方式
              MOV    EAX,CR0
              OR     EAX,1
              MOV    CR0,EAX                          ;置PE=1，切换到保护模式
    ;跳到CODEK段的VIRTUAL1标号偏移处
              JUMP16 <CODEK_SEL>,<OFFSET VIRTUAL1>
    REAL:                                             ;又回到实方式
              LSS    SP,DWORD PTR SPVAR               ;恢复实方式堆栈指针
              STI                                     ;开中断
              MOV    AX,4C00H                         ;结束
              INT    21H
    ;初始化演示任务LDT的子程序
INIT_MLDT PROC
              PUSH   DS                               ;实现无特权集转换任务内切换，push ds
              MOV    AX,LDTSEG                        ;LDTSEG标号挪到AX中
              MOV    DS,AX                            ;LDTSEG标号挪到DX中
              MOV    CX,LDNUM                         ;描述符个数挪到CX中
              MOV    SI,OFFSET LDT                    ;LDT偏移为起始地址
    INITL:    
              MOV    AX,[SI].BASEL                    ;代码段L基地址低16位挪到AX中
              MOVZX  EAX,AX                           ;代码段L基地址低16位挪到EAX中，高位补0
              SHL    EAX,4                            ;代码段L基地址低16位挪到EAX中，高位补0，并左移4位
              SHLD   EDX,EAX,16                       ;将代码段L基地址高16位挪到EDX中
              MOV    [SI].BASEL,AX                    ;初始化LDT中各段的基址
              MOV    [SI].BASEM,DL
              MOV    [SI].BASEH,DH
              ADD    SI,SIZE DESCRIPTOR
              LOOP   INITL
              POP    DS
              RET
INIT_MLDT ENDP
RCODESEG ENDS
	END START
```

### 2.  被包含文件386SCD.ASM

为了节省篇幅，把有关结构类型的定义、宏指令的定义和符号常量的定义等语句集中在一个文件中，以便供每个实例程序使用。

```assembly
;文件名：386SCD.ASM
;内容：符号常量等的定义
;------------------------------------------------
;存储段描述符/系统段描述符结构类型的定义
DESCRIPTOR 	STRUC
	LIMIT		DW	0		;段界限(0~15)
	BASEL		DW 	0		;段基地址(0~15)
	BASEM 		DB 	0 		;段基地址(16~23)
	ATTRIBUTES 	DW  0		;段属性
	BASEH 		DB 	0 		;段基地址(24~31)
DESCRIPTOR ENDS
;------------------------------------------------
;门描述符结构类型的定义
;门结构类型定义
GATE		STRUC		
	OFFSETL		DW	0		;32位偏移的低16位
	SELECTOR 	DW 	0 		;选择子
	DCOUNT 		DB 	0 		;双字计数字段
	GTYPE		DB	0		;类型
	OFFSETH		DW	0		;32位偏移的高16位
GATE		ENDS
;-----------------------------------------------
;伪描述符结构类型的定义
PDESC 		STRUC
	LIMIT		DW 	16 		;界限
	BASE		DD	0 		;基地址
PDESC		ENDS
;------------------------------------------------
;任务状态段TSS结构类型的定义
TASKSS 		STRUC
	TRLINK		DW	?,0		;链接字
	TRESP0		DD	?		;0级堆栈指针
	TRSS0		DW 	?,0
	TRESP1		DD	?		;1级堆栈指针
	TRSS1		DW 	?,0
	TRESP2		DD	?		;2级堆栈指针
	TRSS2		DW 	?,0
	TRCR3		DD 	? 		;CR3
	TREIP		DD 	? 		;EIP
	TREFLAG 	DW 	?,? 	;EFLAGS
	TREAX		DD 	? 		;EAX
	TRECX		DD 	? 		;ECX
	TREDX		DD 	? 		;EDX
	TREBX		DD 	? 		;EBX
	TRESP		DD 	? 		;ESP
	TREBP		DD 	? 		;EBP
	TRESI		DD 	? 		;ESI
	TREDI		DD 	? 		;EDI
	TRES		DW	?,0		;ES
	TRCS		DW 	?,0		;CS
	TRSS		DW 	?,0 	;SS
	TRDS		DW 	?,0 	;DS
	TRFS		DW 	?,0 	;FS
	TRGS		DW 	?,0 	;GS
	TRLDT		DW 	?,0 	;LDT
	TRFLAG		DW	0		;TSS的特别属性字
	TRIOMAP		DW	$ + 2	;指向1/0许可位图区的指针
TASKSS ENDS
;-----------------------------------------------------
;存储段描述符类型值说明
;   属性9XH，就是R0，有效存储段描述符
;   属性8XH，就是R0，有效的系统段、门描述符
ATDR 		=		90H		;存在的只读数据段类型值
ATDW		=		92H		;存在的可读写数据段类型值
                            ;0092H的二进制表示为：0000 0000 1001 0010
                            ;0 0 0 0    0000    1 00    1   0010
                            ;G D 0 AVL  LIMIT   P DPL   DT  TYPE
                            ;G=0:界限粒度为字节
                            ;P=1表示描述符对地址转换是有效
                            ;DPL表示描述符特权级
                            ;DT=1，段储存描述符
                            ;TYPE，位3=0，位2=0，位1=1，位0=1
                            ;位1=1，W=1表示可写
                            ;位3=0，数据段
                            ;所以0092H的含义是：R0可读写数据段
ATDWA		=		93H		;存在的已访问可读写数据段类型值
ATCE		=		98H		;存在的只执行代码段类型值
ATCER		=		9AH		;存在的可执行可读代码段类型值
ATCCO		=		9CH		;存在的只执行一致代码段类型值
ATCCOR 		=		9EH		;存在的可执行可读一致代码段类型值
;系统段描述符和门描述符类型值说明
ATLDT		=		82H		;局部描述符表段类型值
                            ;82H的二进制表示为：0000 0000 1000 0010
                            ;0 0 0 0    0000    1 00    0   0010
                            ;G D 0 AVL  LIMIT   P DPL   DT  TYPE
                            ;G=0:界限粒度为字节
                            ;P=1表示描述符对地址转换是有效
                            ;DPL表示描述符特权级
                            ;DT=0，表示系统段描述符或门描述符
                            ;TYPE，位3=0，位2=0，位1=1，位0=0
                            ;位1=1，W=1表示可写
                            ;所以82H的含义是：LDT系统段描述符
ATTASKGAT	=		85H		;任务门类型值
AT386TSS	=		89H		;386TSS类型值
AT386CGAT 	=		8CH		;386调用门类型值
AT386IGAT	=		8EH		;386中断门类型值
AT386TGAT	=		8FH		;386陷阱门类型值
;DPL和RPL值说明
DPL1		=		20H		;DPL=1
DPL2		=		40H		;DPL=2
DPL3		= 		60h		;DPL=3

RPL1 		= 		01H		;RPL=1
RPL2 		= 		02H 	;RPL=2
RPL3 		= 		03H 	;RPL=3

IOPL1 		= 		1000H 	;IOPL=1
IOPL2 		= 		2000H 	;IOPL=2
IOPL3	 	= 		3000H 	;IOPL = 3
;其他常量值说明
D32			=		4000H	;32位代码段标志
TIL			=		04H		;TI=1(描述符表标志)
VMFL		= 		0002H 	;VMF=1
IFL			= 		0200H 	;IF=1
;------------------------------------------------
;32位偏移的段间转移宏指令
JUMP32 MACRO 	selector,offsetv
           DB 0EAH        ;操作码,Far Jump
           DW offsetv     ;32位偏移
           DW 0
           DW selector    ;选择子
ENDM
;-------------------------------------------------
;32位偏移的段间调用宏指令
CALL32 MACRO 	selector, offsety
           DB 09AH        ;操作码,CALL
           DW offsetv     ;32位偏移
           DW 0
           DW selector    ;选择子
ENDM
;------------------------------------------------
;16位偏移的段间转移宏指令
JUMP16 MACRO 	selector,offsetv
           DB 0EAH        ;操作码,Far Jump
           DW offsetv     ;16位偏移
           DW selector    ;段值/选择子
ENDM
;-----------------------------------------------
;16位偏移的段间调用宏指令
CALL16 MACRO 	selector,offsetv
           DB 09AH        ;操作码，call
           DW offsetv     ;16位偏移
           DW selector    ;段值/选择子
ENDM
```

### 3. 关于实例三的说明

有些步骤的实现方法已在前面的实例中做过介绍，下面就任务内无特权级变换的转移和使用局部描述符`LDT`等作些说明：

#### (1)实方式下初始化LDT

演示任务使用了局部描述符表`LDT`，该`LDT`在实方式下初始化。为了简便，`LDT`中各描述的界限和属性值在定义时预置，利用一个子程序设置各段的段基地址。为了方便，在定义时把各段的段值安排在相应描述符的段基地址低16位字段中。由于实例中各段性实方式下定位，所以把段值乘16就是对应的段基地址。

#### (2)装载LDTR寄存器

在使用`LDT`之前，还要装载局部描述符表寄存器`LDTR`。本实例中的如下两条指令用于装载`LDTR`:

```assembly
MOV		AX,LDT_SEL
LLDT 	AX
```

==LLDT指令是专门用于装载LDTR的指令==。该指令的操作数是对应`LDT`段描述符的选择子。根据该选择子，处理器从`GDT`中取出相应的`LDT`段描述符，在进行合法性等检查后，`LDT`段描述符的基地址和界限等信息被装入`LDTR`的高速缓冲寄存器中。由于要引用`GDT`，所以不能在实方式下装载`LDTR`。在10.8节中对LLDT指令作详细说明。

#### (3)利用段间转移指令JMP实现任务内无特权级变换的转移

==在本实例中进入保护方式后，特权级是0==。通过如下段间直接转移指令实现从代码段K到代码段L的转移：

```assembly
JUMP16 CODEL_SEL.VIRTUAL
```

其中，==选择子`CODEL_SEL`是对应代码段L的描述符的选择子==。该描述符在`LDT`中，所以选择子中的描述符表指示位TI是1。描述符特权级是0，表示对应代码段的特权级是0，选择子中的请求特权级RPL也是0。目标代码段不是一致代码段，所以在`CP=DPL`，`RPL<=DPL`的情况下，顺利进行相同特权级的转移；目标代码段的选择子CODEL_SEL被装入`CS`，对应描述符中的信息被装入高速缓冲寄存器，偏移VIRTUAL2被装入指令指针寄存器。由于是16位代码段，所以偏移用16位表示。类似地，通过如下段间直接转移指令实现从代码段L转移到代码段K:

```assembly
JUMP16 CODEK_SEL,VIRTUAL
```

其中，选择子CODEK_SEL是对应代码段K的描述符的选择子。由于描述符在`GDT`中，所以选择子中的TI位是0。

#### (4)利用段间调用指令CALL实现任务内无特权级变换的转移

在代码段L中，通过段间直接调用指令`CALL`调用了在代码段C中的两个子程序，这些调用都是无特权级变换的转移。
例如：利用如下指令调用了显示字符串子程序DISPMESS:

```assembly
CALL16 CODEC_SEL,DISPMESS
```

其中，CODEC_SEL是代码段C的选择子，DISPMESS表示子程序入口。描述代码段C的描述符在`LDT`中，描述符特权级DPL是0,所以使用的选择子CODE_SEL的请求特权级RPL是0,描述符表指示位T1是1。目标代码段C不是一致代码段，所以在`CPL=DPL`，`RPL<=DPL`的情况下，顺利进行相同特权级的转移：==当前`CS`和`IP`压入堆栈，目标代码段的选择子CODEC_SEL被装入CS,对应描述符中的信息被装入高速缓冲寄存器，16位偏移DISPMESS被装入指令指针==。由于是16位段，所以偏移用16位表示，压入堆栈的是字而不是双字。

#### (5)段间返回指令RET实现任务内无特权级变换的转移

段间返回指令RET从堆栈弹出返回地址(由选择子和偏移构成)。弹出选择子内的`RPL=CPL`，并且对应`DPL=CPL`，`RPL<=DPL`是当然的，所以能顺利进行相同特权转移。

### 4. 别名技术

在上述实例三中，使用了两个描述符来描述演示任务的`LDT`段。描述符LDTABLE被安排在`GDT`中，它是系统段描述，把段LDTSEG描述成演示任务的局部描述符表`GDT`。描述符TOLDT被安排在`LDT`中，它是数据段描述符，把段LDTSEG描述成一个普通的数据段。描述符LDTABLE被装载到`LDTR`，描述符TOLDT被装载到某个数据段寄存器。为什么要这样处理呢？根据实例三的功能要求，需要访问演示任务的局部描述符表`LDT`段，以取得代码段L的段界限值，这需要通过某个段寄存器进行，但不能把系统段描述选择子装载到段寄存器，所以采用两个描述符来描述段LDTSEG。
这种为了满足对同一个段实施不同方式操作的需要，而用多个描述符加以描述的技术称为别名技术。这好比一个演员在一部戏中扮演多个角色，在不同的情景下，使用不同的称呼。在保护方式程序设计中，常常要采用别名技术。例如：用两个具有不同类型值的描述符来描述同一个段。再如，用两个具有不同DPL的描述符来描述符同一个段。

## 10.6.3 任务内不同特权级的变换

==在一个任务之内，可以存在四种特权级，所以常常会发生不同特权级之间的变换==。例如：外层的应用程序调用内层操作系统的例程，以获得必要的诸如存储器分配等系统服务；内层操作系统的例程完成后，返回到外层应用程序在同一任务内，==实现特权级从外层到内层变换的普通途径是==：==使用段间调用指令`CALL`，通过调用门进行转移==；==实现特权级从内层到外层变换的普通途径是==：==使用段间返回指令`RET`==。==注意，不能利用JMP指令实现任务内不同特权级的变换==。

### 1. 通过调用门的转移

> 门的`DPL`规定了访问门的最外层特权级，只有相同级或更高内级可以访问门。假如门DPL=3，就只能0/1/2能使用该门
>
> 门的选择子RPL`<=`门的DPL。假如门DPL=0，RPL只能为0
>
> 通过调用门向内层CALL/JMP，执行前检测`CPL<=DPL(门) && RPL(门内)<=DPL(门)`，假如。CPL=3，DPL(门)只能等于3，RPL(门内)=0/1/2
>
> 调用时，偏移会被丢弃
>
> `CALL`指令在最后把目标代码段的指针装入`CS`和`EIP`之前，要把原`CS`和`EIP`，即返回地址保存到堆栈。如变换特权级，那么返回地址保存在内层堆栈中

==当**段间转移指令`JMP`**和**段间调用指令`CALL`**所含**指针的选择子指示调用门描述符**时，就可实现通过调用门的转移==。
==调用门描述调用转移的入口点==，从图10.13可见，==它包含目标地址的段及偏移量的48位全指针==。==在执行通过调用门的段间转移指令`JMP`或段间调用指令`CALL`时，指令所含指针内的选择子用于确定调用门，而偏移被丢弃==；==把调用门内的48位全指针，作为目标地址指针进行转移==。
==**处理器采用与访问数据段相同的特权级规则**控制对**门描述符**的**访问**==。==门描述符的`DPL`规定了访问门的最外层特权级，只有在相同级或者更内层级的程序才可以访问门==时，还要求指示门的选择子的`RPL`必须满足`RPL<=DPL`的条件。
调用门是门描述符的一种。所以，在取出调用门内的48位全指针，把它作为目标地址指针向目标代码段转移之前，要进行特权级检测。==必须符合`CPL<=DPL`并且`RPL<=DPL`的条件==。检测通过后，开始在10.6.1节中所述的转移步骤。其中还要检测目标描述符是否是描述符代码段，调用门内的选择子指示的描述符必须是代码段描述符。此外，在装载高速缓冲寄存器之前调整`RPL=0`，也即调用门中选择子的`RPL`被忽略。
如10.6.1节中所述，==在装载`CS`高速缓冲寄存器时，还要对目标代码段描述符进行保护检测。检测过程中的`DPL`不再是调用门的`DPL`，而是调用门内选择子所指示的目标代码段描述符的`DPL`==。

段间调用指令`CALL`和段间转移指令`JMP`所做的检测不一样。

- ==对于使用调用门的段间转移指令`JMP`，检测条件与段间直接转移相同。==由于已置`RPL=0`，所以可认为`RPL<=DPL`的条件总能满足。所以，对于普通的非一致代码段，当`CPL=DPL`时，发生无特权级变换的转移；对于一致代码段，在满足`CPL>=DPL`时也发生无特权级变换的转移；其他情形就引起异常。
- ==对于使用调用门的段间调用指令`CALL`，情形就不同了==。由于已置`RPL=0`，所以可认为`RPL<=DPL`的条件总能满足。对于一致代码段，在满足`CPL>=DPL`时发生无特权级变换的转移。对于非一致代码段，当`CPL=DPL`时，仍发生无特权级变换的转移；当`CPL>DPL`时，就发生向内层特权级变换的转移，使`CPL`保持等于`DPL`，同时切换到对应的内层堆栈。

综上所述，==使用段间调用指令`CALL`，通过调用门可以实现从外层程序调用进入内层程序==；通过调用门也可实现无特权级变换的转移。

当然，==`CALL`指令在最后把目标代码段的指针装入`CS`和`EIP`之前，要把原`CS`和`EIP`，即返回地址保存到堆栈==。如无特权级变换，堆栈保持不变，返回地址就保存在原堆栈中；==如变换特权级，那么返回地址保存在内层堆栈中==。

### 2. 堆栈切换

> `CALL`通过调用门向内层转移，特权级发生变换，堆栈段也要切到内层
>
> 特权级转行到内层，特权级使用`TSS`中的堆栈指针对`SS`及`ESP`寄存器进行初始化，建一个空栈
>
> 建立内层堆栈后，把外层堆栈的指针`SS`及`ESP`寄存器的值压入内层堆栈，向返回时外层堆栈可恢复，然后复制参数，最后调用的返回地址被压入堆栈

==在使用`CALL`指令，通过调用门向内层转移时，不仅特权级发生变换，控制转移到一个新的代码段，而且也切换到内层的堆栈段==。

从图10.14所示的任务状态段`TSS`的格式可见，==TSS中包含有指向0级、1级和2级堆栈的指针==。==在特权级发生向内层变换时，根据特权级使用`TSS`中相应的堆栈指针对`SS`及`ESP`寄存器进行初始化，建立起一个空栈==。
==在建立起内层堆栈后，先把外层堆栈的指针`SS`及`ESP`寄存器的值压入内层堆栈，以使得相应的向外层返回可恢复原来的外层堆栈==。然后，从外层堆栈复制以双字为单位的调用参数到内层堆栈，调用门中的`DCOUNT`字段值决定了复制参数的量。这些被复制的参数是主程序通过堆栈传递给子程序的实参，在调用之前被压入外层堆栈。通过复制堆栈中的参数，使内层的子程序不需要考虑堆栈的切换，而容易地访问主程序传递过来的实参。
最后，==调用的返回地址被压入堆栈，以便在调用结束时返回==。图10.15给出了在向内层变换时，建立内层堆栈，并从外层堆栈复制2个双字参数到内层堆栈的示意图。图中每项是双字，可见的段寄存器内的选择子被扩展成32位，高16位为0。无论是否通过调用门，只要不发生特权级变换，就不会切换堆栈。

![image](https://github.com/YangLuchao/img_host/raw/master/20231127/image.1ttqzx4x6hj4.jpg)

### 3. 向外层返回

> `RET`指令返回，先弹出外层EIP，外层CS，删除参数列表，弹出外层ESP，外层SS
>
> ==`RET`指令先从堆栈弹出返回地址==。==如果返回地址的选择子的`RPL`规定相对于`CPL`更外层的级，那么就引起向外层返回==

==与使用`CALL`指令通过调用门向内层变换相反，使用`RET`指令实现向外层返回==。==段间返回指令`RET`从堆栈中弹出返回地址，并且可以采用调整`ESP`的方法，跳过相应的在调用之前压入堆栈的参数==。返回地址的选择子指示要返回的代码段描述符，从而确定返回的代码段。==选择子的`RPL`确定返回后的特权级==，而不是对应描述符的`DPL`，这是因为，段间返回指令`RET`可能使控制返回到一致代码段，而一致代码段可以在`DPL`规定的特权级以外的特权级执行。
==`RET`指令先从堆栈弹出返回地址==。==如果返回地址的选择子的`RPL`规定相对于`CPL`更外层的级，那么就引起向外层返回==。其次，为向外层返回，跳过内层堆栈中的参数，再从内层堆栈中弹出指向外层堆栈的指针，并装入到`SS`及`ESP`，以恢复外层堆栈。再次，调整`ESP`，跳过在相应的调用之前压入到外层堆栈的参数。然后，检查数据段寄存器`DS`、`ES`、`FS`及`GS`，以保证寻址的段在外层是可访问的，==如果段寄存器寻址的段在外层是不可访问的，那么装入一个空选择子，以避免在返回时发生保护空洞==。最后，返回(外层)继续执行。上述五步是对带立即数段间返回指令而言的，立即数规定了堆栈中要跳过的参数的字节数。对无立即数段间返回指令而言，缺少第二和第三步，请参见下面的实例四。如果`RET`指令不需要向外层返回，那么就只有开始和最后的两步。

## 10.6.4 演示任务内特权级变换的实例(实例四)

下面给出一个演示==任务内特权级变换的实例==。该实例演示在==任务内通过调用门从外层特权级变换到内层特权级==；==也演示通过段间返回指令从内层特权级变换到外层特权级==；
还演示==通过调用门的无特权级变换的转移==。实例使用了任务状态段`TSS`，这是因为任务内特权级变换时要使用的内层堆栈指针存放在`TSS`中。

### 1. 实现流程

实例四的主要实现步骤如图10.16所示。在图的右边标出了特权级变换的分界情况。由于在任务内发生特权级变换时要切换堆栈，而内层堆栈的指针存放在当前任务的`TSS`中，所以在进入保护方式后设置任务状态段寄存器`TR`。由于演示任务使用了局部描述符表，所以设置`LDTR`。从实方式切换到保护方式下的16位临时代码段，`CPL=0`在临时代码段通过任务门转移到32位过渡代码段，不发生特权级变换，`CPL=0`。为了演示外层程序通过调用门调用内层程序，要使`CPL>0`。实例先通过段间返回指令`RET`从特权级0变换到特权级3的演示代码段。在特权级3下，通过调用门调用1级的子程序。随着执行段间RET,又返回到3级的演示代码段。在3级演示代码段通过调用门转移到0级的过渡代码段，再转0级的临时代码段，最后切换回实方式。

### 2. 源程序组织和清单

实例四有如下部分组成：

1. 全局描述符表`GDT`。`GDT`含有演示任务的`TSS`段描述符和`LDT`段描述符，此外还含临时代码段描述符、规范数据段描述符和视频缓冲区段描述符。
2. 演示任务的`LDT`段。它含有除临时代码段外的其他代码段的描述符和演示任务各级堆栈段描述符，还含有3个调用门。
3. 演示任务的`TSS`段。
4. 演示任务的0级、1级和3级堆栈段。
5. 显示子程序段。32位代码段，特权级1。
6. 演示代码段。32位代码段，特权级3。
7. 过渡代码段。32位段，特权级0。
8. 临时代码段。16位段，特权级0。
9. 实方式下的数据和代码段。

![image]（https://github.com/YangLuchao/img_host/raw/master/20231127/image.2mz2wr9pflk0.jpg）

该实例的逻辑功能是显示演示程序代码段执行时的当前特权级`CPL`。源程序清单如下：

```assembly
;程序名：T10-4.ASM
;演示在任务内如何进行特权级变换
;
INCLUDE 386SCD.ASM
;
;参见实例三
	.386P

;全局描述符表GDT
GDTSEG SEGMENT 	PARA 	USE16
                 GDT       LABEL 	BYTE

    ;空描述符
                 DUMMY     DESCRIPTOR 	<>

    ;规范数据段描述符
    ;描述符的含义为，段界限为OFFFFH，基址为0h，属性为R0可读写数据段
                 NORMAL    DESCRIPTOR 	<0FFFFH,0,0,ATDW,0>
    ;NORMAL为GDT第二个描述符，一个描述符结构体的长度位8h，所以NORMAL - 0 = 0008h
    ;0008h = 0000 0000 0000 1000 = 0000000000001 0 00
    ;表示0环GDT中index = 1的描述符
    NORMAL_SEL   =         NORMAL - GDT


                 EFFGDT    LABEL 	BYTE


    ;演示任务状态段TSS描述符
    ;描述符内容为，段界限为DemoTSSLEN - 1，基址为DemoTSSSEG段，属性为R0环386TSS类型值
                 DEMOTSS   DESCRIPTOR <DemoTSSLEN-1,DemoTSSSEG,,AT386TSS,>
    ;DEMOTSS为GDT第三个描述符，一个描述符结构体的长度位8h，所以DEMOTSS - 0 = 0010h
    ;0010h = 0000 0000 0000 1000 = 0000000000001 0 00
    ;表示0环GDT中index = 2的描述符
    DemoTSS_SEL  =         DEMOTSS - GDT


    ;演示任务LDT段描述符
    ;描述符内容为，段界限为DemoLDTLEN - 1，基址为DemoLDTSEG段,属性为R0环局部描述符表段类型值
                 DEMOLDTD  DESCRIPTOR <DemoLDTLEN-1,DemoLDTSEG,,ATLDT,>
    ;DEMOLDTD为GDT第四个描述符，一个描述符结构体的长度位8h，所以DEMOLDTD - 0 = 0018h
    ;0018h = 0000 0000 0000 1000 = 0000000000001 0 00
    ;表示0环GDT中index = 3的描述符
    DemoLDT_SEL  =         DEMOLDTD - GDT


    ;临时代码段描述符
    ;描述符内容为，段界限为0FFFFH，基址为TempCodeSEG段，属性为R0环可执行代码段
                 TEMPCODE  DESCRIPTOR <0FFFFH,TempCodeSEG,,ATCE,>
    ;TEMPCODE为GDT第五个描述符，一个描述符结构体的长度位8h，所以TEMPCODE - 0 = 0020h
    ;0020h = 0000 0000 0000 1000 = 0000000000001 0 00
    ;表示0环GDT中index = 4的描述符
    TempCode_SEL =         TEMPCODE - GDT


    ;视频缓冲区段描述符(DPL=3)
    ;描述符内容为，段界限为0FFFFH，基址为0F00H+VideoSEG段，属性为R3环视频缓冲区段
                 VIDEOBUFF DESCRIPTOR 	<0FFFFH,0,0,0F00H+ATDW+DPL3,0>
    ;VIDEOBUFF为GDT第六个描述符，一个描述符结构体的长度位8h，所以VIDEOBUFF - 0 = 0028h
    ;0028h = 0000 0000 0000 1000 = 0000000000101 0 00
    ;表示0环GDT中index = 5的描述符
    Video_SEL    =         VIDEOBUFF - GDT

    ;可用的全局描述符个数
    GDNUM        =         ($ - EFFGDT)/(SIZE DESCRIPTOR)
    ;GDT长度
    GDTLEN       =         $ - GDT
GDTSEG ENDS

;演示任务局部描述符表LDT
DemoLDTSEG SEGMENT 	PARA 	USE16
    ;LDT起始位置标号
                   DemoLDT    LABEL 		BYTE

    ;0级堆栈段描述符(32位段)
    ;描述符内容为，段界限为DemoStack0LEN - 1，基址为DemoStack0SEG段，属性为R0环32位可读写数据段
                   DEMOSTACK0 DESCRIPTOR 	<DemoStack0LEN-1,DemoStack0SEG,,ATDW+D32,>
    ;DEMOSTACK0为LDT第一个描述符，一个描述符结构体的长度位8h，所以0 * 8 - 0 = 0h + 4h = 04h
    ;04h = 0000 0000 0000 0100 = 0000000000000 1 00
    ;表示0环LDT中index = 0的描述符
    DemoStack0_SEL =          (DemoStack0 - DEMOLDT) + TIL


    ;1级堆栈段描述符(DPL=1)
    ;描述符内容为，段界限为DemoStack1LEN - 1，基址为DemoStack1SEG段，属性为R1环32位可读写数据段
                   DEMOSTACK1 DESCRIPTOR 	<DemoStack1LEN-1,DemoStack1SEG,,ATDW+D32+DPL1,>
    ;DEMOSTACK1为LDT第二个描述符，一个描述符结构体的长度位8h，所以1*8 - 0 = 0008h + 4h = 0ch + 0001h = 0Dh
    ;0Dh = 0000 0000 0000 1101 = 0000000000001 1 01
    ;表示1环LDT中index = 1的描述符
    DemoStack1_SEL =          (DemoStack1 - DEMOLDT) + TIL + RPL1


    ;3级堆栈段描述符(DPL=3)
    ;描述符内容为，段界限为DemoStack3LEN - 1，基址为DemoStack3SEG段，属性为R3环32位可读写数据段
                   DEMOSTACK3 DESCRIPTOR 	<DemoStack3LEN-1,DemoStack3SEG,,ATDW+DPL3,>
    ;DEMOSTACK3为LDT第三个描述符，一个描述符结构体的长度位8h，所以3*8 - 0 = 0018h + 4h = 001ch + 0001h = 001dh
    ;001dh = 0000 0000 0001 1101 = 0000000000011 1 01
    ;表示3环LDT中index = 3的描述符
    DemoStack3_SEL =          (DemoStack3 - DEMOLDT) + TIL + RPL3


    ;演示代码段描述符(32位段，DPL=3)
    ;描述符内容为，段界限为DemoCodeLEN - 1，基址为DemoCodeSEG段，属性为R3环32位可执行代码段
                   DEMOCODE   DESCRIPTOR 	<DemoCodeLEN-1,DemoCodeSEG,,ATCE+D32+DPL3>
    ;DEMOCode为LDT第四个描述符，一个描述符结构体的长度位8h，所以4 * 8 - 0 = 0020h + 4h = 0024h + 0001h = 0025h
    ;0025h = 0000 0000 0010 0101 = 0000000000100 1 01
    ;表示3环LDT中index = 4的描述符
    DemoCode_SEL   =          (DEMOCODE - DEMOLDT) + TIL + RPL3


    ;过渡代码段描述符(32位段)
    ;描述符内容为，段界限为T32CodeLEN - 1，基址为T32CodeSEG段，属性为R0环32位可执行代码段
                   T32CODE    DESCRIPTOR 	<T32CodeLEN-1,T32CodeSEG,,ATCE+D32,>
    ;T32Code为LDT第五个描述符，一个描述符结构体的长度位8h，所以5 * 8 - 0 = 0028h + 4h = 002ch
    ;002ch = 0000 0000 0010 1100 = 0000000000101 1 00
    ;表示0环LDT中index = 5的描述符
    T32Code_SEL    =          (T32CODE - DEMOLDT) + TIL


    ;显示子程序代码段描述符(32位段，DPL=1)
    ;描述符内容为，段界限为EchoSUBRLEN - 1，基址为EchoSUBRSEG段，属性为R1环32位可执行代码段
                   ECHOSUBR   DESCRIPTOR 	<EchoSUBRLEN-1,EchoSUBRSEG,,ATCER+D32+DPL1,>
    ;EchoSUBR为LDT第六个描述符，一个描述符结构体的长度位8h，所以6 * 8 - 0 = 0030h + 4h = 0034h + 0001h = 0035h
    ;0035h = 0000 0000 0011 0101 = 0000000000110 1 01
    ;表示1环LDT中index = 6的描述符
    Echo_SEL1      =          (ECHOSUBR - DEMOLDT) + TIL + RPL1
    ;EchoSUBR为LDT第六个描述符，一个描述符结构体的长度位8h，所以6 * 8 - 0 = 0030h + 4h = 0034h + 0003h = 0037h
    ;0037h = 0000 0000 0011 0111 = 0000000000110 1 11
    ;表示3环LDT中index = 6的描述符
    Echo_SEL3      =          (ECHOSUBR - DEMOLDT) + TIL + RPL3

    ;描述符个数
    DemoLDNUM      =          ($ - DEMOLDT)/(SIZE DESCRIPTOR)


    ;指向过渡代码段内T32Begin点的调用门(DPL=0)
    ;TOT32GATEA为门描述符，含义为，T32Begin为偏移低16位，T32Code_SEL为目标选择子，0为参数计数器，AT386CGAT为0环386调用门类型值，0为偏移高16位
                   TOT32GATEA GATE 	<T32Begin,T32Code_SEL,0,AT386CGAT,0>
    ;T32Begin为LDT第七个描述符，一个描述符结构体的长度位8h，所以7 * 8 - 0 = 0038h + 4h = 003ch
    ;003ch = 0000 0000 0011 1100 = 0000000000111 1 00
    ;表示0环LDT中index = 7的描述符
    TOT32A_SEL     =          (TOT32GATEA - DemoLDT) + TIL


    ;指向过渡代码段内T32End点的调用门(DPL=3)
    ;TOT32GATEB为门描述符，含义为，T32End为偏移低16位，T32Code_SEL为目标选择子，0为参数计数器，AT386CGAT+DPL3为3环386调用门类型值，0为偏移高16位
                   TOT32GATEB GATE 	<T32End,T32Code_SEL,0,AT386CGAT+DPL3,0>
    ;T32End为LDT第八个描述符，一个描述符结构体的长度位8h，所以8 * 8 - 0 = 0040h + 4h = 0044h
    ;0044h = 0000 0000 0100 0100 = 0000000001000 1 00
    ;表示0环LDT中index = 8的描述符
    ToT32B_SEL     =          (TOT32GATEB - DemoLDT) + TIL


    ;指向显示子程序的调用门(DPL=3)
    ;TOECHOGATE为门描述符，含义为，EchoSUB为偏移低16位，ToEcho_SEL为目标选择子，0为参数计数器，AT386CGAT+DPL3为3环386调用门类型值，0为偏移高16位
                   TOECHOGATE GATE 	<EchoSUB,Echo_SEL3,0,AT386CGAT+DPL3,0>
    ;EchoSUB为LDT第九个描述符，一个描述符结构体的长度位8h，所以9 * 8 - 0 = 0048h + 4h = 004ch
    ;004ch = 0000 0000 0100 1100 = 0000000001001 1 00
    ;表示0环LDT中index = 9的描述符
    ToEcho_SEL     =          (TOECHOGATE - DemoLDT) + TIL

    ;LDT长度
    DemoLDTLEN     =          $ - DemoLDT
DemoLDTSEG ENDS
    ;----
    ;演示任务的TSS段
DemoTSSSEG SEGMENT PARA USE 16
               DD 0                   ;BACK
               DW DemoStack0LEN,0     ;0级堆栈指针
               DW DemoStack0_SEL,0    ;初始化
               DW DemoStack1LEN,0     ;1级堆栈指针
               DW DemoStack1_SEL,0    ;初始化
               DD ?                   ;2级堆栈指针
               DW ?,0                 ;未初始化
               DD 0                   ;CR3
               DD ?                   ;EIP
               DD ?                   ;EFLAGS
               DD ?                   ;EAX
               DD ?                   ;ECX
               DD ?                   ;EDX
               DD ?                   ;EBX
               DD ?                   ;ESP
               DD ?                   ;EBP
               DD ?                   ;ESI
               DD ?                   ;EDI
               DW ?,0                 ;ES
               DW ?,0                 ;CS
               DW ?,0                 ;SS
               DW ?,0                 ;DS
               DW ?,0                 ;FS
               DW ?,0                 ;GS
               DW DemoLDT_SEL,0       ;LDT
               DW 0
               DW $+2                 ;指向`I/O`许可位图
               DB OFFH                ;`I/O`许可位图结束标志
    DemoTSSLEN =  $
DemoTSSSEG ENDS
;演示任务0级堆栈段(32位段)
DemoStack0SEG SEGMENT 	PARA 	USE32
    DemoStack0LEN =  512
                  DB DemoStack0LEN 	DUP(0)
DemoStack0SEG ENDS
;演示任务1级堆栈段(16位段)
DemoStack1SEG SEGMENT 	PARA 	USE32
    DemoStack1LEN =  512
                  DB DemoStack1LEN DUP(0)
DemoStack1SEG ENDS
;演示任务3级堆栈段(16位段)
DemoStack3SEG SEGMENT 	PARA 	USE16
    DemoStack3LEN =  512
                  DB DemoStack3LEN DUP (0)
DemoStack3SEG ENDS
;演示任务显示子程序代码段(32位段，1级)
EchoSUBRSEG SEGMENT 	PARA 	USE32
    MESSAGE     DB     'CPL=',0
                ASSUME CS:EchoSUBRSEG
    ;显示调用程序的执行特权级
EchoSUB PROC 	FAR
                CLD                          ;清空方向
                PUSH   EBP
                MOV    EBP,ESP               ;当前ESP为R1栈栈顶，重新定义栈底
                MOV    AX,Echo_SEL1          ;子程序代码段是可读段
                MOV    DS,AX                 ;采用RPL=1的选择子
                MOV    AX,Video_SEL
                MOV    ES,AX                 ;视频缓冲区段基地址00000000H
                MOV    EDI,0B8000H           ;视频缓冲区段B8000H开始
                MOV    ESI,OFFSET MESSAGE
                MOV    AH,17H                ;显示属性
    EchoSUB1:   
                LODSB
                OR     AL,AL
                JZ     EchoSUB2
                STOSW                        ;显示字符串
                JMP    EchoSUB1
    EchoSUB2:   
                MOV    EAX,[EBP+8]           ;从堆栈中取调用程序的选择子
                AND    AL,3                  ;调用程序的CPL在CS的RPL字段
                ADD    AL,'0'
                MOV    AH,17H
                STOSW                        ;显示之
                POP    EBP
                RETF                         ;返回
EchoSUB ENDP
    EchoSUBRLEN =      $
EchoSUBRSEG ENDS
;----------------
;演示任务的演示代码段(32位段，3级)
DemoCodeSEG SEGMENT 	PARA 	USE32
                ASSUME CS:DemoCodeSEG
    DemoBegin:  
    ;CPL=3，只能调用DPL=3的门，TOECHOGATE 的属性中DPL=3
    ;TOECHOGATE 门中选择子为 Echo_SEL3，RPL=3，可以指向DPL=0/1/2/3段
    ;Echo_SEL3 指向的段 ECHOSUBR 的DPL=1，所有条件符合，进行跳转，跳到 EchoSUBRSEG 的代码段
    ;CALL 指令，将SS/SP/参数/CS/EIP压入R1堆栈
    ;特权集变换到1级
                CALL32 ToEcho_SEL,0
    ;上一个CALL32 RET后，CPL又回退到3级
    ;转到过渡代码段(变换到0级)
    ;CPL=3，只能调用DPL=3的门，TOT32GATEB 的属性中DPL=3
    ;TOT32GATEB 门中选择子为 T32Code_SEL，RPL=0，可以指向DPL=0段 偏移为t32End
    ;T32Code_SEL 指向的段 T32CODE 的DPL=0，所有条件符合，进行跳转，跳到 T32CodeSEG 的代码段 T32End 偏移处
    ;特权集转换到R0
                CALL32 ToT32B_SEL,0
    DemoCodeLEN =      $
DemoCodeSEG ENDS
;演示任务的过渡代码段(32位段，0级)
;`RET`指令，从特权级0变换到特权级3
T32CODESEG SEGMENT 	PARA 	USE32
               ASSUME CS:T32CODESEG
    T32Begin:  
    ;建立0级堆栈
               MOV    AX,DemoStack0_SEL               ;设置0级栈ss段段值
               MOV    SS,AX
               MOV    ESP,DemoStack0LEN               ;设置0级栈栈顶，方向向下
    ;构建正常CALL跨权限级调用
    ;当前CPL=0，通过调用门调用内层程序，要设法使`CPL>0`,所以要压入3级堆栈指针
               PUSH   DWORD PTR DemoStack3_SEL        ;R3堆栈段选择子(SS)入R0栈
               PUSH   DWORD PTR DemoStack3LEN         ;R3堆栈段栈顶(SP)入R0栈，没有参数，不用压入
    ;压入入口点
               PUSH   DWORD PTR DemoCode_SEL          ;R3代码段选择子(CS)如R0栈，返回地址选择子(CS)的RPL决定返回后的CPL，DemoCode_SEL 选择子对应R3环
               PUSH   OFFSET DemoBegin                ;R3指令指针(EIP)入R0栈
    ;利用RET实现转3级的演示代码段
    ;转移到 DemoCode_SEL 段 DemoBegin 偏移处
               RETF
    T32End:                                           ;转临时代码段，ToReal偏移处
               JUMP32 TempCode_SEL,<OFFSET ToReal>
    T32CadeLEN =      $
T32CODESEG ENDS
	;临时代码段(16位段，0级)
TempCodeSEG SEGMENT		PARA 	USE16
                ASSUME CS:TempCodeSEG
    Virtual:    
    ;装载TR
                MOV    AX,DemoTSS_SEL
                LTR    AX                          ;TR中加载跳转前的TSS
    ;装载LDTR
                MOV    BX,DemoLDT_SEL
                LLDT   BX                          ;LDT中加载跳转前的LDT
    ;通过调用门转过渡段
    ;通过 TOT32A_SEL 选择子找到 TOT32GATEA 门描述符
    ;通过 TOT32GATEA 调用门找到 T32Code_SEL 目标存储段选择子和 T32Begin 在目标存储段中的偏移
    ;通过 T32Code_SEL 目标存储段选择子找到 T32Code_SEG 目标存储段
    ;通过 T32Code_SEG 目标存储段找到 T32Begin 偏移
    ;执行跳转
                JUMP16 ToT32A_SEL,0
    ToReal:                                        ;准备切换回实方式
                MOV    AX,Normal_SEL
                MOV    DS,AX
                MOV    ES,AX                       ;把规范段描述符
                MOV    FS,AX                       ;装入各数据段寄存器
                MOV    GS,AX
                MOV    SS,AX
                MOV    EAX,CR0                     ;PE置为0，切换到实模式
                AND    AX,OFFFEH
                MOV    CR0,EAX                     ;返回实方式
                JUMP16 <SEG REAL>,<OFFSET REAL>
    TempCodeLEN =      $
TempCodeSEG ENDS
;实方式下的数据段
RDataSEG SEGMENT 	PARA 	USE16
             VGDTR PDESC 	<GDTLEN - 1,>
    SPVAR    DW    ?
    SSVAR    DW    ?
RDataSEG ENDS
;实方式下的代码段
RCodeSEG SEGMENT 	PARA 	USE16
             ASSUME CS:RCodeSEG,DS:RDataSEG
    Start:   
             MOV    AX,RDataSEG
             MOV    DS,AX                            ;装载是模式下数据段
             CLD                                     ;设置方向标志
             CALL   INIT_GDT                         ;初始化GDT
    ;
             MOV    AX,DemoLDTSEG                    ;LDT段值挪到FS中
             MOV    FS,AX
             MOV    SI,OFFSET DemoLDT                ;设置起始偏移
             MOV    CX,DemoLDNUM                     ;设置LDT中描述符的个数
             CALL   INIT_LDT                         ;初始化LDT
    ;设置切换前的栈基址和栈顶位置
             MOV    SSVAR,SS
             MOV    SPVAR,SP
    ;装载GDTR和切换到保护方式
             LGDT   QWORD PTR VGDTR
             CLI                                     ;关中断
             MOV    EAX,CR0
             OR     AX,1
             MOV    CR0,EAX                          ;切换到保护模式
             JUMP16 TempCode_SEL,<OFFSET Virtual>    ;跳转，跳转以后，系统会自动刷新TSS和LDT，TSS和LDT会保存未跳转前的任务的信息
    Real:    
             MOV    AX,RDATASEG
             MOV    DS,AX
             LSS    SP,DWORD PTR SPVAR               ;恢复实方式堆栈指针
             STI                                     ;关中断
             MOV    AX,4C00H
             INT    21H                              ;完成，退出
    ;初始化全局描述符表的子程序
    ;(1)把定义时预置的段值转换成32位段基地址并置入描述符内相应字段
    ;(2)初始化为GDTR准备的伪描述符
INIT_GDT PROC 	NEAR
             PUSH   DS
             MOV    AX,GDTSEG                        ;定义的GDT段段值挪到AX中
             MOV    DS,AX                            ;定义的GDT段段值挪到DS中
             MOV    CX,GDNUM                         ;GDNUM是初始化的描述符个数
             MOV    SI,OFFSET EFFGDT                 ;EFFGDT是开始偏移
    ;将描述符中的基址扩展到32位
    INITG:   
             MOV    AX,[SI].BASEL                    ;取出预置的段值
             MOVZX  EAX,AX                           ;将初始化进去的16位段值扩展到32位
             SHL    EAX,4                            ;段值左移4位
             SHLD   EDX,EAX,16                       ;分解到2个16位寄存器
             MOV    [SI].BASEL,AX
             MOV    [SI].BASEM,DL                    ;置入描述符相应字段
             MOV    [SI].BASEH,DH
             ADD    SI,SIZE DESCRIPTOR               ;调整到下一描述符
             LOOP   INITG                            ;所有描述符处理完后，退出循环
    ;描述符中的基址扩展完成
             POP    DS
    ;初始化为GDTR准备的伪描述符
             MOV    BX,16
             MOV    AX,GDTSEG
             MUL    BX
             MOV    WORD PTR VGDTR.BASE,AX
             MOV    WORD PTR VGDTR.BASE+2,DX
    ;VGDTR初始化完成
             RET
INIT_GDT ENDP
    ;初始化演示任务局部描述符表的子程序
    ;把定义时预置的段值转换成32位段基地址并置入描述符内相应字段
    ;入口参数：FS:SI=第一个要初始化的描述符
    ;CX=要初始化的描述符个数
INIT_LDT PROC
    ;将初始化进去的16位段值扩展到32位
    ILDT:    
             MOV    AX,FS:[SI].BASEL
             MOVZX  EAX,AX
             SHL    EAX,4
             SHLD   EDX,EAX.16
             MOV    FS:[SI].BASEL,AX
             MOV    FS:[SI].BASEM,DL
             MOV    FS:[SI].BASEH,DH
             ADD    SI,SIZE DESCRIPTOR
             LOOP   ILDT
    ;将初始化进去的16位段值扩展到32位结束
             RET
INIT_LDT ENDP
RCodeSEG ENDS
	END Start
```

### 3. 关于实例四的说明

程序中部分片段的背景和实现方法已在前面的实例中做过介绍，下面主要就如何实现任务内特权级变换作些说明：

#### (1)通过段间返回指令实现特权级变换

实例在两处==使用段间返回指令实现任务内的特权级变换==。

==一处是T32Begin标号开始从0级的过渡代码段中用段间`RET`指令，从特权级0变换到特权级3的演示代码段==。

- 该处`RET`指令并不对应`CALL`指令。实例从保护方式切换到实方式后`CPL=0`。
- 为了演示如何==通过调用门调用内层程序，要设法使`CPL>0`==。
- 为此，实例先建立一个已发生从外层到内层变换的环境，也即按如图10.15所示，==在当前堆栈(0级堆栈)中放入外层堆栈的指针和外层演示程序的入口指针==，形成一个如图10.17所示的0级堆栈，无需传递参数。
- 然后，执行段间返回指令`RET`，从堆栈中弹出3级演示代码的选择子，`RPL=3`，而当时`CPL=0`，所以导致向外层变换特权级，就从0级的过渡代码段变换到3级的演示代码段，同时切换到3级堆栈。

另一处是从1级的显示子程序EchoSUB返回到3级的演示程序段。这处的RET指令与演示程序中使用的通过调用门的段间调用指令`CALL`相对应，执行段间返回指令RET时的1级堆栈也如图10.17所示，其中的返回地址指针和外层堆栈指针由指令`CALL`压入。

![image](https://github.com/YangLuchao/img_host/raw/master/20231127/image.1vi3wg9ji81s.jpg)

#### (2)通过调用门实现特权级变换

实例在两处==使用了段间调用指令，通过调用门实现特权级的变换==。

一处是3级演示代码通过调用门`TOECHO GATE`调用1级的显示子程序。调用门`TOECHO GATE`自身`DPL=3`，只有这样，3级的演示代码才能够使用该调用门。由于调用门内的选择子Echo_SEL3所指示的显示子程序代码段描述符`DPL=1`，而当时`CPL=3`，所以引起从外层特权级向内层特权级的变换，使`CPL=1`。同时形成如图10.17所示的1级堆栈。虽然调用门内的选择子`Echo_SEL3`的`RPL=3`，大于目标代码段描述符的`DPL`，但没有关系，因为在通过调用门转移时，门内指示目标代码段的选择子`RPL`总被当作0对待。
另一处是3级演示代码还通过调用门`TOT32 GATEB`调用了0级的过渡代码。该处使用的调用门描述符`DPL`也等于3。由于调用门内的选择子`T32Code_SEL`所指示的过渡代码段描述符`DPL=0`，而当时`CPL=3`，所以引起从3特权级向0特权级的变换，使`CPL=0`。同时形成如图10.17所示的0级堆栈。但该处的调用实际上是`有去无回`的，调用的目的是转移到0级的过渡代码，准备返回到实方式。由于从3级的演示代码到0级的过渡代码要发生特权级变换，所以不能使用转移指令`JMP`，必须使用调用指令`CALL`。

#### (3)通过调用门实现无特权级变换的转移

在临时代码段中，==使用调用门`TOT32 GATEA`转移到过渡代码段==。尽管调用门内的选择子`T32Code_SEL`所指示的过渡代码段描述符`DPL=0`，但当时`CPL=0`，所以不发生特权级变换。正是这个原因，才可以使用段间转移指令`JMP`。

#### (4)子程序EchoSUB的实现

子程序`EchoSUB`的功能是显示调用程序执行时的特权级。调用程序的执行特权级在代码段寄存器`CS`内选择子的`RPL`字段，在调用`EchoSUB`时，`CS`寄存器内容被压入堆栈。子程序从堆栈取得调用程序的代码段选择子，再从中分离出RPL就可得调用程序的执行特权级。

#### (5)装载任务状态段寄存器TR

在==任务内发生特权级变换时堆栈也随着自动切换，外层堆栈指针保存在内层堆栈中，而内层堆栈指针存放在当前任务的`TSS`中==。所以，在从外层向内层变换时，要访问`TSS`。`实例`在进入保护方式下的临时代码段后，通过如下两条指令，装载任务状态段寄存器`TR`，使其指向已预置好的演示任务的`TSS`:

```assembly
MOV 	AX,DemoTSS_SEL
LTR 	AX
```

==`LTR`指令是专门用于装载任务状态段寄存器`TR`的指令==。==该指令的操作数是对应`TSS`段描述符的选择子==。`LTR`指令从`GDT`中取出相应的`TSS`段描述符，把`TSS`段描述符的基地址和界限等信息被装入`TR`的高速缓冲寄存器中。在10.8节中对`LTR`指令的一般格式作说明。

## 10.6.5 任务切换

==利用段间转移指令`JMP`或者段间调用指令`CALL`，通过任务门或者直接通过任务状态段，可以切换到别的任务==。此外，在==中断/异常或者执行`IRET`指令时也可能发生任务切换==。

### 1. 直接通过TSS进行任务切换

==当段间转移指令`JMP`或段间调用指令`CALL`所含指针的选择子指示一个可用任务状态段`TSS`描述符时，正常情况下就发生从当前任务到由该可用`TSS`对应任务(目标任务)的切换==。==目标任务的入口点由目标任务`TSS`内的`CS`和`EIP`字段所规定的指针确定==。
这样的`JMP`或`CALL`指令内的偏移被丢弃。处理器采用与访问数据段相同的特权级规则控制对`TSS`段描述符的访问。`TSS`段描述符的`DPL`规定了访问该描述符的最外层特权级，只有在相同级或者更内层级的程序才可以访问它。==同时，还要求指示它的选择子的`RPL`必须满足`RPL<=DPL`的条件==。当这些条件满足时，就开始任务切换。

### 2. 通过任务门进行任务切换

==任务门内的选择子指示某个任务的`TSS`描述符==。==当段间转移指令`JMP`或段间调用指令`CALL`所含指针的选择子指示一个任务门时，正常情况下就发生任务切换，也即从当前任务切换到由任务门内的选择子所指示的`TSS`描述符对应的任务(目标任务)==。这样的`JMP`或`CALL`指令内的偏移被丢弃；任务门内的偏移也无意义。

**切换条件**：

处理器采用与访问数据段相同的特权级规则控制对任务门的访问。==任务门的`DPL`规定了访问该门的最外层特权级，只有在相同级或者更内层级的程序才可以访问它==。同时，==还要求指示任务门的选择子的`RPL`必须满足`RPL<=DPL`的条件==。==在这些条件满足时再检查任务门内的选择子，要求该选择子指示`GDT`中的可用`TSS`描述符==。在检查通过后，就开始任务切换。

### 3. 任务切换过程

根据指示目标任务`TSS`描述符的选择子进行任务切换的一般过程如下：

1. 第一，==测试目标任务状态段的界限==。TSS用于保存任务的各种状态信息，不同的务，TSS中可以有数量不等的其他信息，但根据图10.14所示的任务状态段基本格式，TSS的界限应大于或等于103。
2. 第二，==把寄存器现场保存到当前任务的`TSS`==。==把通用寄存器、段寄存器、`EIP`、`EFLAGS`的当前值保存到当前`TSS`中。保存的`EIP`的值是返回地址，指向引起任务切换指令的下一条指令。但不把`LDTR`和`CR3`内容保存到`TSS`中==。
3. 第三，==把指示目标任务`TSS`的选择子装入`TR`==。==同时，把对应`TSS`描述符装入`TR`高速缓冲寄存器中==。==此后，当前任务改称为原任务，目标任务改称为当前任务==
4. 第四，==基本恢复当前任务(目标任务)的寄存器现场==。==根据保存在`TSS`中的内容，恢复各通用寄存器、段寄存器、`EFLAGS`及`EIP`==。==在装入段寄存器的过程中，为了能正确地处理可能发生的异常，只把对应选择子装入各段寄存器==。==还装载`CR3`寄存器==。
5. 第五，进行链接处理。
   1. 如果需要链接，那么将指向原任务`TSS`的选择子写入当前任务`TSS`的链接字字段，把当前任务`TSS`描述符类型改为`忙`，并将标志寄存器`EFLAGS`中的`NT`位置1，表示是联套任务。
   2. 如果需要解链；那么把原任务`TSS`描述符类型改为`可用`。
   3. 如果无链接处理，那么将原任务`TSS`描述符类型置为`可用`，当前任务`TSS`描述符类型置为`忙`。
   4. 由`JMP`指令引起的任务切换不实施链接/解链处理；
   5. 由`CALL`指令、中断、`IRET`指令引起的任务切换要实施链接/解链处理
6. 第六，把`CR0`中的`TS`标志置为1。这表示已发生过任务切换，在当前任务使用协处理器指令时，产生自陷。由自陷处理程序完成有关协处理器现场的保存和恢复。这有利于快速地进行任务切换
7. 第七，把`TSS`中的`CS`选择子的`RPL`作为当前任务特权级设置为`CPL`。任务切换可以在一个任务的任何特权级发生，并可切换到另一任务的任何特权级。
8. 第八，装载`LDTR`寄存器。一个任务可以有自己的`LDT`，也可以没有。当任务没有`LDT`时，`TSS`中`LDT`选择子为0。如果`TSS`中`LDT`选择子非空，则从`GDT`中读出对应`LDT`描述符，在经过测试后，把所读`LDT`描述符装入`LDTR`高速缓冲寄存器。如果，`LDT`选择子为空，则将`LDT`的存在位置成0，表明任务不使用`LDT`。
9. 第九，装载代码段寄存器`CS`、堆栈段寄存器`SS`和各数据段寄存器及其它的高速缓冲寄存器。
10. 第十，把调试寄存器`DR7`中的局部启用位设置为0，以清除局部于原任务的各个断点和方式。

### 4. 关于任务状态和联套的说明

在段间转移指令`JMP`引起任务切换时，不实施链接，不导致任务的嵌套。它要求目标任务是可用的任务。切换过程中把原任务置为`可用`，目标任务置为`忙`。在段间调用指令`CALL`引起任务切换时，实施链接，导致任务的联套。它要求目标任务是可用的任务。在切换过程中把目标任务置为`忙`，原任务仍保持`忙`；标志寄存器`EFLAGS`中的`NT`位被置1，表示是嵌套任务。
在由中断/异常引起任务切换时，实施链接，导致任务的嵌套。要求目标任务是可用的任务。在切换过程中把目标任务置为`忙`，原任务仍保持`忙`；标志寄存器`EFLAG`中的`NT`位被置1，表示是嵌套任务。
在执行`IRET`时引起任务切换，那么实施解链。要求目标任务是忙的任务。在切换过程中把原任务置为`可用`，目标任务仍保持`忙`。
关于中断/异常如何引起任务切换和指令IRET如何考虑任务切换的内容在10.7节中介绍。

## 10.6.6 演示任务切换的实例(实例五)

下面给出一个用于演示任务切换的实例。该实例的逻辑功能是在任务切换后显示原任务的挂起点(`EIP`)值。该实例演示内容包括：直接通过`TSS`段的任务切换，通过任务门的任务切换，任务内特权级的变换及参数传递。

### 1. 实现流程

为了达到演示任务切换和特权级变换的目的，实例五在保护方式下涉及到两个任务，一个任务称为临时任务，另一个任务称为演示任务。演示任务的功能是演示通过调用门实现特权级的变换和堆栈间参数的自动复制。临时任务和演示任务配合展示任务切换。
实例五的主要实现步骤如图10.18所示。在图的右边标出了任务切换和特权级变换的分界情况。在任务切换时，把原任务的现场保存到`TR`所指示的`TSS`内，然后再把指向目标任务`TSS`描述符的选择子装入`TR`，所以，在从临时任务切换到演示任务之前，要把指向临时任务`TSS`描述符的选择子装入`TR`。通过把演示任务的`TSS`初始化成恢复点在特权级为2的代码段，使得在从临时任务切换到演示任务后，当前特权级`CPL=2`。

![image]（https://github.com/YangLuchao/img_host/raw/master/20231127/image.2j00gdf9abo0.jpg）

### 2.源程序组织和清单

实例五有如下部分组成：

1. 全局描述符表`GDT`。`GDT`含有演示任务`TSS`描述符和`LDT`段描述符，还含有临时任务`TSS`描述符和临时任务的代码段描述符，此外，还含有子程序代码段描述符、规范数据段描述符和视频缓冲区段描述符。
2. 演示任务的`TSS`段。已根据演示要求初始化。

3. 演示任务的`LDT`段。它含有演示任务的0级和2级堆栈段描述符、代码段和数据段描述符、分别以数据段方式描述`LDT`和临时任务`TSS`的数据段描述符、以及指向子程序的调用门和指向临时任务的任务门。

4. 演示任务的0级和2级堆栈段。32位段，特权级分别为0和2。

5. 演示任务数据段。32位段，特权级3。

6. 子程序代码段。32位代码段，特权级0。

7. 演示任务代码段。32位代码段，特权级2。

8. 临时任务的TSS段。未初始化。

9. 临时任务代码段。16位段，特权级0。

10. 实方式下的数据和代码段。


该实例的逻辑功能是在任务切换后显示原任务的挂起点值。源程序清单如下：

```assembly
;程序名：T10-5.ASM
;功能：演示任务切换和任务内特权级变换
;
INCLUDE 386SCD.ASM;参见实例三
.386P
;全局描述符表
GDTSEG SEGMENT 	PARA 	USE16
    ;全局描述符表标号
                 GDT       LABEL 	BYTE
                 
    ;空描述符
                 DUMMY     DESCRIPTOR 		<>

    ;规范描述符
    ;描述符的含义为，段界限为0FFFFH，基址为0h，属性为R0可读写数据段
                 NORMAL    DESCRIPTOR 		<0FFFFH,0,0,ATDW,0>
    ;NORMAL为GDT第二个描述符，一个描述符结构体的长度位8h，所以NORMAL - 0 = 0008h
    ;0008h = 0000 0000 0000 1000 = 0000000000001 0 00
    ;表示0环GDT中index = 1的描述符
    Normal_SEL   =         NORMAL - GDT

    ;全局描述符表任务定义描述符起始表示
                 EFFGDT    LABEL 	BYTE


    ;演示任务的任务状态段描述符
    ;描述符内容为，段界限为DemoTSSLEN - 1，基址为DemoTSSSEG段，属性为R0环386TSS类型值
                 DEMOTSS   DESCRIPTOR 		<DemoTSSLEN - 1,DemoTSSSEG,,AT386Tss,>
    ;DEMOTSS为GDT第三个描述符，一个描述符结构体的长度位8h，所以DEMOTSS - 0 = 0010h
    ;0010h = 0000 0000 0001 0000 = 0000000000010 0 00
    ;表示RPL=0环GDT中index = 2的描述符
    DemoTSS_SEL  =         DEMOTSS - GDT


    ;演示任务的局部描述符表段描述符
    ;描述符内容为，段界限为DemoLDTLEN - 1，基址为DemoLDTSEG段,属性为R0环局部描述符表段类型值
                 DEMOLDTAB DESCRIPTOR 		<DemoLDTLEN - 1,DemoLDTSEG,,ATLDT,>
    ;DEMOLDTAB为GDT第四个描述符，一个描述符结构体的长度位8h，所以DEMOLDTAB - 0 = 0018h
    ;0018h = 0000 0000 0001 1000 = 0000000000011 0 00
    ;表示RPL=0环GDT中index = 3的描述符
    DemoLDT_SEL  =         DEMOLDTAB - GDT


    ;临时任务的任务状态段描述符
    ;描述符内容为，段界限为TempTSSLEN - 1，基址为TempTSSSEG段，属性为R2环386TSS类型值
                 TEMPTSS   DESCRIPTOR 		<TempTSSLEN - 1,TempTSSSEG,,AT386TSS+DPL2,>
    ;TEMPTSS为GDT第五个描述符，一个描述符结构体的长度位8h，所以TEMPTSS - 0 = 0020h
    ;0020h = 0000 0000 0010 0000 = 0000000000100 0 00
    ;表示RPL=0环GDT中index = 4的描述符
    TempTSS_SEL  =         TEMPTSS - GDT


    ;临时任务代码段
    ;描述符内容为，段界限为0FFFFH，基址为TempCodeSEG段，属性为R0环可执行代码段
                 TEMPCODE  DESCRIPTOR 		<0FFFFH,TempCodeSEG,,ATCE,>
    ;TEMPCODE为GDT第六个描述符，一个描述符结构体的长度位8h，所以TEMPCODE - 0 = 0028h
    ;0028h = 0000 0000 0010 1000 = 0000000000101 0 00
    ;表示RPL=0环GDT中index = 5的描述符
    TempCode_SEL =         TEMPCODE - GDT


    ;子程序代码段描述符
    ;描述符内容为，段界限为SUBRLEN - 1，基址为SUBRSEG段，属性为R0环子程序代码段
                 SUBR      DESCRIPTOR 		<SUBRLEN - 1,SUBRSEG,,ATCE+D32,>
    ;SUBR为GDT第七个描述符，一个描述符结构体的长度位8h，所以SUBR - 0 = 0030h + 3h = 0033h
    ;0033h = 0000 0000 0011 0000 = 0000000000110 0 11
    ;表示RPL=3环GDT中index = 6的描述符
    SUBR_SEL     =         SUBR_GDT + RPL3


    ;显示缓冲区段描述符
    ;描述符内容为，段界限为0FFFFH，基址为0H，属性为R3环显示缓冲区段
                 VIDEOBUFF DESCRIPTOR 		<0FFFFH,0,0,0F00H+ATDW+DPL3,0>
    ;VIDEOBUFF为GDT第八个描述符，一个描述符结构体的长度位8h，所以VIDEOBUFF - 0 = 0038h
    ;0038h = 0000 0000 0011 1000 = 0000000000111 0 00
    ;表示RPL=0环GDT中index = 7的描述符
    Video_SEL    =         VIDEOBUFF - GDT

    ;可用的全局描述符个数
    GDNUM        =         ($ - EFFGDT)/(SIZE DESCRIPTOR)

    ;GDT长度
    GDTLEN       =         $	-	GDT
GDTSEG ENDS
;演示任务的任务状态段
DemoTSSSEG SEGMENT 	PARA 	USE16
               DD 0                   ;链接字
               DD DemoStack0LEN       ;0级堆栈指针
               DW DemoStack0_SEL,0
               DD 0                   ;1级堆栈指针(实例不使用)
               DW ?,0
               DD DemoStack2LEN       ;2级堆栈指针
               DW DemoStack2_SEL,0
               DD 0                   ;CR3
               DW DemoBegin,0         ;EIP
               DD 0                   ;EFLAGS
               DD 0                   ;EAX
               DD 0                   ;ECX
               DD 0                   ;EDX
               DD 0                   ;EBX
               DD DemoStack2LEN       ;ESP
               DD 0                   ;EBP
               DD 0                   ;ESI
               DD 0B8000H             ;EDI
               DW Video_SEL,0         ;ES
               DW DemoCode_SEL,0      ;CS
               DW DemoStack2_SEL,0    ;SS
               DW DemoData_SEL,0      ;DS
               DW ToDLDT_SEL,0        ;FS
               DW ToTTSS_SEL,0        ;GS
               DW DemoLDT_SEL,0       ;LDTR
               DW 0
               DW $ + 2               ;`I/O`许可位图指针
               DB 0FFH                ;`I/O`许可位图结束字节
    DemoTSSLEN =  $
DemoTSSSEG ENDS
;演示任务的局部描述符表LDT
DemoLDTSEG SEGMENT 	PARA 	USE16
    ;局部描述符表标号
                   DemoLDT    LABEL 	BYTE


    ;0级堆栈段描述符(32位段)
    ;描述符内容为，段界限为DemoStack0LEN - 1，基址为DemoStack0SEG段，属性为R0环32位可读写数据段
                   DEMOSTACKO DESCRIPTOR 		<DemoStack0LEN,,DemoStack0SEG,ATDW + D32,>
    ;DEMOSTACK0为LDT第一个描述符，一个描述符结构体的长度位8h，所以0 * 8 - 0 = 0h + 4h = 04h
    ;04h = 0000 0000 0000 0100 = 0000000000000 1 00
    ;表示RPL=0环LDT中index = 0的描述符
    DemoStackO_SEL =          (DEMOSTACK0 - DemoLDT) + TIL


    ;1级堆栈段描述符(32位段，DPL=2)
    ;描述符内容为，段界限为DemoStack1LEN - 1，基址为DemoStack1SEG段，属性为R2环32位可读写数据段
                   DEMOSTACK2 DESCRIPTOR 		<DemoStack2LEN - 1,DemoStack2SEG,ATDW+D32+DPL2,>
    ;DEMOSTACK1为LDT第二个描述符，一个描述符结构体的长度位8h，所以1*8 - 0 = 0008h + 4h = 0ch + 0001h = 0Dh
    ;0Dh = 0000 0000 0000 1101 = 0000000000001 1 01
    ;表示RPL=1环LDT中index = 1的描述符
    DemoStack2_SEL =          (DEMOSTACK2 - DemoLDT) + TIL + RPL2


    ;演示代码段描述符(32位段，DPL=2)
    ;描述符内容为，段界限为DemoCodeLEN - 1，基址为DemoCodeSEG段，属性为R2环32位可读写数据段
                   DEMOCODE   DESCRIPTOR 		<DemoCodeLEN - 1,DemoCodeSEG,,ATCE+D32+DPL2,>
    ;DEMOCODE为LDT第三个描述符，一个描述符结构体的长度位8h，所以2*8 - 0 = 0010h + 4h = 14h + 0001h = 15h
    ;15h = 0000 0000 0001 0101 = 0000000000010 1 01
    ;表示RPL=1环LDT中index = 2的描述符
    DemoCode_SEL   =          (DEMOCODE - DemoLDT) + TIL + RPL2


    ;演示数据段描述符(32位段，DPL=3)
    ;描述符内容为，段界限为DemoDataLEN - 1，基址为DemoDataSEG段，属性为R3环32位可读写数据段
                   DEMODATA   DESCRIPTOR 		<DemoDataLEN - 1,DemoDataSEG,,ATDW+D32+DPL3,>
    ;DEMODATA为LDT第四个描述符，一个描述符结构体的长度位8h，所以3*8 - 0 = 0018h + 4h = 1Ch
    ;1Ch = 0000 0000 0001 1100 = 0000000000011 1 00
    ;表示RPL=0环LDT中index = 3的描述符
    DemoData_SEL   =          (DEMODATA - DemoLDT) + TIL


    ;把LDT作为普通数据段描述的描述符(DPL=2)
    ;描述符内容为，段界限为DemoLDTLEN - 1，基址为DemoLDTSEG段，属性为R2环32位可读写数据段
                   TODLDT     DESCRIPTOR 		<DemoLDTLEN - 1,DemoLDTSEG,,ATDW+DPL2,>
    ;TODLDT为LDT第五个描述符，一个描述符结构体的长度位8h，所以4*8 - 0 = 0020h + 4h = 24h
    ;24h = 0000 0000 0010 0100 = 0000000000100 1 00
    ;表示RPL=0环LDT中index = 4的描述符
    ToDLDT_SEL     =          (TODLDT - DemoLDT) + TIL


    ;把TSS作为普通数据段描述的描述符(DPL=2)
    ;描述符内容为，段界限为TempTSSLEN - 1，基址为TempTSSSEG段，属性为R2环386TSS类型值
                   TOTTSS     DESCRIPTOR 		<TempTSSLEN - 1,TempTSSSEG,,ATDW+DPL2,>
    ;TOTTSS为LDT第六个描述符，一个描述符结构体的长度位8h，所以5*8 - 0 = 0028h + 4h = 2Ch
    ;2Ch = 0000 0000 0010 1100 = 0000000000101 1 00
    ;表示RPL=0环LDT中index = 5的描述符
    ToTTSS_SEL     =          (TOTTSS - DemoLDT)	+	TIL

    ;演示任务的LDT描述符个数
    DemoLDNUM      =          ($	-	DemoLDT)/(SIZE DESCRIPTOR)


    ;指向子程序SUBRB的调用门(DPL=3)
    ;TOSUBR为门描述符，含义为，SUBRB为偏移低16位，SUBR_SEL为目标选择子，0为参数计数器，AT386CGAT+DPL3为3环386调用门类型值，0为偏移高16位
                   TOSUBR     GATE 			<SUBRB,SUBR_SEL,0,AT386CGAT+DPL3,0>
    ;TOSUBR为LDT第七个描述符，一个描述符结构体的长度位8h，所以6 * 8 - 0 = 0030h + 4h = 34h
    ;34h = 0000 0000 0011 0100 = 0000000000110 1 10
    ;表示RPL=2环LDT中index = 6的描述符
    TOSUBR_SEL     =          (TOSUBR - DemoLDT) + TIL + RPL2


    ;指向临时任务Temp的任务门(DPL=3)
    ;TOTEMPT为门描述符，含义为，0为偏移低16位，TempTSS_SEL为目标选择子，0为参数计数器，AT386CGAT+DPL3为3环386调用门类型值，0为偏移高16位
                   TOTEMPT    GATE 			<0,TempTSS_SEL,0,ATTASKGAT+DPL3,0>
    ;TOTEMPT为LDT第八个描述符，一个描述符结构体的长度位8h，所以7 * 8 - 0 = 0038h + 4h = 38h
    ;38h = 0000 0000 0011 1000 = 0000000000111 1 00
    ;表示RPL=0环LDT中index = 7的描述符
    ToTempT_SEL    =          (TOTEMPT - DemoLDT) + TIL

    ;演示任务的LDT长度
    DemoLDTLEN     =          $ 	- 	DemoLDT
DemoLDTSEG ENDS
;演示任务的0级堆栈(32位段)
DemoStackOSEG SEGMENT 	PARA 	USE32
    DemoStackOLEN =  1024
                  DB DemoStack0LEN 	DUP (0)
DemoStackOSEG ENDS
;演示任务的2级堆栈(32位段)
DemoStack2SEG SEGMENT 	PARA 	USE32
    DemoStack2LEN =  512
                  DB DemoStack2LEN 	DUP (0)
DemoStack2SEG ENDS
;演示任务的数据段(32位段)
DemoDataSEG SEGMENT 	PARA 	USE32
    Message     DB 'Value=',0
    DemoDataLEN =  $
DemoDataSEG ENDS
;子程序段(32位段)
;CPL=0
;使用0级堆栈
SUBRSEG SEGMENT 	PARA 	USE32
            ASSUME     CS:SUBRSEG
SUBRB PROC 	FAR
            PUSH       EBP
            MOV        EBP,ESP
            PUSHAD                     ;保护现场
    ;从堆栈(0级)中取提示信息串偏移
    ;为什么是+12？
    ;+4是外层EIP
    ;+8是外层CS
    ;+12是第2个参数，Message起始地址
            MOV        EAX,[EBP+12]
            MOV        ESI,EAX
            MOV        AH,7
            JMP        SHORT SUBR2
    SUBR1:                             ;输出message信息与TempTask.TREIP
            STOSW
    SUBR2:  
            LODSB
            OR         AL,AL
            JNZ        SUBR1           ;从堆栈(0级)中取显示值
            MOV        EDX.[EBP+16]
            MOV        ECX,8
    SUBR3:  
            ROL        EDX,
            MOV        AL,DL
            CALL       HTOASC
            STOSW
            LOOP       SUBR3
            POPAD                      ;恢复现场
            POP        EBP
            RET        8               ;ret 8 堆栈平衡
SUBRB ENDP
HTOASC PROC
            AND        AL,0FH
            ADD        AL,90H
            DAA
            ADC        AL,40H
            DAA
            RET
            HTOASCENDP
    SUBRLEN =          $
SUBRSEG ENDS
;演示任务的代码段(32位段)
;从R0切换过来，CPL=2
DemoCodeSEG SEGMENT 	PARA 	USE32
                ASSUME CS:DemoCodeSEG
    DemoBegin:  
    ;表示在特权级向内层变换时，需从外层堆栈依次复制2个双字参数到内层堆栈
                MOV    FS:ToSUBR.DCOUNT,2
    ;向堆栈(2级)中压入参数
    ;TempTask 是临时任务TSS，当前要通过调用们进行特权集切换，现将返回地址压入对账
    ;将提示信息前缀压入堆栈
                PUSH   DWORD PTR GS:TempTask.TREIP
                PUSH   OFFSET Message
    ;通过调用门调用子程序 SUBRB
    ;选择子 TOSUBR_SEL RPL=2
    ;选择子 TOSUBR_SEL 指向的 TOSUBR 调用门 DPL=3 可以调用
    ;执行调用门 TOSUBR
    ;调用门指向 SUBR_SEL 选择子，RPL=0，且偏移为 SUBRB
    ;SUBR_SEL 选择子 RPL=3 指向的段为 SUBRSEG DPL=0
    ;特权集进行切换，堆栈也进行了切换
                CALL32 ToSUBR_SEL,0
    ;SUBRB的返回，`CPL=0`变换为`CPL=2`，堆栈也回到2级堆栈
    ;把指向规范数据段描述符的选择子填入临时任务TSS
                ASSUME DS:TempTSSSEG
                PUSH   GS
                POP    DS
                MOV    AX,Normal.SEL
                MOV    TempTask.TRDS,AX
                MOV    TempTask.TRES.AX
                MOV    TempTask.TRFS,AX
                MOV    TempTask.TRGS,AX
                MOV    TempTask.TRSS,AX
    ;通过任务切换到临时任务
    ;CPL=2
    ;ToTempT_SEL RPL=0
    ;ToTempT_SEL 指向的 TempTSS_SEL DPL=3，偏移为0
    ;TempTSS_SEL RPL=0 指向 TempTSSSEG DPL=2
    ;跳转TSS.CS TSS.EIP
    ;跳转CS:TempCodeSEG，EIP:ToReal
                JUMP32 ToTempT_SEL,0
    DemoCodeLEN =      $
DemoCodeSEG ENDS
;临时任务的任务状态段
TempTSSSEG SEGMENT 	PARA 	USE16
               TempTask TASKSS	<>
               DB       0FFH
    TempTSSLEN =        $
TempTSSSEG ENDS
;临时任务的代码段
TempCodeSEG SEGMENT 	PARA 	USE16
                 ASSUME CS:TempCodeSEC
    Virtual:     
    ;将 TempTSS 装载到 TR
    ;TempTSS_SEL 的 RPl=0
    ;TempTSS_SEL 指向的 TEMPTSS 的 DPL=2
                 MOV    BX,TempTSS_SEL
                 LTR    BX                          ;要把临时任务的现场保存到临时任务的`TSS`，这就要求`TR`指向临时任务的`TSS`
    ;CPL=0
    ;DemoTSS_SEL 的 RPL= 0
    ;DemoTSS_SEL 指向 DemoTSSSEG 的 DPL=0
    ;DemoTSSSEG 为定义的TSS段，预定义的CS=DemoCode_SEL,EIP=DemoBegin
    ;DemoCode_SEL 为指向 DemoCodeSEG 的选择子，RPL=2，DPL=2
    ;采用段间转移指令`JMP`，直接指向演示任务的`TSS`，切换到演示任务，切换动作包括
    ;1：把临时任务的执行现场保存到临时任务的`TSS`中
    ;2：从演示任务的`TSS`中恢复演示任务的现场
    ;3：把演示任务的`LDT`描述符选择子装载到`LDTR`等
                 JUMP16 DemoTSS_SEL,0               ;直接切换到演示任务
    ;TSS中的CS:TempCodeSEG，EIP:ToReal
    ToReal:                                         ;准备返回实方式
                 CLTS                               ;清空TS
    ;清任务切换标志
                 MOV    EAX,CR0
                 AND    EAX,0FFFFFFFEH
                 MOV    CR0,EAX                     ;PE位置0，返回实模式
    ;返回实方式
                 JUMP16 <SEG Real>,<OFFSET Real>
    TempCodel_EN =      $
TempCodeSEG ENDS
;实方式数据段
RDataSEG SEGMENT 	PARA 	USE16
             VGDTR PDESC <GDTLEN-1,>
    SPVAR    DW    ?
    SSVAR    DW    ?
RDataSEG ENDS
;实方式代码段
RCodeSEG SEGMENT 	PARA 	USE16
             ASSUME CS:RCodeSEG,DS:RDataSEG,ES:RDataSEG
    Start:   
             MOV    AX,RDataSEG
             MOV    DS,AX                                  ;装载实模式数据段
             CLD                                           ;设置方向标志
             CALL   INIT_GDT                               ;初始化GDT
             MOV    AX,DemoLDTSEG
             MOV    FS,AX
             MOV    CX,DemoLDNUM
             MOV    SI,OFFSET DemoLDT
             CALL   INIT_LDT                               ;初始化演示任务LDT
  
             MOV    SSVAR,SS
             MOV    SPVAR,SP                               ;保存实方式下的堆栈指针


             LGDT   QWORD PTR VGDTR                        ;装载GDTR
             CLI                                           ;关中断
             MOV    EAX,CR0
             OR     EAX,1
             MOV    CR0,EAX                                ;CR0的PE位置为1，切换到保护模式
    ;切换到保护方式
    ;CPL=0 TempCode_SEL(RPL=0) 可以调用
    ;TempCode_SEL 指向的 TempCodeSEG DPL=0，可以跳转
             JUMP16 <TempCode_SEL>,<OFFSET Virtual>
    Real:    
    ;又回到实方式
             MOV    AX,RDataSEG
             MOV    DS,AX
             LSS    SP,DWORD PTR SPVAR                     ;将源操作数加载到目标操作数中，并且 TR 寄存器的内容更新为源操作数
             STI                                           ;开中断
             MOV    AX,4C00H
             INT    21H
    ;初始化全局描述符表的子程序
    ;(1)把定义时预置的段值转换成32位段基地址并置入描述符内相应字段
    ;(2)初始化为GDTR准备的伪描述符
INIT_GDT PROC 	NEAR
             PUSH   DS
             MOV    AX,GDTSEG                              ;定义的GDT段段值挪到AX中
             MOV    DS,AX                                  ;定义的GDT段段值挪到DS中
             MOV    CX,GDNUM                               ;GDNUM是初始化的描述符个数
             MOV    SI,OFFSET EFFGDT                       ;EFFGDT是开始偏移
    ;将描述符中的基址扩展到32位
    INITG:   
             MOV    AX,[SI].BASEL                          ;取出预置的段值
             MOVZX  EAX,AX                                 ;将初始化进去的16位段值扩展到32位
             SHL    EAX,4                                  ;段值左移4位
             SHLD   EDX,EAX,16                             ;分解到2个16位寄存器
             MOV    [SI].BASEL,AX
             MOV    [SI].BASEM,DL                          ;置入描述符相应字段
             MOV    [SI].BASEH,DH
             ADD    SI,SIZE DESCRIPTOR                     ;调整到下一描述符
             LOOP   INITG                                  ;所有描述符处理完后，退出循环
    ;描述符中的基址扩展完成
             POP    DS
    ;初始化为GDTR准备的伪描述符
             MOV    BX,16
             MOV    AX,GDTSEG
             MUL    BX
             MOV    WORD PTR VGDTR.BASE,AX
             MOV    WORD PTR VGDTR.BASE+2,DX               ;VGDTR初始化完成
             RET
INIT_GDT ENDP
    ;初始化演示任务局部描述符表的子程序
    ;把定义时预置的段值转换成32位段基地址并置入描述符内相应字段
    ;入口参数：FS:SI=第一个要初始化的描述符
    ;CX=要初始化的描述符个数
INIT_LDT PROC
    ;将初始化进去的16位段值扩展到32位
    ILDT:    
             MOV    AX,FS:[SI].BASEL
             MOVZX  EAX,AX
             SHL    EAX,4
             SHLD   EDX,EAX.16
             MOV    FS:[SI].BASEL,AX
             MOV    FS:[SI].BASEM,DL
             MOV    FS:[SI].BASEH,DH
             ADD    SI,SIZE DESCRIPTOR
             LOOP   ILDT
    ;将初始化进去的16位段值扩展到32位结束
             RET
INIT_LDT ENDP
RCodeSEG ENDS
	END Start
```

### 3.关于实例五的说明

程序中部分片段的背景和实现方法已在前面的实例中做过介绍，下面主要就任务切换和通过调用门实现任务内特权级变换时参数的复制等情形作些说明：

#### (1)从临时任务直接通过TSS切换到演示任务

在从实方式切换到保护方式后，就认为进入了临时任务。但`TR`并没有指向临时任务的`TSS`。在从临时任务切换到演示任务时，==要把临时任务的现场保存到临时任务的`TSS`，这就要求`TR`指向临时任务的`TSS`==。所以，首先要使用`LTR`指令把指向临时任务`TSS`描述符的选择子装入`TR`。在利用`LTR`指令显式地装载`TR`时，并不引用`TSS`的内容，所以临时任务的`TSS`几乎没有初始化。理由是这不是真正的任务切换

==临时任务采用段间转移指令`JMP`，直接指向演示任务的`TSS`，切换到演示任务==。在执行切换到演示任务的段间转移指令`JMP`时，`CPL=0`，`JMP`指令中所含选择子内的`RPL=0`，演示任务`TSS`的描述符`DPL=0`，并且是一个可用的`TSS`，所以顺利进行从临时任务到演示任务的切换。切换过程包括：

- 把临时任务的执行现场保存到临时任务的`TSS`中；
- 从演示任务的`TSS`中恢复演示任务的现场；
- 把演示任务的`LDT`描述符选择子装载到`LDTR`等。

从源程序可见，初始化后的演示任务`TSS`中`CS`字段存放的选择子是DemoCode_SEL，对应的描述符在演示任务的`LDT`中，并且`DPL=2`，它描述了代码段DemoCode;挂起点是DemoBegin，所以在切换到演示任务后从该点开始执行，并且`CPL=2`。==由于使用`JMP`指令进行任务切换，所以不实施任务链接==。

#### (2)从演示任务通过任务门切换到临时任务

==演示任务采用段间转移指令`JMP`，通过任务门TOTEMPT切换到临时任务==。在执行切换到临时任务的段间转移指令`JMP`时，`CPL=2`，`JMP`指令中所含选择子ToTempT_SEL内的`RPL=0`，它指示的任务门`DPL=3`，所以可以访问该任务门。任务门内的选择子TempTSS_SEL指示临时任务`TSS`，并且此时的临时任务`TSS`是可用的，所以可顺利进行任务切换。演示任务的现场保存到演示任务的`TSS`；临时任务的现场从临时任务的`TSS`恢复。
临时任务的挂起点是临时任务代码段内的ToReal点，所以恢复后的临时任务从该点开始，`CS`含临时任务代码段选择子。但由于在演示任务内`强硬`地改变了临时任务`TSS`内的`SS`和`DS`等字段，所以在恢复到临时任务时，`SS`和`DS`等段寄存器内已含规范数据段的选择子，而非挂起时的原有值。注意，这种做法不被提倡，但在这里却充分地展示如何从`TSS`恢复任务。

#### (3)演示任务内的特权级变换和堆栈传递参数

演示任务采用段间调用指令`CALL`，通过调用门TOSUBR调用子程序SUBRB。执行段间调用指令`CALL`时的`CPL=2`，指令所含指向调用门的选择子`RPL=2`，调用门的`DPL=3`，所以对调用门的访问是允许的；尽管调用门内的选择子`RPL=3`，但由于它所指示的子程序代码段描述符`DPL=0`，所以在==调用过程中就发生了从特权级2到特权级0的变换，同时堆栈也被切换==。

演示代码通过堆栈传递了两个参数给子程序SUBRB。在把参数压入堆栈时，`CPL=2`，使用的也是对应特权级2的堆栈。通过调用门进入子程序后，`CPL=0`，使用0级堆栈。为此，把调用门TOSUBR中的DCOUNT字段设置为2，==表示在特权级向内层变换时，需从外层堆栈依次复制2个双字参数到内层堆栈==。随着特权级变换，堆栈也跟着变换，如图10.15所示。这种在堆栈切换的同时复制所需参数的做法，保证了子程序方便地访问堆栈中的参数，而无需考虑是哪个堆栈。
==随着从子程序SUBRB的返回，`CPL=0`变换为`CPL=2`，堆栈也回到2级堆栈==。由于再进入0级堆栈时，总是从空开始，所以在返回前不是非要保持内层堆栈平衡的。但2级堆栈中的2个双字参数需要废除。从源程序可见，这是采用带立即数的段间返回指令实现的，在返回的同时自动废除外层堆栈中的参数。

#### (4)别名技术的应用

在10.6.2节对实例三作说明时，已介绍过别名技术。实例五也有两处应用了别名技术。
为了把调用门TOSUBR中的DCOUNT字段设置成2，使用一个数据段描述符TODLDT描述调用门所在演示任务`LDT`段，该描述符把演示任务的`LDT`段描述成数据段。请读者考虑源程序如何把指向该数据段描述符的选择子装载到FS寄存器。
还有一处是把临时任务的`TSS`视作为普通数据段。在从演示任务切换到临时任务之前，把指向描述规范数据段的描述符NORMAL的选择子Normal.SEL填到临时任务TSS中的各数据段寄存器(包括堆栈段寄存器)字段，于是在切换到临时任务时，作为恢复临时任务的现场，该选择子就被装到DS等数据段寄存器，对应的描述符NORMAL内的信息也就被装入到对应的高速缓冲寄存器中，达到为从临时任务切换到实方式作准备的目的。
