[toc]

Intel的80486和Pentium是80x86家族的新成员，它们保持与80386的兼容。本章在前两章的基础上介绍80486和Pentium。本章不涉及浮点处理部件方面的内容

# 11.1 80486程序设计基础

80486是80x86家族中继80386之后又一种功能更强大的32位微处理器。80486有80486DX和80486SX两款，80486DX是在80386的基础上集成浮点处理部件和超高速缓存而构成的，80486SX不包含浮点处理部件。由于我们几乎不涉及浮点处理方面的内容，所以把它们简单地统称为80486,而不加区分从程序设计的角度看，80486只比80386多了几个控制位和6条指令，所以第9章和第10章介绍的内容对80486仍有效。

## 11.1.1 寄存器

80486不仅兼容80386,而且还在片上集成了相当于80387的浮点处理部件，所以80486含有80386和80387所拥有的全部32位寄存器。这些寄存器可分为如下几类：

1. 基本结构寄存器，包括通用寄存器、段寄存器、指令指针和标志寄存器。
2. 系统级寄存器，包括控制寄存器和系统地址寄存器。
3. 浮点处理部件FPU寄存器，包括数据寄存器、标志字、状态字、控制字、指令和数据指示字。
4. 调试和测试寄存器。

### 1. 基本结构寄存器及标志寄存器

80486的8个32位的通用寄存器与80386相同，6个段寄存器与80386相同，指令指针也与80386相同。请参见图9.1。
80486的标志寄存器`EFLAGS`仍是32位，如图11.1所示。与图9.2所示的80386标志寄存器相比，80486的标志寄存器新增了一个==对齐检查标志`AC`==。其他标志位的位置及意义保持与80386相同。

![image](https://github.com/YangLuchao/img_host/raw/master/20231128/image.64fq186caic0.jpg)

标志位AC参与控制地址不对齐异常的发生。所谓地址不对齐是指如下情形：访问一个奇地址的字，或访问地址不是4的倍数的双字等等。==如果AC置1，那么当出现地址不对齐情形时，引起地址对齐异常。但在特权级0、1和2运行时，忽略AC位的设置，在CR0中的AM位为1时也忽略AC位的设置==。地址对齐异常是80486新设置的异常，属于故障类异常，向量号规定为11H。80486地址对齐异常提供出错码0。只有在特权级3运行的应用程序才可能引起地址对齐故障。

### 2. 系统级寄存器及控制寄存器

系统地址寄存器是指全局描述符表寄存器`GDTR`、局部描述符表寄存器`LDTR`、中断描述符表寄存器`IDTR`和任务状态段寄存器`TR`。80486的这些系统地址寄存器与80386对应的系统地址寄存器相同。请参见图10.9。
==80486仍只包括3个控制寄存器`CR0`、`CR2`和`CR3`。`CR2`用于指示引起页面故障的线性地址。`CR0`新设了5个控制位。`CR3`新设了2个控制位==。

#### (1) 控制寄存器CR0

图11.2给出了80486控制寄存器`CR0`各位的定义。与如图10.9所示的80386控制寄存器`CR0`相比较，80486的`CR0`新定义了如下控制位：用于控制片上超高速缓存工作方式的`CD`位和`NW`位；对齐屏蔽位`AM`；页面写保护位`WP`；数字异常位`NE`。

![image](https://github.com/YangLuchao/img_host/raw/master/20231128/image.6hx1vplbvow0.jpg)

==`PE`位控制80486工作于实方式还是保护方式，`PG`位控制是否启用分页机制==，它们的作用与80386保持兼容，它们组合定义的处理器工作方式如表10.3所列。
由于80486含浮点处理部件，所以处理器扩展类型位ET总是1。
位`TS`、`EM`和`MP`的作用与80386保持兼容。只是它们控制片上浮点处理部件。==新设的数字异常位`NE`控制通过哪种方式报告未屏蔽的浮点部件出错故障==。

- `NE=0`采用外部中断方式报告。这种方式是系统复位时的缺省方式，保持与先前微机系统的处理方式相一致。也即当浮点部件出错时，导致中断向量号为0DH的外部中断。
- `NE=1`，通过引起浮点部件出错故障报告，对应中断向量号为10H。请参见10.7.2节。

新设的对齐屏蔽位`AM`控制标志寄存器`EFLAGS`中的对齐检查标志`AC`是否有效。

- `AM=0`，忽略`AC`位。这是系统复位时的缺省状态，以便保持与80386兼容。
- `AM=1`，考虑`AC`位，这时才可能引起地址对齐异常。

新设的页面写保护位`WP`控制系统级程序写访问只读页面。80386允许系统特权级(0级、1级和2级)程序写访问只读页面，请参见10.10.3节。在80486中，这种情况受到`WP`位的控制。

- `WP=0`，保持与80386兼容，这是系统复位时的缺省状态。
- `WP=1`，任何特权级程序向只读页面写访问，都将引起页故障。

新设的片上超高速缓存控制位`CD`控制是否允许超高速缓存填充。

- `CD=0`，允许片上超高速缓存填充。
- `CD=1`，禁止片上超高速缓存填充。

新设的片上超高速缓存直写方式控制位`NW`控制是否采用直写方式。

- `NW=1`，采用直写方式和允许使无效，这是系统复位时的缺省状态。
- `NW=0`，禁止直写方式及使无效。关于这两个控制位的详细说明请参见11.1.4节。

为了严格与先前的处理器兼容，装入机器状态字指令LMSW，不能改变ET位和NE位。

#### (2) 控制寄存器CR3

如图10.9所示，==`CR3`的高20位是页目录表所在物理页的页码==。在80386中，`CR3`的低12位保留未用。==80486在`CR3`的低12位中定义了2个新的控制位`PCD`和`PWT`==,如图11.3所示。

![image](https://github.com/YangLuchao/img_host/raw/master/20231128/image.7j0tc58ijyo0.jpg)

80486的页目录表和页表项也在位4和位3的位置定义了`PCD`和`PWT`位，也就是说在如图10.28所示的表项格式的位4是`PCD`位，位3是PWT位。
控制寄存器`CR3`、页目录表和页表中的这两个控制位参与控制页面可超高速缓存性。

### 3. 调试和测试寄存器

80486象80386一样含有6个调试寄存器，它们分别是`DR0`、`DR1`、`DR2`、`DR3`、`DR6`和`DR7`。在11.2节介绍调试寄存器的使用。
80486含有5个测试寄存器。`TR6`和`TR7`用于支持转换后援缓冲器`TLB`的测试，这与80386相同。`TR3`、`TR4`和`TR5`用于测试片上超高速缓存。

## 11.1.2 指令系统

80486的指令集是在80386指令集的基础上增加了6条新指令。所以，80486的指令集包含了80386的指令集，并保持与80386兼容。新增的指令主要用于片上高速缓存的清洗和对多处理器系统的支持。下面就只介绍新增的6条指令。

### 1.字节交换指令BSWAP

==字节交换指令==的格式如下：

```assembly
BSWAP 	OPRD
```

其中操作数OPRD是任一32位通用寄存器。字节交换指令BSWAP的功能是在操作数OPRD内交换4个字节的顺序。==交换对应关系是：第0字节与第3字节交换，第1字节与第2字节交换==，如图11.4所示。
例如：

```assembly
BSWAP EAX	;设EAX=11223344H,执行后EAX=44332211H
BSWAP ESI	;设ESI=87654321H,执行后ESI=21436587H
```

该指令不影响各标志。

![image](https://github.com/YangLuchao/img_host/raw/master/20231128/image.1y67j6f7k05c.jpg)

80x86系列处理器按`高高低低`的原则存储多字节数据，但某些处理器按`低低高高`原则存储数据。BSWAP指令特别适宜于这两种数据格式之间的转换

### 2.交换加指令

==交换加指令==的格式如下：

```assembly
XADD 	OPRD1,OPRD2
```

==交换加指令`XADD`的功能是交换操作数OPRD1和OPRD2的内容，并把两个操作数相加结果送到操作数OPRD1中==。其中操作数OPRD1可以是8位、16位或32位通用寄存器或者存储单元，操作数OPRD2只能是8位、16位或32位通用寄存器。两个操作数的尺寸必须一致。
例如：

```assembly
XADD 	AL,AH		;设AX=1122H,执行后AX=2233H
XADD 	[BX],ESI
XADD 	[ECX+3],AL
```

==`XADD`指令按照一条相当于`ADD`指令的操作设置标志寄存器中的各运算结果标`XADD`指令的功能相当于连续的交换指令`XCHG`和加运算指令`ADD`的功能==。但该指令能更好地实现信号量操作。例如：

```assembly
MOV 	AL,1		;信号量增值
XADD 	Sema,AL		;增加
JC 		Failed		;未到转，但已取得原信号量值
```

==当在`XADD`指令前加`LOCK`前缀时，能方便地实现多处理器场合的信号量操作==。

### 3. 比较交换指令CMPXCHG

==比较交换指令==的格式如下：

```assembly
CMPXCHG 	OPRD1,OPRD2
```

==其中操作数OPRD1可以是8位、16位或32位通用寄存器或者存储单元；操作数OPRD2只能是通用寄存器，并且尺寸必须与OPRD1相一致==。==比较交换指令的功能是把对应尺寸的累加器(`EAX`、`AX`、`AL`)与操作数OPRD1比较，如果相等，把操作数OPRD2的内容送操作数OPRD1，并置零标志ZF==；==如果不等，把操作数OPRD1的内容送累加器，并清零标志ZF==。
例如：

```assembly
CMPXCHG 	BL,CL
CMPXCHG 	[EDX],SI
CMPXCHG 	[SI],EAX
```

该指令按比较结果影响有关标志。
在加上`LOCK`前级后，该指令对多处理器情况下的信号量操作非常有用。

### 4. 使超高速缓存无效指令INVD

==使超高速缓存无效指令==的格式如下：

```assembly
INVD
```

==该指令使片上超高速缓存无效，也即清洗片上超高速缓存。该指令也产生一个特殊的总线周期，它可以用于使外部(二级)超高速缓存无效==。注意，该指令不把片上超高速缓存中的内容写回主存，所以使用时必须十分小心，通常应使用`WBINVD`指令。
该指令不影响各标志。
该指令是特权指令。只有在实方式和保护方式的特权级0下，才可执行该指令。
我们在11.1.3节介绍片上超高速缓存的有关内容，和举例说明INVD指令的使用。

### 5. 写回并使超高速缓存无效指令WBINVD

==写回并使超高速缓存无效指令==的格式如下：

```assembly
WBINVD
```

==该指令使片上超高速缓存无效，也即清洗片上超高速缓存，但在清洗前把片上超高速缓存中更改的内容写回主存==。==该指令会产生特殊的总线周期，指示把外部超高速缓存中更改的内容写回主存和指示外部超高速缓存无效==。
==通常应该使用该指令清洗片上超高速缓存==。
==该指令不影响各标志==。
==该指令是特权指令。只有在实方式和保护方式的特权级0下，才可执行该指令==。

### 6. 使TLB项无效指令INVLPG

我们知道，==在启用分页机制的情况下，分页部件利用页目录表和页表把线性地址转换成物理地址。为了加快转换速度，80386和80486片上都有转换后援缓冲器`TLB`。`TLB`含32个项，用于存放当前最常使用的物理页的页码==。
使TLB项无效指令的格式如下：

```assembly
INVLPG OPRD
```

其中操作数OPRD必须是存储器操作数。该指令的功能是，如果存储器操作数OPRD能通过TLB中的某项转换成物理地址，那么使TLB内对应项无效。
例如：

```assembly
INVLPG	[BX]
INVLPG	[ECX*2+30H]
```

该指令不影响各标志。

该指令是特权指令。只有在实方式和保护方式的特权级0下，才可执行该指令。只有在特殊情况下才使用该指令，强制更新某些TLB项。

## 11.1.3 片上超高速缓存

为了进一步提高性能，80486在片上带有8K字节的超高速缓存器。它对软件是透明的，以保证与80×86系列先前的处理器兼容。尽管超高速缓存器是透明的，但了解它的组织和工作方式，对优化程序很有益。下面简单介绍片上超高速缓存的组织和工作方式，同时说明控制寄存器`CR0`中控制位`CD`和`NW`等的作用。

### 1. 片上超高速缓存及其工作方式的控制

80486的8K字节片上超高速缓存既能存储数据又能存储代码(指令)。8K字节容量指能用于存储数据或指令的容量，而不包括用于存储地址标记等的容量。
片上超高速缓存采用4路组相关联结构，在物理上分成4个2K字节的块。每块由128行构成，每行16字节宽。在逻辑上，分成128组，每组4行。每行都有一个21位的标记相关联，记录每行与主存储器中存储单元的对应关系，这21位的标记相当于主存储器中存储单元物理地址的高端部分。每一行都有一个有效位相关联，每行不是有效就是无效，没有部分有效的行。每行还有用于记录最近最少使用情况的LRU位相关联。
==超高速缓存命中是指欲访问的存储单元地址作为有效标记部分出现在超高速缓存中==。==如果是读命中，那么直接从片上超高速缓存中读出，从而大大提高速度==。==如果读未命中，那么通常会把该存储单元所在行填入超高速缓存==。==如果写命中超高速缓存，那么80486通常(采用直写方式时)不仅向超高速缓存相应单元写，同时也向主存储器相应单元写==。==如果写未命中，那么直接写入主存储器相应单元，不影响超高速缓存==。
==片上超高速缓存的工作方式由控制寄存器`CR0`中的`CD`位和`NW`位控制==。其中，==`CD`位允许和禁止填充片上超高速缓存，`NW`位控制直写和使无效==。由`CD`位和`NW`位组合定义的片上超高速缓存的工作方式比较灵活，列于表11.1。尽管两位可表示4种方式，但`CD=0`和`NW=1`的组合是无效组合，会引起通用保护故障。在RESET后的缺省组合是`CD=1`和`NW=1`,超高速缓存为空。

![image](https://github.com/YangLuchao/img_host/raw/master/20231128/image.5j4sc062im00.jpg)

==`CD=0`允许超高速缓存填充==。==当读访问存储单元时，如果未命中片上超高速缓存，那么所读存储单元所在行通常就会被填充到超高速缓存，并且物理地址的高端部分就作为该行的标记==。在处理器外部，通过其他途径可以阻止某些存储单元不被超高速缓存，这是不通常情况。在把某行填充到超高速缓存时，首先检查该组中所有的4行是否都有效，如果有无效行，则更新该行，如果都有效，那么采用最近最不常使用算法确定更新哪一行。
==`CD=1`禁止超高速缓存填充==。==当读访问存储单元未命中片上超高速缓存时，不把所在行填充到超高速缓存==。不影响读命中超高速缓存，不影响写命中超高速缓存和写未命中超高速缓存的动作。
==`NW=0`允许直写和使无效==。==当写访问命中超高速缓存时，所写信息写入片上超高速缓存，同时驱动一个外部写总线周期，更新外部对应存储单元==。==80486集成有监视其他外部系统写入主存储器的逻辑，当它检查到其他外部系统写入主存储器的存储单元命中片上超高速缓存时，就使片上超高速缓存的对应行无效。这就是使无效==。==它在保证超高速缓存的内容与对应主存储器的内容保持一致方面起重要作用==。
==`NW=1`禁止直写和使无效==。==当写访问命中超高速缓存时，更新片上超高速缓存相应行，但不更新外部对应存储单元==。==当其他外部系统更新主存储器的存储单元命中片上超高速缓存时，并不使片上超高速缓存对应行无效==。==这种处理方法会导致片上超高速缓存内容与对应主存储器的内容不一致==。

### 2. 演示片上超高速缓存作用的实例

下面给出一个演示片上超高速缓存如何提高速度性能的演示程序。演示程序含有一个循环访问某些存储单元的测试子程序，该测试子程序还能测定运行所耗时间。演示程序在允许和禁止片上超高速缓存两种情况下，分别调用该测试子程序，然后显示两种情况下运行同一子程序所耗时间。该演示程序在80486实方式下运行。源程序清单如下：

```assembly
;程序名：T11-1.ASM
;功能：演示片上高速缓存的作用
;说明：仅在80486实方式下运行(用TASM汇编，用TLINK连接)
CDBIT	=	30		;CR0种的CD位位置
COUNT 	= 	100
	.486P
;识别486指令集
CSEG 	SEGMENT 	PARA 	USE16
	CacheD 	DB 'Cache Disable: $'
	CacheE 	DB 'Cache Enable: $'
	ASSUME 	CS:CSEG
BEGIN:
	PUSH	CS
	POP 	DS		;使数据段同代码段
Step1:;在禁止片上超高速缓存的情况下调用测试子程序
	CLI
	MOV 	EAX,CR0
	BTS 	EAX,CDBIT
	MOV 	CR0,EAX	;置CD位，禁止片上超高速缓存
	INVD			;清洗片上超高速缓存
	CALL 	Acceas	;调用测试子程序
	STI
	MOV 	ESI,EDX	;保存所耗时间参数
Step2:;在允许片上超高速缓存的情况下调用测试子程序
	CLI
	MOV 	EAX,CR0
	BTR 	EAX,CDBIT
	MOV 	CR0,EAX	;清CD位，允许片上超高速缓存
	INVD			;清洗片上超高速缓存
	CALL 	Access	;调用测试子程序
	STI
	MOV 	EDI,EDX	;保存所耗时间参数
Step3:
;显示两种情况下的所耗时间表示值
	MOV 	DX,OFFSET CacheD
	MOV 	ECX,ESI
	CALL 	DMESS
	MOV 	DX,OFFSET CacheE
	MOV 	ECX,EDI
	CALL 	DMESS
Over:;结束
	MOV 	AH,4CH
	INT 	21H
;过程名称：Access
;功能：测试允许和禁止片上超高速缓存效率
;人口参数：无
;出口参数：EDX含所耗时间参数
;高16位是开始时间表示值，低16位是结束时间表示值
Access 		PROC
	MOV 	CX,COUNT
	MOV 	EBX,16
	CALL 	GetCount	;取时间表示值
	SHL 	EDX,16		;保存到EDX高16位
ACC1: 
	MOV 	EAX,[EBX]
	MOV 	EAX,[EBX*2]
	MOV 	EAX,[EBX+EBX*2]
	LOOP 	ACC1		;再取时间表示值，保存在DX中
	CALL 	GetCount
	RET
Access 		ENDP
;过程名称：GetCount
;功能：读系统定时计数器0,取得时间表示值
;入口参数：无
;出口参数：DX=时间表示值
GetCount 	PROC
	MOV 	AL,0
	OUT 	43H,AL		;选定系统定时器0
	CALL 	DELAY
	IN 		AL,40H		;读计数值低8位
	MOV 	DL,AL
	CALL 	DELAY
	IN		AL,40H		;读计数值高8位
	MOV 	DH,AL
DELAY:
	RET
GetCount ENDP
;过程名称：DMESS
;功能：显示说明信息和所用时间表示值
;入口参数：DX=提示信息开始地址偏移
;ECX=含时间表示值(高16位是开始表示值，低16位是结束表示值)
;出口参数：无
DMESS 		PROC
	MOV 	AH,9
	INT		21H			;显示提示信息
	SHLD 	EDX,ECX,16
	SUB 	DX,CX		;得所耗时间表示值
DMESS1:
	MOV 	AX,DX
	CALL 	DHEX		;以16进制数形式显示
	CALL 	NEWLINE		;回车换行
	RET
DMESS		ENDP
;略去按十六进制数形式显示DX之内容的过程DHEX
;略去形成回车换行的过程NEWLINE
CSEG ENDS
	END BEGIN
```

上述演示程序的演示过程是清楚的。现就测试子程序所耗时间表示值的测定作些说明。PC及其兼容机系统中的定时计数器芯片支持多个独立的计数器，其中0号计数器用于形成系统软时钟。计数器采用减计数方式，每当计数到0时就自动重新按初始化时设置的计数初值开始下一轮计数。计数器0的计数初值是65536。读取计数器0的方法是把计数器号送到定时计数器控制端口43H，然后分两次从40H端口读取计数器计数值。测试子程序在开始循环前读取计数值，在结束循环后再读取计数值。这两个计数值可认为是开始和结束的时间表示，它们的差能够反映测试子程序所耗的时间，但不等于所耗时间，所以我们称之为时间表示值。通常定时计数器的输入频率固定为1193180，根据该计数频率可计算出测试子程序所耗的时间。顺便说一下，时钟中断产生的间隔时间大约55ms就是根据该输入频率计算出的。
请注意，由于Pentium片上超高速缓存通常情况下不采用直写方式，而采用回写方式，所以上述演示程序在以Pentium为处理器的系统上运行可能要出问题。如要在Pentium上运行，那么把程序中的清洗片上超高速缓存的指令INVD，改成指令WBINVD.

### 3. 演示控制位NW作用的子程序

上述演示程序清楚地说明了`CR0`中控制位`CD`的作用，下面的程序片段能说明控制位`NW`的作用，也反映禁止直写可能导致超高速缓存与主存储器相应存储单元不一致的情况。所以，==在禁止超高速缓存和禁止直写和使无效时，应清空超高速缓存==。

```assembly
......
;只能在80486实方式下调试
	ENTER 	2,0					;在堆栈中安排一个临时字变量
	CLI
	INVD						;清洗超高速缓存
LINE1: 
	MOV	 	BL,[BP-2]			;读访问该临时字变量(未命中而被填充)
	MOV 	BYTE PTR [BP-2],1	;命中，也写入主存储器
	MOV 	EAX,CR0
	BTS 	EAX,30
LINE2:
	BTSE	AX,29
	MOV 	CR0,EAX				;使CD=1和NW=1
	MOV 	BYTE PTR [BP-2],5	;命中，但不写入主存储器
	MOV 	CL,[BP-2]			;命中，CL=5
LINE3: 
	INVD						;清洗超高速缓存
	MOV 	BL,[BP-2]			;没有命中，BL=1
	BTR	 	EAX,30
	BTR 	EAX,29
	MOV 	CR0,EAX				;使CD=0和NW=0
	STI
	LEAVE
```

请考虑分别删除上述程序片段中LINE1、LINE2或LINE3后的执行情况。

### 4. 页面可超高速缓存性

在处理器外部，通过对80486的输入引脚KEN#的控制，可以使访问的存储单元不被超高速缓存。软件可以设置控制位CD禁止超高速缓存填充。
在启用分页机制时，软件可以设置页表项中的`PCD`位阻止页面被超高速缓存。设置页目录表中的`PCD`位和`CR3`中的`PCD`位阻止页表和页目录表被超高速缓存。因为存在转换后援缓冲器`TLB`,所以通常页表和页目录表不需要超高速缓存。

80486的输出引脚`PCD`和`PWT`能够用于控制外部高速缓存。引脚`PCD`和`PWT`受页表项、页目录项或者`CR3`中`PCD`位和PWT位的驱动。但`CD`能够屏蔽`PCD`。总之，==`PCD`位能够用于控制页面可超高速缓存性；`PWT`位控制外部高速缓存的直写策略，但不影响片上超高速缓存的直写策略==。

# 11.2 80486对调试的支持

8086/8088提供断点指令`INT3`和单步标志`TF`，调试工具利用它们可以设置断点和实现单步。从80386开始，在片上集成了调试寄存器。利用这些调试寄存器不仅可以设置代码执行断点，而且还可以设置数据访问断点；不仅可以把断点设置在RAM中，也可以把断点设置在ROM中。所以说，这些调试寄存器能提供调试便利和简化调试过程。
80486的调试功能包括了80386的调试功能并稍有扩充。关于断点指令和单步与8086/8088基本相一致。本节主要介绍80486通过调试寄存器提供的支持调试能力。

## 11.2.1 调试寄存器

80386和80486都支持6个调试寄存器，如图11.5所示。它们分别是==断点地址寄存器`DR0`、`DR1`、`DR2`和`DR3`==，==调试状态寄存器`DR6`和调试控制寄存器`DR7`==。==这些断点寄存器都是32位寄存器==。利用在10.8.2节介绍的调试寄存器数据传送指令，可以存取这些调试寄存器。但必须注意，==调试寄存器数据传送指令只能在实方式和保护方式的特权级0下执行，所以只有在实方式或特权级0执行的程序才能设置断点和进行断点处理==。

![image](https://github.com/YangLuchao/img_host/raw/master/20231128/image.5577lz8ar240.jpg)

### 1. 断点地址寄存器

==断点地址寄存器用于保存断点处的线性地址，也即指示断点位置==。这些寄存器长32位，与32位线性地址长度相符。处理器硬件把执行指令所涉及的线性地址和断点地址寄存器内的线性地址进行比较，判别执行指令是否触及断点。==处理器具有4个断点地址寄存器`DR0`、`DR1`、`DR2`和`DR3`，所以可以同时支持4个这样的`硬`断点==。
因为由片上寄存器指示断点位置，而非断点中断指令指示断点位置，所以这些`硬`断点可以设置在`ROM`中或者几个任务共享的代码中。
==不论是否启用分页机制，断点地址寄存器内保存的总是线性地址==。我们知道，如果不启用分页机制，那么线性地址就等于物理地址；如果启用分页机制，那么线性地址经过分页部件转换成物理地址。根据线性地址设置断点保证使断点与分页无关。这种断点位置由线性地址表示的做法便于断点的表示，也符合实际调试的需要。

### 2. 调试控制寄存器

==调试寄存器`DR7`也称为调试控制寄存器==，其各字段的意义如图11.5所示。它不仅控制是否允许断点，还控制各断点是代码执行断点还是数据访问断点。`DR7`所含各字段作用如下：

#### (1) 断点类型说明字段RWE

==`DR7`有4个`RWE`字段，依次分别对应4个断点。`RWEi`字段说明`DRi`寄存器所指示断点的类型==。每一个`RWE`占两位，所表示的类型列于表11.2。==`00`表示指令执行断点，当执行对应断点地址寄存器所含地址处的指令时，满足断点条件==。注意，指令执行断点地址必须等于指令开始的字节地址(包括前级)。==`01`和`11`表示数据访问断点，当按所示读写方式访问对应断点地址寄存器所含地址处的存储单元时，满足断点条件==。

![image](https://github.com/YangLuchao/img_host/raw/master/20231128/image.1sstqez9zhj4.jpg)

#### (2) 断点长度说明字段

==`DR7`有4个`LEN`字段，依次分别对应4个断点。`LENi`字段说明`DRi`寄存器所指示断点的长度(范围)==。每一个`LEN`占两位，所表示的长度列于表11.3。指令执行断点的断点长度必须为1字节。数据访问断点的断点长度可以是1字节、2字节或4字节。

![image](https://github.com/YangLuchao/img_host/raw/master/20231128/image.4d5d4hnzjkw0.jpg)

对于数据访问断点而言，如表11.3所示，实际上，==断点长度说明字段`LEN`和对应断点寄存器规定了断点的区域范围==。例如，==设`DR1`内的断点线性地址是`XXXXXXX5H`，`LEN1=00`时，断点的区域范围只有1字节，地址就是`XXXXXXX5H`==；==当`LEN1=01`时，断点的区域范围是地址`XXXXXXX4H`到`XXXXXXX5H`的2字节==；==当`LEN1=11`时，断点的区域范围是地址`XXXXXXX4H`到`XXXXXXX7H`的4字节==。==当按`RWE`所示数据访问断点方式访问存储单元触及断点范围内的字节时，就满足断点条件==。

#### (3) 全局和局部断点允许位

`DR7`有4个`Gi`和`Li`，分别对应4个断点。`Gi`和`Li`控制`DRi`所指示的断点i在断条件满足时，是否引起断点异常。当`Gi`或`Li`为1时，如果`DRi`所指示数据访问断点条件满足，那么导致进入向量号为1的调试陷阱，如果`DRi`所指示指令执行断点条件满足，那么导致引发向量号为1的调试故障。
==`Gi`和`Li`分别称为全局断点允许位和局部断点允许位==。==在任务切换时，处理器清各位，所以`Li`位只支持一个任务范围内的断点。任务切换并不影响`Gi`位，所以`Gi`支持系统内各任务的断点==

#### (4) 精确数据访问断点相符位

==`DR7`还有`GE`位和`LE`位，用于指示是否要求数据访问断点精确相符==。80486无`GE`或`LE`是否置位，总是断点精确相符的。在80386中，可能出现数据访问断点不精确相符，通过设置`GE`位或`LE`位可指示80386数据访问断点精确相符。在任务切换时，`LE`位被自动清除，所以`LE`位是局部于任务的；任务切换时`GE`位不受影响，所以`GE`位是全局

#### (5) 全局调试寄存器访问检测位

`DR7`的位13是调试寄存器访问检测位`GD`。尽管只能在实方式或保护方式的特权0时才能访问调试寄存器，但`GD`位还提供对调试寄存器的特别保护。在`GD=1`的情况下，即使在实方式或保护方式的特权级0时，访问任何调试寄存器都会引起向量号为1的调试故障。这种附加的保护特性保证调试程序在需要的时候可以完全控制调试寄存器资源。在进入向量号为1的异常处理程序时，自动地清除`GD`位，以便异常1处理程序能自由地访问调试寄存器

### 3. 调试状态寄存器

==调试寄存器`DR6`也称为调试状态寄存器==，其各位的定义如图11.5所示。==它指示断点原因，也即指示进入异常1处理程序的原因==。==异常1处理程序可根据`DR6`的有关位，确定是数据访问断点、指令执行断点、单步或其他原因==。
DR6内的各指示位为1时所表示的意义如下：

1. ==`Bi=1(i=0，1，2，3)`表示由`DRi`所指示的断点引起指令执行调试故障或进入数据访问调试陷阱==。每当处理器在某个允许的断点i处发现断点条件满足，就设置`DR6`中的Bi，然后转入异常1处理程序。要特别注意，在某个允许的断点i处断点条件满足而设置Bi时，同时设置所有在那瞬间断点条件满足的各对应Bj位，而不论是否允许。因此，异常1处理程序可能看到多个Bi被置位，但可以通过判断断点允许位Gi和Li位的方法来确定真实的原因。
2. ==`BD=1`表示在`GD`置位的情况下访问调试寄存器，从而引起调试故障==。在进入异常1处理程序时，自动清除GD位。
3. ==`BS=1`表示由于单步原因进入调试陷阱==。当标志寄存器`EFLAGS`中的单步标志`TF`置位时，一般每执行完一条指令后就进入异常1处理程序，这就是单步。由于在进入异常处理程序时，自动清TF标志。实方式下的情形请参见图5.6，保护方式下的情形请参见图10.20，所以，异常1处理程序的执行不会再单步。在异常处理程序结束时，中断返回指令`IRET`从堆栈中弹出原标志寄存器内容到标志寄存器，如果`TF`为1的话，那么又会产生单步。实际上，在执行置位TF指令的下一条指令(通常是`IRET`)之后才产生单步。还请参见5.3.5节。
4. ==`BT=1`表示刚切换到任务状态段`TSS`中的调试陷耕标志T置位的任务==。任务状态段`TSS`内安排了一个调试陷阱标志T，从图10.14可见，该标志T是任务状态段`TSS`内偏移64H处的字的最低位。在任务切换时，如果进入任务的T位为1，那么通常在任务切换完成之后，新任务的第一条指令执行之前进入调试陷阱，也即进入异常1处理程序。这也称为任务切换自陷。

请注意，硬件根据上述各种情况设置调试状态寄存器`DR6`中的相应标志，但硬件并不自动清除它们。所以，异常1处理程序一般应该在返回前清除`DR6`，以免发生混淆。

### 4. 调试故障和调试陷阱的区别

==调试异常分为调试故障和调试陷阱两类==。

==数据访问断点、单步和任务切换自陷属于调试陷阱==。==调试陷阱是在执行引起异常的指令之后发生，进入调试陷阱时，保存在堆栈中的返回地址指向引起陷阱的指令的下一条要执行指令==。

==调试故障是在引起异常的指令之前发生，进入调试故障时，堆栈中的返回地址指向引起故障的指令==。==标志寄存器`EFLAGS`中的重启动标志`RF`能控制是否产生调试故障==。在把`RF`置成1后，下一条指令的任何调试故障被忽略。通常每当成功地执行完一条指令，那么`RF`被清0。但`IRETD`指令例外，它能根据堆栈中标志寄存器映象的RF位值设置RF。异常1处理程序能利用这一特性，在返回断点处时不再重复产生断点故障。

## 11.2.2 演示调试故障/陷阱的实例

下面给出一个可在实方式下运行的演示调试故障和调试陷阱的实例。

实例程序由两部分组成：异常1处理程序和演示程序，分别安排在两个段中。

异常1处理程序的处理步骤如下：

1. 在屏幕的左上角区域以二进制数的形式显示调试状态寄存器`DR6`、指令指针`EIP`的低16位部分IP和32位寄存器`EAX`的内容。
2. 调用BIOS键盘管理程序，等待按键。该步是让用户能够看清上述显示内容。
3. 根据`DR6`和`DR7`判断进入异常1处理程序的原因。分调试陷阱和调试故障两种情形结束异常1处理程序。对于调试陷阱，直接用中断返回指令`IRET`返回。对于调试故障，通过能够设置标志寄存器中RF标志的`IRETD`指令返回，为此还必须在堆栈中形成由二个双字的返回地址和32位`EFLAGS`映象的断点现场。

演示程序的执行步骤如下：

1. 把异常1处理程序的入口填入中断向量表。由于实例在实方式下运行，所以仍使用中断向量表。
2. 模拟单步陷阱和访问调试寄存器故障。
3. 把演示的断点线性地址装入`DR0`、`DR2`和`DR3`，并设置`DR7`。
4. 模拟指令执行断点和数据访问断点。

源程序清单如下：

```assembly
;程序名：T11-2.ASM
;功能：演示调试故障/陷阱的发生及处理
;说明：用TASM汇编，用“TLINK/3”命令连接。
	COLOR 	= 	17H			;显示字符属性值(兰底白字)
	.486P
;调试故障/陷阱处理程序代码段
CSEGD 	SEGMENT 	PARA 	USE16
	ASSUME CS:CSEGD
Debug: 
	PUSHAD					;保存现场
	PUSH 	ES
	CLD
	MOV 	DI,0B800H
	MOV 	ES,DI			;置显示缓冲区段值
;在屏幕第一行显示DR6之内容
	XOR 	DI,DI
	MOV 	EAX, (COLOR SHL 8 +'R') SHL 16 + (COLOR SHL 8 +'D')
	STOSD
	MOV 	EAX, (COLOR SHL 8 +'=') SHL 16 + (COLOR SHL 8 +'6')
	STOSD
	MOV 	EDX,DR6
	BSWAP 	EDX
	XCHG 	DH,DI			;显示DR6之高16位
	CALL 	ECHOB
	BSWAP 	EDX
	CALL 	ECHOB			;显示DR6之低16位
;在屏幕第二行显示IP之内容
	MOV 	DI,160
	MOV 	AX,COLOR SHL 8 +','
	STOSW
	MOV 	EAX, (COLOR SHL 8 +'P') SHL 16 + (COLOR SHL 8 +'I')
	STOSD
	MOV 	AX,COLOR SHL 8 +'='
	STOSW
	MOV 	DX,[ESP+4*8+2]
	CALL 	ECHOB			;在屏幕第三行显示EAX之内容
	MOV 	DI,320
	MOV 	EAX, (COLOR SHL 8 +'A') SHL 16 + (COLOR SHL 8 + 'E')
	STOSD
	MOV 	EAX, (COLOR SHL 8 +'=') SHL 16 + (COLOR SHL 8 + 'X')
	STOSD
	MOV 	EDX,[ESP+4*8+2-4]
	ROL 	EDX,16
	CALL 	ECHOB
	ROL 	EDX.16
	CALL 	ECHOB			;为了演示而设的等待按键
	mov 	ah,0
	int 	16h				;取调试状态寄存器DR6和清DR6
	MOV 	EDX,DR6
	XOR 	EAX,EAX
	MOV 	DR6,EAX			;取调试控制寄存器DR7及分析调试故障/陷阱原因
	MOV 	EAX,DR7
	XOR 	EBX,EBX
	MOV 	CX,4			;4个断点可能
Debug1:
	MOV		BP,CX
	DEC 	BP
	BT 		DX,BP			;DR6中的Bi置17
	JNC 	Debug2			;否，转
	ADD 	BP,BP
	INC 	BP
	BTS 	BX,BP
	DEC 	BP
	BTS 	BX,BP
	TEST 	AX,BX			;判Gi/Li
	JZ 		Debug2
	SHL 	EBX.16
	TEST 	EAX,EBX			;判是数据访问断点还是指令执行断点
	JNZ 	Debug3
	JMP 	SHORT Debug5
Debug2:
	LOOP 	Debug1
	BT 		DX,14			;判BS=1?
	JNC	 	Debug4
	BTR 	WORD PTR [ESP+4*8+2+4],8
Debug3:;调试陷阱处理
	POP 	ES				;恢复现场
	POPAD
	IRET					;返回
Debug4:
	BT 		DX,13			;判BD=17
	JNC 	Debug3
Debug5:;调试故障处理
	POP 	ES
	POP 	AD				;恢复现场
	SUB 	ESP,6
	PUSH 	EAX				;在堆栈中形成返回地址
	MOV 	AX,[ESP+10]
	MOVZX 	EAX,AX
	MOV 	[ESP+4],EAX
	MOV 	AX,[ESP+12]
	MOV 	[ESP+8],EAX
	PUSHFD
	POP 	EAX
	MOV 	AX,[ESP+14]
	MOV 	[ESP+12],EAX
	BTS 	DWORD PTR [ESP+12],16
	POP	 	EAX
	IRETD					;返回
;以二进制数形式显示DX之内容
ECHOB: 
	MOV 	AH, COLOR
	MOV 	CX,16
ECHOB1:
	RCL		DX,1
	SETC 	AL
	ADD 	AL,'0'
	STOSW
	LOOP 	ECHOB1
	RET
CSEGD 		ENDS
;演示程序代码段
CSEGM 	SEGMENT 	PARA 	USE16
	ASSUME 	CS:CSEGM
	VARA	DW	0
	VARB 	DW 	4		;假设的数据变量
	VARC	DW	0
	VARD	DB	0
	BREAKD 	LABEL 	BYTE
	VARE	DD	0
Begin:;把异常1处理程序入口填入中断向量表(实方式)
	XOR 	AX,AX
	MOV 	FS,AX
	MOV 	AX,CSEGD
	SHL 	EAX,16
	MOV 	AX,OFFSET Debug
	XCHG 	FS:[1*4],EAX
	MOV 	ESI,EAX
Step1:;模拟单步陷阱
	PUSHF
	BTS 	WORD PTR [ESP],8
	POPF
	MOV 	EAX,1
Step2:;模拟访问调试寄存器故障
	MOV 	EAX,DR7
	BTS 	EAX,13
	MOV 	DR7,EAX
	MOV 	EAX,2
	MOV 	EAX,DR3
Step3: ;设置DR0为指令执行断点
	MOV 	AX,CS
	MOVZX 	EAX,AX
	SHL 	EAX,4
	MOV 	EBX,OFFSET BRK0
	XADD 	EAX,EBX
	MOV 	DR0,EAX
	XOR 	EDX,EDX
	BTS 	EDX,0				;L0=1,RWE0=00,LEN0=00
;设置DR2为数据访问断点
	MOV 	EAX,OFFSET BREAKD
	ADD 	EAX,EBX
	MOV 	DR2,EAX
	BTS 	EDX,4				;L2=1
	BTS 	EDX,24
	BTS 	EDX,25				;RWE2=11
	BTS 	EDX,26
	BTS 	EDX,27				;LEN2=11
;设置DR3为数据访问断点
	MOV 	DR3,EAX
	BTS 	EDX,7				;G3=1
	BTS 	EDX,28				;RWE3=01
	BTS 	EDX,30				;ILEN3=01
	MOV 	DR7,EDX
Step4:;模拟指令执行断点
	MOV 	EAX,3
BRKO: 
	MOV 	EAX,0
Step5:;模拟数据访问断点(读访问)
	MOV 	EAX,DWORD PTR CS:VARB
Step6:;模拟数据访问断点(写访问)
	PUSH 	CS
	POPDS
	MOV 	EAX,5
	MOV 	WORD PTR VARD,AX
Step7:;清DR7
	XOR 	EAX,EAX
	MOV 	DR7,EAX
Over:;恢复1号中断向量
	MOV 	FS:[1*4],ESI		;结束
	MOV 	AH,4CH
	INT 	21H
CSEGM 	ENDS
	END Begin
```

# 11.3 Pentium 程序设计基础

Pentium是继80486之后的新一代微处理器，它保持与先前各代微处理器百分之百二进制兼容。它不仅采用更先进的技术实现先前微处理器的功能，而且增加了许多新功能，因此它的性能要大大优于80486。Pentium实现超标量体系结构，支持分别称为U和V的两条流水线，理想情况下，在一个时钟周期内可以执行两条指令。Pentium通过在片内的分支目标缓冲器(BTB)，实现动态分支预测，有效地提高分支处理执行速度。
Pentium增加了片上超高速缓存的容量，8K字节用于数据，8K字节用于代码。此外，Pentium还实现了流水线浮点部件，加强了错误检测和报告功能，完善和扩充了虚拟8086模式，提供多处理器支持。
我们在先前各章节介绍的内容几乎都适用于Pentium。本节从程序设计的角度简单介绍Pentium新增、扩充或改进的内容。

## 11.3.1 寄存器

Pentium维持80486绝大部分寄存器的作用和使用方法。但新增了若干Pentium模型专用寄存器，这些模型专用寄存器主要用于系统测试和运行性能检测。把它们称为模型专用寄存器的原因是它们与处理器关系密切，可能在以后的处理器中不会以相同的方法继续使用。80486所含的测试寄存器的功能，在Pentium上由模型专用寄存器实现。

### 1.基本结构寄存器及其标志寄存器

Pentium的8个32位的通用寄存器与80386相同，6个段寄存器也与80386相同，指令指针也与80386相同。请参见图9.1。Pentium的标志寄存器`EFLAGS`仍是32位，如图11.6所示。

与图11.1所示的80486标志寄存器相比，Pentium的标志寄存器新增了三个标志：

1. 虚拟中断标志VIF
2. 虚拟中断挂起标志VIP
3. 标识标志ID

其他标志位的位置及意义保持与80486相同。

![image](https://github.com/YangLuchao/img_host/raw/master/20231128/image.31ufgsikvpk0.jpg)

==虚拟中断标志`VIF`占用标志寄存器的位19==。==当允许虚拟8086方式扩充或者允许保护方式虚拟中断时，VIF是中断标志的虚拟映象==。==当禁止虚拟8086方式扩充和禁止保护方式虚拟中断时，`VIF`被强制为0==。
==虚拟中断挂起标志`VIP`占用标志寄存器的位20==。==当允许虚拟8086方式扩充或者允许保护方式虚拟中断时，VIP指示虚拟中断是否挂起==。==当禁止虚拟8086方式扩充和禁止保护方式虚拟中断时，`VIP`被强制为0==。
==标识标志ID占用标志寄存器的位21==。==如果可以设置或清除该标志，那么表示处理器支持CPUID指令==。==利用该指令可获得处理器类型等信息==。请参见T11-3.ASM。

### 2. 系统级寄存器及控制寄存器

==Pentium的系统地址寄存器(全局描述符表寄存器`GDTR`、局部描述符表寄存器`LDTR`、中断描述符表寄存器`IDTR`和任务状态段寄存器`TR`)与80386的系统地址寄存器相同==。请参见图10.9
==Pentium支持4个控制寄存器`CR0`、`CR2`、`CR3`和`CR4`==。与80486相比，多了CR4。控制寄存器CR0各位的安排与80486相同，如图11.2所示，但其中的`CD`位和`NW`位重新定义了片上超高速数据缓存的工作方式。请参见11.3.4节关于片上超高速缓存的说明。
==控制寄存器`CR2`用于指示引起页面故障的线性地址==，这与80486相同。
==控制寄存器`CR3`高20位含有页目录表所在物理页的页码，低12位中定义了控制位`PCD`和`PWT`==。这与80486相同，如图11.3所示。
==`CR4`是Pentium新增的控制寄存器==，其各位的定义如图11.7所示。

![image](https://github.com/YangLuchao/img_host/raw/master/20231128/image.2md7zherex20.jpg)

1. ==位2是读时间标记计数器指令`RDTSC`使用控制位`TSD`==。==当`TSD`为0时，可在任一特权级上执行读时间标记计数器指令`RDTSC`==。==当`TSD`为1时，只有在当前特权级为0时，可执行指令`RDTSC`，否则将导致出错码为0的通用保护异常==。==`RESET`后，`TSD`为0，任一特权级执行的程序都可使用指令`RDTSC`，读取时间标记计数器==。
2. ==位3是调试扩充控制位`DE`==。==当`DE`为0时，禁止调试扩充，也即不支持``I/O``断点==。==当`DE`为1时，允许调试扩充，也即支持`I/O`断点==。`RESET`后，DE为0，禁止调试扩充，这样Pentium就保持80486原有调试功能。请参见下面关于调试寄存器的说明。
   ==位0是虚拟8086方式扩充控制位`VME`==。==当`VME`为0时，禁止虚拟8086方式扩充==。
3. ==位1是保护方式虚拟中断控制位`PVI`==。==当`PVI`为0时，禁止保护方式虚拟中断==
4. ==位4是页面大小扩充控制位`PSE`==。==当`PSE`为0时，禁止页面大小扩充==。
5. ==位6是机器检查异常控制位`MCE`==。==当`MCE`为0时，禁止机器检查异常==。

在`RESET`后，这些控制位都是0，从而保持与80486相一致。

### 3. 调试寄存器

Pentium不仅支持如图11.5所示的调试寄存器，而且调试功能还有所扩充。==Pentium所支持的调试功能扩充是指支持`I/O`断点==。==80486调试控制寄存器`DR7`中的各断点类型说明字段`RWEi`尽管是2位，但该字段取值`10`的情况被保留==。==在允许调试扩充时，Pentium调试控制寄存器`DR7`中的各断点类型说明字段`RWEi`，可以取值`10`，所表示的断点条件是``I/O``端口读或者写==。在允许调试扩充时，表11.2所列出的断点类型扩充为表11.4所列的断点类型。==对应的断点地址寄存器内存放的是扩展成32位的``I/O``端口地址==。

![image](https://github.com/YangLuchao/img_host/raw/master/20231128/image.1ydar1uv4ubk.jpg)

==控制寄存器`CR4`中的`DE`位决定是否允许调试功能扩充。当`DE`为1时，允许调试功能扩充==。

## 11.3.2 指令系统

Pentium指令集应该说是80486指令集的超集。由于在Pentium中测试寄存器归属于Pentjum模型专用寄存器，所以Pentium不再支持测试寄存器数据传送指令。除此之外，Pentium支持其他80486的全部指令，并保持与80486兼容。与80486相比，Pentium还新增了几条指令。但某些新增的指令是否有效与Pentium的型号有关，==可利用处理器特征识别指令`CPUID`判别处理器是否支持某些新增指令==。
Pentium支持控制寄存器`CR4`，所以Pentium的控制寄存器传送指令的操作数还可以是控制寄存器`CR4`。Pentium还提供从系统管理方式返回的指令`RSM`。

### 1. 8字节比较交换指令CMPXCHG8B

==8字节比较交换指令==的格式如下：

```assembly
CMPXCHG8B OPRD
```

==其中操作数OPRD是64位存储器操作数==。==该指令的功能是把`EDX:EAX`内的64位值与存储器操作数`OPRD`相比较，如果相等，把`ECX:EBX`内的64位值存入存储器操作数OPRD，如果不等，把存储器操作数OPRD内的64位值装入`EDX:EAX`==。`EDX`和`ECX`分别是64位值的高32位。
例如：

```assembly
CMPXCHG8B [BX]
CMPXCHG8B [EDX]
```

==如果`EDX:EAX`的值与存储器操作数OPRD的值相等，那么置`ZF`，否则清`ZF`。该指令不影响其他标志==。
在加上LOCK前级后，该指令对多处理器情况下的信号量操作有用。

### 2. 处理器特征识别指令CPUID

==处理器特征识别指令==的一般格式如下：

```assembly
CPUID
```

==利用该指令能够方便地获得包括处理器类型在内的若干处理器特征信息==。`CPUID`指令返回由`EAX`指定的某方面的处理器特征信息。表11.5列出了指令CPUID根据EAX返回特征信息的定义。在Pentium第1型中，指令参数可取的最大值是1。在新一代处理器中，可能提供更丰富的特征信息。

![image](https://github.com/YangLuchao/img_host/raw/master/20231128/image.5eru2p9eem00.jpg)

例如，如下指令可取得最大特征参数值和厂商识别标识串：

```assembly
MOV 	EAX,0
CPUID
```

Pentium处理器的厂商识别标识串是“Genuine Intel"。
关于由`EAX`返回的CPU说明信息和由`EDX`返回的特征标志字的格式及说明请参见11.3.3节。
该指令不影响各标志。
从后期的80486开始，就支持该指令。软件可通过判断标志寄存器中的ID位是否可设置和清除来判断处理器是否支持该指令。如果ID可设置和清除，那么可使用`CPUID`指令。

### 3. 读时间标记计数器指令RDTSC

Pentium含有一个64位的时间标记计数器。==该计数器随每一时钟周期递增。在`RESET`后，该计数器被清0==。利用该计数器可检测程序运行性能。
==读时间标记计数器指令==的一般格式如下：

```assembly
RDTSC
```

==该指令把时间标记计数器的高32位复制到`EDX`，把低32位复制到`EAX`==。
==控制寄存器`CR4`的`TSD`位限制该指令的使用==。==当`TSD`为0时，可在任一特权级上执行`RDTSC`指令，当`TSD`为1时，只有当特权级为0时，可执行`RDTSC`指令，否则将导致出错码为0的通用保护异常==。
该指令不影响各标志。

### 4. 读模型专用寄存器指令RDMSR

==读模型专用寄存器指令==的一般格式如下：

```assembly
RDMSR
```

==该指令把由`ECX`寄存器指定的模型专用寄存器的内容送到`EDX:EAX`，`EDX`含高32位，`EAX`含低32位==。==如果所指定的模型寄存器不足64位，那么在`EDX:EAX`中的对应位未定义==。
Pentium提供一组模型专用寄存器，==在利用`RDMSR`读某个模型专用寄存器时，必须先把欲读模型专用寄存器的编号送到`ECX`寄存器==。==如果在`ECX`中指定的编号未定义或被保留，将导致通用保护异常==。
该指令不影响各标志。
该指令只能在实方式或者保护方式的特权级0下执行，否则将导致通用保护异常。在使用该指令前，应该利用`CPUID`指令取得处理器特征标志字，以判别是否可使用该指令，否则可能导致无效操作码异常。
Pentium的上述时间标记计数器是模型专用寄存器之一。利用访问模型专用寄存器的指令也可读取时间标记计数器值。但不提倡应用程序通过RDMSR指令读取时间标记计数器。

### 5. 写模型专用寄存器指令WRMSR

写模型专用寄存器指令的一般格式如下：

```assembly
WRMSR
```

该指令把`EDX:EAX`的内容送到由`ECX`寄存器指定的模型专用寄存器，`EDX`送到高32位，`EAX`送到低32位。如果指定的模型寄存器有未定义的或者被保留的位，那么这些位的内容不变。像利用RDMSR指令读模型专用寄存器那样，如果在`ECX`中指定的编号未定义或被保留，将导致通用保护异常。
该指令不影响各标志。
该指令只能在实方式或者保护方式的特权级0下执行，否则将导致通用保护异常。
在使用该指令前，应该利用`CPUID`指令取得处理器特征标志字，以判别是否可使用该指令，否则可能导致无效操作码异常。
系统程序利用`WRMSR`指令可设置上述时间标记计数器。

### 6. 用宏定义新增指令

低版的汇编器不识别Pentium的新增指令。可利用如下定义的宏来使用这些新增指令。请注意，其中的8字节比较交换指令宏没有考虑可能的地址扩展前缀，所以如果在16位段代码中采用该宏指令时，不能使用32位地址，如果在32位代码中采用该宏指令时，不能使用16位地址。

```assembly
;文件名：PENTIUM.INC
;包含为Pentium新增指令定义的宏
CMPXCHG8B	MACRO 	MQ		;8字节比较交换指令，该宏指令
	LOCAL LAB1,LAB2			;在16位段中使用时，不支持32位地址
	LAB1 	= $
	STR 	MQ
	LAB2 	= $
	ORG		LAB1+1
	DB 		0C7H
	ORG 	LAB2
ENDM
CPUID 	MACRO				;处理器特征识别指令
	DB 		0FH,0A2H
ENDM
RDTSC 	MACRO				;读时间标记计数器指令
	DB 		0FH,31H
ENDM
RDMSR MACRO					;读模型专用寄存器指令
	DB 		0FH,32H
ENDM
WRMSR 	MACRO				;写模型专用寄存器指令
	DB 		0FH,30H
ENDM
RSM 	MACRO				;从系统管理方式返回指令
	DB 	0FH,0AAH
ENDM
```

## 11.3.3 处理器的识别

随着处理器不断升级换代，处理器的功能越来越强，80x86系列新型号处理器具有老型号处理器的功能。通常，在老型号处理器上可运行的程序，在新型号处理器上也可运行。
这称为向前兼容，或者称为向上兼容。另一方面，程序只有利用处理器提供的新特性，才能充分发挥处理器的能力。所以，一个良好的程序应该能够根据不同的处理器采取不同的方法，实现相同的功能。那么如何识别处理器型号(类型)呢？对前几代处理器的识别，可通过判断标志寄存器中某些标志位的设置情况来进行。从后期的80486开始，处理器提供了处理器特征识别指令CPUID，利用该指令可方便地获得处理器特征信息。

### 1.处理器说明信息和特征标志字

如果处理器支持`CPUID`指令，那么利用如下指令可取得CPU说明信息和特征标志字：

```assembly
MOV 	EAX,1
CPUID
```

==执行上述指令后，`EAX`含有CPU说明信息，`EDX`含有特征标志字==。CPU说明信息的格式如图11.8所示。类别字段(ProcessorType)占用2位，说明处理器的种类信息。家族代号(Family)字段占用4位，80486处理器该字段值是4，Pentium处理器该字段值是5，PentiumPro处理器该字段值是6。型号(Model)字段占用4位，反映型号值。系列号(SteppingID)字段占用4位。

![image](https://github.com/YangLuchao/img_host/raw/master/20231128/image.2qja44rali60.jpg)

特征标志字的每一位可用于指示一个特性是否存在。Pentium特征标志字中的基本特征标志如下：

1. ==位0是片上浮点处理单元特征位FPU==。==该位为1表示处理器含有浮点处理单元，可执行387指令集中的浮点处理指令==。
2. ==位1是虚拟8086方式扩充特征位`VME`，该位为1表示处理器支持虚拟8086方式扩充==，这种情况下
   - 控制寄存器`CR4`中的`VME`位可以控制虚拟8086方式扩充是否允许；
   - `PV1`位可以控制保护方式虚拟中断；
   - `TSS`可以支持软件间接位图，标志寄存器中的`VIF`和`VIP`标志位有效。
3. ==位2是调试功能扩充特征位`DE`==。该位为1表示处理器支持调试功能扩充，这种情况下
   - 控制寄存器`CR4`中的`DE`位可以控制调试功能扩充是否允许，也即`I/O`断点是否允许。
4. ==位3是页面大小扩充特征位`PSE`==。该位为1表示处理器支持页面大小扩充，这种情况下
   - 控制寄存器`CR4`中的`PSE`位可以控制页面大小扩充是否允许。
5. ==位4是时间标记计数器特征位`TSC`==。该位为1表示处理器支持读时间标志计数器指令`RDTSC`，控制寄存器`CR4`中的`TSD`位才可以控制允许使用`RDTSC`指令的特权级。
6. ==位5是模型专用寄存器特征位`MSR`==。该位为1表示处理器支持读和写模型专用寄存器指令`RDMSR`和`WRMSR`。
7. 位7是机器检查异常特征位`MCE`。该位为1表示处理器支持控制寄存器`CR4`中的`MCE`位，MCE位可以控制是否允许机器检查异常。
8. 位8是`CMPXCHG8B`指令特征位`CX8`。该位为1表示处理器支持8字节比较交换指令`CMPXCHG8B`.
9. 位9是特征标志位`APIC`。该位为1表示处理器含有高级可编程中断控制器`APIC`，并可以使用`APIC`。
10. 位23是特征标志位`MMX`。该位为1表示处理器支持`MMX`指令集。

### 2. 识别处理器类型的实例

下面给出一个识别处理类型的实例。该实例通过判别标志寄存器中有关标志位区分8086、80286、80386和80486，在确定处理器至少是80486之后，根据判别ID标志来判断是否可执行处理器特征识别指令`CPUID`，Pentium总是支持`CPUID`的。如果可以执行`CPUID`指令，那么利用该指令进一步获取处理器的特征信息。但该实例没有识别浮点处理部件。

```assembly
;程序名：T11-3.ASM
;功能：识别处理器类型(没有显示功能)
;说明：该实例应在实方式下执行
	.386P
	INCLUD	EPENTIUM.INC;包含定义Pentiun新增指令的宏文件
CSEG 	SEGMENT 	USE16
	ASSUME 		CS:CSEG,DS:CSEG
	CPUTYPE 	DB 		?		;处理器类型(0:86,2:286,3:386,4:486,5:Pentium)
	CPUIDF 		DB 		0		;1表示使用CPUID指令
	INTELF		DB		0		;Intel产品标识
	FAMILY		DB		0		;家族代号信息
	CMODEL 		DB 		0		;型号信息
	STEPID 		DB 		0		;系列号信息
	PROPF		DD		0		;特征标志字
;获取处理器类型的过程
GetCPUI 	PROC
Check8086:
;8086标志寄存器的最高4位总为1,根据此特性判断是否是8086
	PUSHF
	POP 	AX
	AND 	AX,0FFFH
	PUSH 	AX
	POPF
	PUSHF
	POP 	AX
	AND 	AX,0F000H
	CMP		AX,0F000H
	MOV 	CPUTYPE,0			;假设是8086
	JNZ 	SHORT Check286
	RET	
Check286:
;实方式下80286标志寄存器中的IOPL总为0,根据此特性判断是否是80286
	PUSHF
	POP 	AX
	OR 		AX,3000H
	PUSH 	AX
	POPF
	PUSHF
	POP 	AX
	TEST 	AX,3000H
	MOV 	CPUTYPE,2			;假设是80286
	JNZ 	SHORT Check386
	RET
Check386:
;80386标志寄存器中的位18不能设置，而80486中该位定义成AC标志
;根据此特性判断是否是80386
;现在可以使用386指令和32位操作数
	MOV 	BP,SP
	AND 	SP,NOT 3			;避免堆栈出现不对齐现象
	PUSHFD
	POP 	EAX
	MOV 	EDX,EAX
	BTS 	EAX,18
	PUSH 	EAX
	POPFD
	PUSHFD
	POP 	EAX
	BT 		EAX,18
	JC 		SHORT A386
	MOV 	CPUTYPE,3			;是80386
	MOV 	SP,BP
	RET
A386:
	PUSH 	EDX					;恢复
	POPFD
	MOV 	SP,BP
Check486:
;对于后期的80486以及Pentium,可利用CPUID指令获取处理器类型信息
;标志寄存器中的位21定义成ID标志
;能否改变ID标志，反映是否可使用CPUID指令
	MOV 	EAX,EDX
	BTS 	EAX,21
	PUSH 	EAX
	POPFD
	PUSHFD
	POP 	EAX
	PUSH 	EDX
	POPFD
	BT 		EAX,21
	MOV 	CPUTYPE,4		;至少是80486
	JNC 	SHORT IDOK
AE486: 
	MOV 	CPUIDF,1		;可使用CPUID指令
	XOR 	EAX,EAX
	CPUID					;取厂商识别标识申
	CMP 	EBX,"uneG"
	JNE 	SHORT IDOK
	CMP 	EDX,'leni'
	JNE 	SHORT IDOK
	CMP 	ECX,'letn'
	JNE 	SHORT IDOK
YINTEL:
	MOV 	INTELF,1		;是Intel产品
	CMP 	EAX,1
	JB 		SHORT IDOK
	MOV 	EAX.1
	CPUID					;进步取得特征信息
	MOV 	PROPF,EDX
	MOV 	BL,AI
	AND 	AX,OFOFH
    MOV 	STEPID,AL		;保存系列号信息
	MOV 	FAMILY,AH		;保存家族代号信息
    SHR 	BL,4
    MOV 	CMODEL,BL		;保存型号信息
	MOV 	CPUTYPE,AH
IDOK: 
	RET
GetCPUID ENDP
Begin:
	PUSH 	CS
	POP 	DS
	CALL 	GetCPUID
	MOV 	AH,4CH
	INT 	21H
CSEG 		ENDS
	END 	Begin
```

为了简单，上述实例没有提供显示输出功能。读者可完善该实例，使其能够显示输出处理器类型信息和有关特征信息。

## 11.3.4 片上超高速缓存

Pentium在片上包含了独立的指令(代码)和数据超高速缓存器，分别为8K字节。指令和数据超高速缓存可以同时被访问。可以利用软件和硬件的方法控制片上超高速缓存的工作方式，也可以利用软件和硬件的方法控制可被超高速缓存的内存区域。==为了适应多处理器环境的需要，对于数据超高速缓存，采用一种称为`MESI`的协议，保持超高速缓存数据一致==；==对于指令超高速缓存，则采用`MESI`协议的子集`SI`来保持一致==。下面简单介绍Pentium片上超高速缓存的组织。尽管可以认为超高速缓存器是透明的，但事实上了解它的组织对编写高效的程序有益。

### 1. 片上超高速缓存及其工作方式的控制

Pentium片上的数据超高速缓存和指令超高速缓存的容量告为8K字节，而且都采用二路组相关联结构。每个超高速缓存有128组，每组2行。每行32字节宽。==每个超高速缓存都使用物理地址来访问，并且每个超高速缓存都有自己的`TLB`将线性地址转换为物理地址==。
数据超高速缓存由在4字节边界处交错的8个体构成。它在同一个时钟内可以支持两次数据访问。在两条流水线中执行的指令可以同时访问数据超高速缓存，但如果访问对同一个体进行，那么会有延时。Pentium的数据超高速缓存是一种回写式超高速缓存，填充和替换以行为单位进行。==每一行有用于支持`MESI`协议的两位相关联，可表示4种状态：M状态(Modified)、E状态(Exclusive)、S状态(Shared)和I状态(Invalid)==。另外，每一行还有用于==记录最近最少使用情况的`LRU`位==相关联指令超高速缓存在一个时钟内可提供多达32字节的原始代码。由于指令超高速缓存无需回写，所以每一行有用于支持SI协议的一位相关联，可表示S和1这2种状态。每一行也有用于记录最近最少使用情况的`LRU`位相关联控制寄存器`CR0`中的`CD`位和`NW`位可控制片上超高速缓存的工作方式，它们定义的工作方式如表11.6所列。由于Pentium的超高速缓存支持回写方式，所以与80486相比，这两个控制位的定义有所不同。

![image](https://github.com/YangLuchao/img_host/raw/master/20231128/image.2nbvpz3duqy0.jpg)

![image](https://github.com/YangLuchao/img_host/raw/master/20231129/image.28gmpjufj63o.jpg)

==`CD=0`和`NW=0`能使片上超高速缓存发挥最高性能==。==把`CD`和`NW`置1能禁止超高速缓存，但为了完全禁止超高速缓存，在把`CD`和`NW`置1后，还应该清洗超高速缓存==。==在`RESET`后，`CD=1`和`NW=1`==。

### 2. 演示片上超高速缓存作用的实例

下面给出一个演示程序，该程序演示片上指令超高速缓存和数据超高速缓存如何提高处理性能。演示程序含有以循环方式访问某些存储单元的两个测试子程序，测试子程序能测定运行所耗时钟数。演示程序在禁止和允许超高速缓存两种情况下，分别调用测试子程序1，然后在允许超高速缓存的情况下再调用子程序2，最后分别显示所用时钟数。该演示程序在Pentium实方式下运行。源程序清单如下：

```assembly
;程序名：T11-4.ASM
;功能：演示Pentium片上高速缓存的作用
;说明：仅在Pentium的实方式下运行
CDBIT		=		30		;CR0种的CD位位置
COUNTV		=		10
	.486P
;识别486指令集
	INCLUDE PENTIUM.INC;包含定义Pentium新增指令的宏文件
DSEG	SEGMENT 	PARA 	USE16
	Mess1		DB		'Clock1:$'
	Mess2		DB		'Clock2:$'
	Mess3		DB		'Clock3:$"
	COUNT1		DD		?
	COUNT2		DD		?
	COUNT3		DD		?
DSEG 	ENDS
CSEG 	SEGMENT 	PARA 	USE16
	ASSUME CS:CSEG,DS:DSEG
BEGIN:
	MOV 	AX,DSEG
	MOV 	DS,AX
Stepl:
	CLI
	MOV 	EAX,CR0
	BTS 	EAX,CDBIT
	MOV 	CR0.EAX					;禁止超高速缓存
	WBINVD							;清洗超高速缓存
	CALL 	Access1					;调用测试子程序1
	STI
	MOV 	COUNT1,EAX				;保存时钟数
Step2:
	CLI
	MOV 	EAX,CR0
	BTR 	EAX,CDBIT
	MOV 	CR0,EAX					;允许超高速缓存
	WBINVD							;清洗超高速缓存
	CALL 	Access1					;调用测试子程序1
	STI
	MOV 	COUNT2,EAX				;保存时钟数
Step3:
	CLI
	WBINVD							;清洗超高速缓存
	CALL 	Access2					;调用测试子程序2
	STI
	MOV 	COUNT3,EAX				;保存时钟数
Step4:
	MOV 	DX,OFFSET Mess1
	MOV 	ECX,COUNT1
	CALL 	DMESS					;显示提示信息和所用时钟数1
	MOV 	DX,OFFSET Mess2
	MOV 	ECX,COUNT2
	CALL 	DMESS					;显示提示信息和所用时钟数2
	MOV 	DX,OFFSET Mess3
	MOV 	ECX,COUNT3
	CALL	DMESS					;显示提示信息和所用时钟数3
	MOV 	AX,4C00H
	INT 	21H
;测试子程序1
;EAX返回运行所用时钟数
Access1 	PROC
	MOV 	CX,COUNTV
	MOV 	EBX,1024
	RDTSC							;开始时读时间标记计数器
	MOV 	ESI,EDX					;保存
	MOV 	EDI,EAX
ACC1: 
	MOV 	EAX,[EBX]
	MOV 	EAX,[EBX+1024*4]
	MOV	 	EAX,[EBX+1024*2]
	MOV 	EAX,[EBX+1024*6]
	LOOP 	ACC1
	RDTSC							;结束时再读时间标记计数器
	SUB 	EAX,EDI
	SBB 	EDX,ESI					;得所用时钟数
	RET
Accessl 	ENDP
;测试子程序2
;EAX返回运行所用时钟数
;与测试子程序1的不同之处是访问的存储单元
Access2 	PROC
	MOV 	CX,COUNTV
	MOV 	EBX,1024
	RDTSO
	MOV 	ESI,EDX
	MOV 	EDI,EAX
ACC2:
	MOV 	EAX,[EBX]				;这种安排使数据超高速缓存
	MOV 	EAX,[EBX+1024*4]		;不断被置换填充，也即仍然每次
	MOV 	EAX,[EBX+1024*8]		;访问都不命中
	MOV 	EAX,[EBX+1024*12]
	LOOP 	ACC2
	RDTSC
	SUB 	EAX,EDI
	SBB 	EDX,ESI
	RET
Access2 ENDP
	;略去过程DMESS
CSEG 	ENDS
	END BEGIN
```

上述演示程序利用了读时间标记计数器指令`RDTSC`，在循环开始时读取时间标记值，在循环结束时再读取时间标记值，它们的差可认为是循环所花的时钟数

# 11.4 基于Pentium的程序优化技术

Pentium处理器具有双整型流水线、指令和数据独立的超高速缓存、动态分支预测机制和流水线浮点处理部件等多种新特性。Pentium的这些新特性能够大大提高处理性能。尽管这些新特性的实现对程序员而言是透明的，但如果程序员能够在理解这些新特性后注意发挥它们的作用，那么程序运行效率就可更高。本节简单介绍有助于提高程序执行速度的优化技术，这些优化技术以Pentium处理器为基础，这些技术的实质就是如何较好地利用Pentium的上述新特性。注意，在PentiumPro和PentiumII及支持MMX的Pentium上可能略有差异。
本节介绍的例子都假设是在某个32位代码段中的片段。

## 11.4.1 流水线优化技术

Pentium是一个高级的超标量处理器，它拥有两条并行的整型流水线。流水线是指，每条指令的执行过程分成若干阶段，每个阶段都有独立的部件来处理，当一条指令的某个处理阶段完成后，它就进入到下一处理阶段，而独立的处理部件就可立即处理下一条指令。采用流水线方式执行指令，能提高指令执行的并行程度，有效地提高机器处理性能。
Pentium的两条流水线能够同时执行指令，所以Pentium最多能在一个时钟内执行两条整型指令。

### 1. U流水线和V流水线

Pentium的两条流水线分别称为U流水线和V流水线。U流水线是主流水线，它能够执行指令集中的所有指令。V流水线在可执行的指令方面有限制，它只能执行大多数常用指令。
例如，如下程序片段在理想情况下执行时只要花2个时钟：

```assembly
MOV		EAX,EBX				;在U流水线执行
MOV		EDX,ECX				;在V流水线执行
MOV		EBX,12345678H		;在U流水线执行
MOV		CX,[ESI]			;在V流水线执行
```

==Pentium的整型流水线含有五步：预取(PreFetch)、译码1(Decodestage1)、译码2(Decodestage2)、执行(Execute)、回写(WriteBack)==。整型指令的执行要经过流水线中这五步。与80486的流水线相比，Pentium的流水线经过了优化，可达到更高的性能。另一方面，如果要执行的两条指令符合`指令配对规则`能够配对，那么一条指令经由U流水线执行，另一条指令经由V流水线执行。Pentium处理器以流水线方式执行指令的过程如图11.9所示，其中in表示指令n。尽管指令在两条流水线中并行执行，但执行指令的功能与指令顺序执行时是完全一致的。流水线的第一步是预取(PF)，在该阶段，从指令超高速缓存或存储器预取指令。两条流水线的预取阶段是合在一起的，由指令预取器完成。指令预取器具有两对32字节长的预取缓冲区，一对用于顺序预取，一对用于预测分支执行预取(从分支预测机制预测执行的分支处预取)。由于Pentium具有独立的指令超高速缓存，所以从超高速缓存预取指令不会与数据访问相冲突。

![image](https://github.com/YangLuchao/img_host/raw/master/20231129/image.7djvxg339d00.jpg)

==流水线的第二步是第一阶段译码(D1)==。在该阶段之初，译码器根据指令配对规则判别随后的两条指令是否配对。如果配对，那么把两条指令依次发往U流水线和V流水线；如果不配对，那么仅一条指令交U流水线。
==流水线的第三步是第二阶段译码(D2)==。在该阶段，计算存储器操作数的有效地址。通常该阶段仅需一个时钟。
==流水线的第四步是执行(EX)==。在该阶段，进行算术逻辑运算和数据存取访问。因此，
那些既要算术逻辑运算，又要数据存取访问的指令在该步中需要化去多个时钟。例如，指令`ADD[EBX]，EAX`就是这样的指令，在该阶段要化3个时钟。
==流水线的第五步是回写(WB)==。在该阶段，改变处理器状态，最终完成指令的执行。
在依次经过流水线各步的过程中，由于某些情况，指令执行可能被拖延。U流水线和V流水线中的指令一起配对进入和离开D2和EX阶段。如果在某条流水线中的指令在某阶段被耽搁，那么在另一条流水线中的配对指令也在同一阶段被耽搁，所以U流水线和V流水线中的配对指令同时进入EX阶段。在EX阶段，如果U流水线中的指令被拖延，那么V流水线中可能有的配对指令也被耽搁；如果V流水线中的指令被拖延，那么U流水线中的配对指令也被耽搁。只有当处于两条流水线EX阶段的配对指令都到达WB阶段，那么两条流水线上的随后指令才能够进入EX阶段。在两条流水线并行执行过程中，对存储器的访间仍保持顺序执行时的次序，所以只有在U流水线中的指令完成需要的存储器访问后，V流水线中可能有的配对指令才能够进行存储器访问，这也可能会导致某些执行被拖延。

### 2. 整型指令配对规则

==指令集中的指令根据如何进行流水线配对==可分为如下四类：

#### (1) UV类指令

==这类指令既可发到U流水线又可发到V流水线==。==大多数算术逻辑运算指令、全部比较指令和全部以通用寄存器为操作对象的堆栈操作指令属于UV类指令==。

#### (2) PU类指令

==这类指令在配对时只能发到U流水线==。==有前缀的指令属于PU类指令==；==带进位或借位操作指令、移位位数由立即数决定的移位指令属于PU类指令==。

#### (3) PV类指令

==这类指令在配对时只能发到V流水线==。==简单控制转移指令(如近调用`CALL`，近转移`JMP`，条件转移指令)属于`PV`类指令==。

#### (4) NP类指令

==这类指令不能配对，只能单独在U流水线中执行==。==移位位数由`CL`确定的移位指令、乘除指令(如`MUL`，`DIV`)、扩充的指令(如`PUSHA`，`ENTER`，`MOVS`，`LOOPNZ`，`MOVSX`)、涉及段寄存器的指令(如远调用指令`CALL`，`PUSHDS`)属于`NP`类指令==。
表11.7列出了主要可配对的整型指令，其中U流水线列的指令是在配对时可进入U流水线的指令(即UV类指令和PU类指令)，V流水线列的指令是在配对时可进入V流水线的指令(即UV类指令和PV类指令)。表中的操作符alu表示算术逻辑运算操作符，shift/rot表示移位或者循环操作符，jccnear表示条件转移指令，OFjcc表示转移范围扩充的条件转移指令，acc表示累加器，reg和r表示通用寄存器，m表示存储器操作数，r/m表示寄存器操作数或者存储器操作数，imm表示立即操作数。

![image](https://github.com/YangLuchao/img_host/raw/master/20231129/image.qo8k32aniw0.jpg)

==整型指令配对的基本规则(必要条件)如下==：

1. 配对的两条指令都不能是NP类指令，前一条指令不能是PV类指令，后一条指令不能是PU类指令。
2. 配对的两条指令必须已在指令超高速缓存中，而且已执行过。但如果前一条指令是单字节指令，那么该指令不受该项约束。例如，指令`PUSH EAX`就是单字节指令。
3. 除某些特别的配对指令外，配对的指令之间不能有隐式或显式的寄存器争用。稍后再介绍寄存器争用的概念和如何避免寄存器争用。
4. 如果指令的一个操作数由立即寻址方式确定，并且另一个操作数的寻址方式中使用了相对偏移，那么这样的指令不能参与配对。立即数和地址偏移可能是8位、16位或者32位。例如，指令`MOV BYTE PTR[EBX+1],12`，不能参与配对，属于NP类指令。所以，如果要多使用某个立即数，那么可先将其装入某个通用寄存器。
5. 指令基本长度(不包括前级)超过7字节的指令不能参与配对。如果随后的两条指令能够配对，那么前一条指令发到U流水线执行，后一条指令发到V流水线执行；如果不能配对，那么只有前一条指令发到U流水线执行，后一条指令将作为下次配对的前一条指令。

例如，设某个程序片段中的指令分类情况是：`PV1`、`PU2`、`PU3`、`UV4`和`NP5`，并设这5条指令不受上述规则其他条款的限制，那么流水线配对情况如下：PV1指令没有配对进入U流水线；PU2没有配对进入U流水线；PU3和UV4配对，PU3进入U流水线，UV4进入V流水线；NP没有配对，进入U流水线。

那么，如何提高配对机会？如何减少指令在流水线中的耽搁时间呢？下面就简单介绍这方面的技巧和方法。

### 3. 减少寄存器争用

数据相关能够导致寄存器争用。除某些特别的配对外，如果前后指令之间发生寄存器争用，那么就不能配对。显然，减少寄存器争用可提高配对机会。下列情况被视为寄存器争用：
(1)当前一条指令以某个寄存器为目标写，而后一条指令要引用该寄存器，就引起寄存器争用。例如：

```assembly
MOV EAX,8
MOV EBX,EAX
```

(2)当前后两条指令都以某个寄存器为目标写，也引起寄存器争用。例如：

```assembly
MOV EAX,[EBX]
ADD EAX,5
```

在判定寄存器争用时，访问32位寄存器的部分(字节或者字)被认为是对32位寄存器的访问。例如，如下两条指令被认为是争用寄存器EAX:

```assembly
MOV	AL,0
MOV	AH,1
```

但是，由于改变标志而影响标志寄存器，不认为是对标志寄存器的争用。
另外，如果前一条指令以某个寄存器为源读，而后一条指令以该寄存器为目标写，这种情况不认为是寄存器争用。例如：

```assembly
MOV EAX,EBX
MOV EBX,ECX
```

为了提高可配对的机会，Pentium对某些寄存器争用情况作了特殊处理，把这些经特殊处理的争用配对称为特别配对。特别配对主要涉及隐式读写堆栈指针寄存器ESP或者隐式写标志寄存器。如下指令对是特别配对的(以行为单位):

```assembly
PUSH 	reg/imm		PUSH 	reg/imm
PUSH 	reg/imm		CALL
POP 	reg			POP reg
CMP		Jcc			Jcc					;表示条件转移指令
ADD					JNE
```

减少寄存器争用的一个方法，是在保持程序原有逻辑的前提下调整指令次序。请考虑如下片段(假设是32位代码段，并且符合其他配对规则)。其中，L1至L4的4条指令争用寄存器ECX，导致它们不能配对；L5至L8的4条指令争用寄存器EDX，导致它们不能配对；只有L4和1.5处的两条指令可配对。

```assembly
L1: 	MOV 	ECX,[EAX+40]
L2:		ADD		ECX,EBX
L3:		AND		ECX,0FFFF0000H
L4:		MOV		[EAX+40],ECX
L5:		MOV		EDX,[EAX+80]
L6:		ADD		EDX,EBX
L7:		AND 	EDX,0FFFF0000H
L8:		MOV 	[EAX+80],EDX
```

现在调整指令次序如下，那么它们就能依次两两配对(假设符合其他配对规则):

```assembly
L1:		MOV 	ECX,[EAX+40]
L5:		MOV		EDX,[EAX+80]
L2:		ADD		ECX,EBX
L6:		ADD		EDX,EBX
L3: 	AND 	ECX,OXFFFF0000H
L7:		AND		EDX,OXFFFF0000H
LA:		MOV		[EAX+40],ECX
L8:		MOV 	[EAX+80],EDX
```

充分利用其他暂时不用的通用寄存器，也能够减少寄存器争用。

### 4. 减少地址形成相关现象

在某个通用寄存器作为基址寄存器或者变址寄存器用于计算有效地址时，如果该寄存器又是刚刚执行(发出)指令的目的寄存器，那么就出现地址形成相关(AddressGenerateInterlock)。由于在一个时钟内最多可执行两条指令，所以上述`刚刚执行`的指令可能间隔2条指令。例如，在执行如下两条指令时就会出现地址形成相关(AG1)现象：

```assembly
MOV		EBX,4
MOV		ECX,ESI
MOV		EAX,[EBX]
```

当出现地址相关现象时，那么在Pentium流水线的D2阶段会耽搁一个时钟。所以，为了提高流水线的效率，应该减少和避免地址形成相关现象的发生。
与调整指令次序可减少寄存器争用一样，通过调整指令次序的方法也可减少地址形成相关现象的发生。如下片段中的4条指令都是UV类指令，但由于L4指令把EBX作为基址寄存器，而L1指令以EBX为目标，发生地址形成相关，所以在不考虑其他因素的情况下，执行时要化3个时钟。

```assembly
L1:		ADD		EBX,4
L2: 	MOV		EAX,[ESI]
L3:		ADD		ECX,8
14:		MOV		[EBX],EAX
```

现在调整指令次序如下，避免了地址形成相关现象的发生，执行时只要化2个时钟：

```assembly
L2:		MOV 	EAX,[ESI]
L3:		ADD		ECX,8
L4:		MOV		[EBX+4],EAX		;注意该指令增加了相对偏移
L1:		ADD		EBX,4
```

### 5. 减少超高速缓存体的冲突

Pentium的数据超高速缓存由8个体构成，每个体宽4字节。它支持在两条流水线中执行的指令可以同时访问。在两条流水线中执行的配对指令，同时对同一个体的访问称为超高速缓存体冲突。如果出现超高速缓存体冲突，那么V流水中执行的指令在D2阶段被耽搁一个时钟。
例如，下面片段中的mem表示存储器操作数，L1指令和L2指令配对，被发到U流水线和V流水线并行执行。但L1指令和L2指令引起超高速缓存体冲突，在V流水线执行的L2指令在D2阶段被耽搁一个时钟。由于配对指令要一起离开D2阶段进入EX阶段，所以执行将被耽搁一个时钟。

```assembly
L1: MOV ECX,[EBX]
L2: MOV EDX,[EBX+32]
L3: ADD EAX,4
```

我们同样可采用调整指令次序的方法减少超高速缓存体冲突。例如，把上面的片段作如下调整，这样，L1指令和L3指令配对，就避免了超高速缓存体冲突：

```assembly
L1: MOV ECX,[EBX]
L3: ADD EAX,4
L2: MOV EDX,[EBX+32]
```

### 6. 选择合适的指令

80x86系列处理器的指令集越来越丰富，在实现某个功能时往往有多种选择，现在举例说明如何选择合适的指令，以增加指令配对的机会。

#### (1) 充分利用单字节指令

在指令超高速缓存中的指令才能够配对这条规则有个例外，也即如果前一条指令是单字节指令，那么该指令可不在超高速缓存中。所以，要多采用单字节指令。请比较如下左右两边的指令(以行位单位):

```assembly
XCHG 	ECX,EBX			XCHG 	EAX,EBX
ADD		ESI,1			INC		ESI	
SUB		EDX,1			DEC 	EDX
```

#### (2)考虑使用多条单时钟指令代替一条多时钟指令

所谓单时钟指令是指只要化一个时钟就可执行的指令，许多指令是单时钟指令。所谓多时钟指令是指执行时要化多个时钟的指令，以存储器操作数为目标操作数的算术逻辑运算指令不是单时钟指令，执行这样的指令往往要化3个时钟。尽管用多条单时钟指令代替一条多时钟指令一般会增加代码长度，可能还要使用更多的寄存器，但有时用这种方法可增加指令配对机会，提高流水线效率。
例如，如下右边的3条单时钟指令可代替左边的一条3时钟指令：

```assembly
ADD 	[EBX],ECX			MOV 	EAX,[EBX]
							ADD 	EAX,ECX
							MOV		[EBX],EAX
```

尽管右边的3条指令之间由于寄存器争用不能配对，但首末2条指令可能和上下指令配对，即使仍不配对都在U流水线执行，也只要花3个时钟。另外，两条流水线中的指令要同时退出EX阶段，所以某条流水线被耽搁，会影响到另一条流水线；由于Pentium对存储器的访问仍保持顺序执行时的次序，只有在U流水线中的指令完成需要的存储器访问后，V流水线中可能有的配对指令才能够进行存储器访问。因此，上述左边指令可能多耽搁流水线超过2个时钟，而右边的片段可避免由于存储访问而耽搁流水线。
如下左边的2条指令用右边6条指令代替后，可收到较好的效果，实际上可避免流水线被耽搁：

```assembly
INC 	DWORD PTR [EBX]				MOV 	ECX,[EBX]
INC 	DWORD PTR [EBX+4]			MOV 	EDX,[EBX+4]
									INC 	ECX
									INC 	EDX
									MOV 	[EBX],ECX
									MOV 	[EBX+4],EDX
```

以存储器操作位目标操作数的算术逻辑运算指令一般都可采用上述方法。但必须注意，这种方法的代价是增加目标代码长度和占用其他寄存器。

#### (3) 避免使用NP类指令

有某些指令不仅是NP类指令，而且执行时要花多个时钟。为了提高指令配对机会，提高流水线效率，可考虑用多条指令代替它。这类似于用多条单时钟指令代替一条多时钟指令，这种方法通常会增加目标代码长度。
例如，循环指令LOOP，要花5至8个时钟，而且属于NP类指令。用如下两条指令代替指令LOOP后，可减少分支指令执行时钟，而且增加指令配对机会：

```assembly
DEC		ECX
JNZ 	NEXT		;NEXT是标号
```

例如，建立堆栈框架指令ENTER，要花10个以上的时钟，而且属于NP类指令。用如下3条指令代替指令`ENTER BCOUNT,0`后，可提高流水线效率，而且增加指令配对机会：

```assembly
PUSH 	EBP
MOV 	EBP,ESP
SUB 	ESP,BCOUNT		;BCOUNT是常数
```

例如，符号扩展指令CDQ，属于NP类指令。用如下2条指令代替指令CDQ后，可增加指令配对机会。虽然CDQ指令花2个时钟，如下两条指令也要化2个时钟，但增加了与前后指令的配对机会：

```assembly
MOV 	EDX,EAX
SAR 	EDX,31		;该指令属于PU类指令
```

### 7. 由指令前缘带来的副作用

80x86系列处理器，通过在正常指令之前添加前缀的方法，有效地改变或者扩充了指令原有功能。例如，使用段超越前缀可方便地实现跨段访问；使用操作数尺寸前缀和地址长度前缀可灵活地实现16位代码和32位代码的混合。可能的前级有段超越前级、重复前缀、封锁前缀、操作数尺寸前级(66H)、地址长度前级(67H)和操作码扩充前缴等原本属于UV类的指令，由于添加了前缀，只能发到U流水线，也就是说在配对时只能作为PU类指令。实际上，指令的各个前缀依次都发到U流水线，然后基本指令再参加可能的配对发到U流水线。只有扩充的增加转移范围的条件转移指令所具有的前缀(0FH)是例外。
在16位代码段(实方式下的代码段是16位代码段)中，如果使用32位操作数或者32位地址，那么指令就带有操作数前缀或者地址长度前缀；在32位代码段中，如果使用16位操作数或者16位地址，那么指令就带有操作数前缀或者地址长度前级。因此，要减少16位代码和32位代码的混用，特别是在32位代码段中，要减少使用16位寄存器和减少16位存储器操作数地址。
尽管利用段超越前缀的方法可方便地访问多个段，但这会带来前缀，所以要尽量通过DS访问数据段。

## 11.4.2 分支优化技术

Pentium具有动态分支预测能力。在采用流水线方式执行指令后，如果不能有效地预测分支转移目标，那么转移就会导致流水线被冲洗，严重降低流水线处理效率。

### 1. 动态分支预测

Pentium利用一个称为分支目标缓存器(BranchTargetBuffer)的超高速缓存，实现动态分支预测。分支目标缓存器(BTB)是一个4路组相关联的超高速缓存，共有256项，分为64组。访问BTB时使用的标记是分支指令的地址。BTB项的主要内容是对应位置处转移指令的转移目标地址，该地址就作为预测的转移目标地址。
在流水线的开始阶段对转移指令的转移目标地址进行预测。在流水线的后期阶段，根据实际转移地址修正预测地址。但并非每当根据BTB项作出的预测不正确时，就一定用实际转移地址来修正预测地址。BTB项除记录转移目标地址外，还有2位用于记录对应转移指令的转移历史信息。在修正预测地址时，还根据历史信息位作出是否要改变BTB中记录的转移目标地址的判断。这可避免因一次偶尔的转移变化，导致预测不正确。在连续两次BTB预测不正确的情况下，那么改变BTB中记录的该分支指令转移目标地址。表11.8列出了对在某个循环中的如下转移指令的动态预测情况，设EBX的初值是26H:

```assembly
		SHR EBX,1			;EBX初值是00100110B
		JC NEXT
		......
NEXT:	......
```

![image](https://github.com/YangLuchao/img_host/raw/master/20231129/image.311rygza0z00.jpg)

如果BTB已记录了预取的转移指令的转移目标地址，那么Pentium就预测该地址是要转移的目标地址。如果BTB还没有记录预取转移指令的转移目标地址，也即无法根据BTB作出预测，那么Pentium就预测为不发生转移。在不是根据BTB作出预测的情况下，如果预测正确，那么不把该顺序地址保存到对应的BTB项；如果预测不正确，那么就把实际转移地址保存到对应的BTB项。请参见表11.8，最初情况是BTB没有记录预取转移指令的转移目标地址。
如果预测正确，Pentium流水线并未被耽搁；如果预测不正确，那么流水线将被冲洗，为此要耽搁3或4个时钟。
为了提高流水线的效率，应该减少分支转移，提高预测正确程度。下面就简单介绍这方面的技巧和方法。

### 2.调整基本片段位置

所谓基本片段是指只有一个入口和出口的顺序执行的片段。所谓调整基本片段的位置是指：把使用频率高的基本片段安排在分支转移指令之后的位置处，也即使得最经常的分支是直行的；把使用频率低的基本片段安排得尽可能离开使用频率高的基本片段。这样的安排，不仅提高可预测程度，而且可减少把很少执行的代码预取入超高速缓存，还可减少对BTB项的占用。
图11.10给出了一个简单分支所涉及的两个基本片段的调整情况。设BB3是经常使用的片段，而BB2是不太使用的基本片段。图的左边是调整前的情况，右边是调整后的情况。尽管调整后的目标代码可能增长，而且还增加了转移指令，但当BB3片段的使用频率明显超过BB2片段使用频率时，调整后的执行效率会较好。因为，在多数情况下，将直接执行BB3片段。

![image](https://github.com/YangLuchao/img_host/raw/master/20231129/image.1acvskmowvcw.jpg)

### 3. 代替条件转移指令

有时可用无分支转移的程序片段代替含分支转移的程序片段，从而消除分支。有两种常用的代替方法：一种是用条件字节设置指令SETcc代替条件转移指令Jcc;另一种方法是用带进位CF操作的ADC或SBB指令代替条件转移指令Jcc。如下两个并列的程序片段，完成相同的功能(r3=rlaer2?1:0)，其中的r1、r2和r3分别表示通用寄存器。左边的片段含转移指令；右边的片段没有转移指令，效率要高于左边的片段。所以，通常情况下应该使用右边的片段代替左边的片段。

```assembly
		CMP		r1,r2			XOR 	r3,r3
		MOV 	r3,1			CMP 	r1,r2
		Jae 	NEXT			SETae 	r3
		MOV 	r3,0
NEXT:
```

如下两个并列的程序片段，都能完成更一般化的功能，`r3 = r1 cc r2 ? CONST1 : CONST2`，其中的r1、r2和r3分别表示通用寄存器，cc表示条件，CONST1和CONST2分别表示常数。

```assembly
	CMP rl,r2				XOR r3,r3
	MOV r3,CONST1			CMP r1,r2
	Jcc NEXT				SETcc r3L 				;r3L表示r3低8位寄存器
	MOV 13,CONST2			DEC r3
NEXT:
							AND r3,CONST2-CONST1
							ADD r3,CONST1			;如CONST1为0,可省
```

上述左边的片段含有条件转移指令，右边的片段没有转移指令。是否要用右边的片段代替左边的片段，取决于左边片段的平均效率。
如下程序片段是利用带CF位的SBB指令代替条件转移指令的一个例子。程序片段的功能是根据EBX内容的正负设置EDX的值(正时EDX为0，负时EDX为-1)。右边片段的效率比左边片段的效率要好。

```assembly
CMP 	EAX.0			SHL 	EAX,1
MOV 	EDX,-1			SBB 	EDX,EDX
JS 		NEXT
MOV 	EDX,0
```

如下程序片段是利用带CF的ADC指令代替条件转移指令的一个例子。其中，r1，r2，r3是寄存器，CONST是常数。片段的功能是实现`r3 = (r1 ne r2) ? const : 0`。但在某个程序中是否要用右边的片段代替左边的片段，要视具体情况而定：

```assembly
	CMP		r1,r2			SUB 	r1,r2
	MOV 	13,CONST		CMP 	r1,1
	JNE 	NEXT			MOV 	r3,0
	MOV 	r3,0			ADC 	r3,-1
NEXT:
							AND r3,CONST
```

另一个更一般的例子如下，它们的功能是实现`r3= (rl e r2) ? CONST1 : CONST2`

```assembly
	CMP r1,r2			SUB r1.r2
	MOV r3,CONST1		CMP r1.1
	JE NEXT				SBB r3,r3
	MOV 13,CONST2		AND r3,CONST1-CONST2
NEXT:
						ADD r3,CONST2
```

## 11.4.3 超高速缓存优化技术

Pentium的指令超高速缓存和数据超高速缓存是独立的，各有8K字节；都采用二路组相关联结构，都分成128组，每组2行，每行宽32字节；都使用物理地址访问；都采用最近最少使用淘汰算法。Pentium片上超高速缓存能够支持在一个时钟内进行2次数据访问和获取32字节的原始代码。但是，如果不能命中片上超高速缓存，那么至少要耽搁3个时钟；如果还没有命中机器系统的2级高速缓存，或者机器没有2级高速缓存，那么要耽搁的时间更多，达7个时钟。理想情况下，Pentium在7个时钟内可能执行14条指令。所以，根据超高速缓存的特点，安排数据和组织代码对提高程序的效率是极其重要的。

### 1. 对齐访问

尽管Pentium能够存取任何字节边界处的数据，但对数据超高速缓存不对齐的访问要多花3个时钟。所以，应该尽量实现对齐访问。也就是说，对2字节数据的访问应在2字节边界处进行，至少不跨越4字节边界；对4字节数据的访问应在4字节边界处进行；对8字节数据的访问应在8字节边界处进行。
例如，如下两条指令左边的访问不对齐，右边的访问对齐，设数据已在超高速缓存中，那么左边的不对齐访问要比右边的对齐访问多花3个时钟：

```assembly
MOV EAX,[0005H]
MOV EAX,[0004H]
```

例如，设EBX的内容是`xxxx0H`，在不考虑其他因素影响的情况下，那么如下三条指令的访问要比指令`MOV AX,[EBX+3]`快：

```assembly
MOV AX,[EBX]
MOV AX,[EBX+1]
MOV AX,[EBX+2]
```

因此，在定义变量和缓冲区时，要注意数据对齐。在定义结构类型时，要注意各字段位置的安排，以便结构变量字段的对齐和结构数组的对齐。
例如，如下两个结构类型的定义，结构STRUBB比STRUAA要好。当然，假设利用这些结构类型定义的结构变量或者结构数组是对齐的。

```assembly
STRUAA 	STRUC
	VARB1 	DB ?
	VARW 	DW ?
	VARD 	DD ?
	VARB2 	DB ?
STRUAA 	ENDS
;
STRUBB STRUC
	VARB1 	DB ?
	VARB2 	DB ?		;即使无需VARB2字段，也宜添一个字节
	VARW 	DW ?		;以便对齐
	VARD 	DD ?
STRUBB 	ENDS
```

注意，为了做到对齐访问，可能要浪费部分存储单元。

### 2. 访问数据相对集中

通常程序运行时所执行的指令和所访问的数据各自相对集中，而且越是被多次访问的数据越有可能再被访问。高速缓存正是根据这些特点设计的。为了充分利用超高速缓存，在安排数据和组织代码时要注意相对集中。具体地说是数据相对集中和访问相同数据的代码相对集中。相对集中可使得被访问的数据尽量已出现在超高速缓存中。
例如，假设要对一组数据进行两项操作，如果分别用两个循环来处理，那么把这两个循环安排得较近为好。如果数据组较大，那么应该考虑把这两个循环合为一个循环。

### 3.缩短代码长度

尽量使当前活跃的代码长度在8K字节范围内，以适合指令缓冲区。算法的改进是缩短代码长度的主要手段。此外还有一些选择指令的小技巧。
采用一条多时钟的指令代替多条单时钟的指令能有效地缩短目标代码长度。但前面已提及，这种方法会减少指令配对机会，在取舍时要综合考虑。
充分利用32位寻址方式。例如，如下的指令片段可用一条指令`MOVE CX,[EBX+EDX*8+32]`代替：

```assembly
SHL EDX.3
ADD EBX,EDX
ADD EBX,32
MOV ECX,[EBX]
```

利用LEA指令往往可方便地实现多个操作数相加。并且LEA指令是UV类指令，执行时只要花一个时钟。但要注意，LEA指令可能会增加AGI现象的发生。

例如，如下的程序片段，可用一条指令`LEA ECX,[EAX+EBX*4+CONSTV]`代替，其中CONSTV是常数：

```assembly
MOV ECX,EBX
SHL ECX,2
ADD ECX,EAX
ADD ECX,CONSTV
```

注意采用较短的指令。在11.4.1指出了单字节指令便于配对的优点，显然单字节指令也能够缩短目标代码，但多数情况是无法用单字节指令实现的。在使用多字节指令时，要注意选择较短的多字节指令。例如，如下左右两个片段多根据EBX的内容是否为0进行分支，但右边的片段较短：

```assembly
CMP EBX,0
OR 	EBX,EBX
JNZ	NEXT
JNZ NEXT
```

当条件转移指令和无条件转移指令的转移范围较小时，要用`SHORT`明确说明，这样可只用1字节表示地址差。例如，如果上述条件转移指令中的标号NEXT较近，并且是向前引用，那么在其前加上`SHORT`可节省3个字节(设32位代码)。